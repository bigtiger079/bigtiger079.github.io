<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Bigtiger&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Bigtiger's blog">
<meta property="og:url" content="http://www.bigtiger079.com/page/2/index.html">
<meta property="og:site_name" content="Bigtiger's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bigtiger's blog">
<meta name="twitter:description">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xlrpi.com1.z0.glb.clouddn.com/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Bigtiger</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/categories">分类</a></li>
				        
							<li><a href="/tags">标签</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="mail" target="_blank" href="/bigtiger079@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/Cpp基础/" style="font-size: 10px;">Cpp基础</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JNI/" style="font-size: 10px;">JNI</a> <a href="/tags/RecyclerView/" style="font-size: 16.67px;">RecyclerView</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/linux/" style="font-size: 20px;">linux</a> <a href="/tags/线性表/" style="font-size: 13.33px;">线性表</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Bigtiger</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xlrpi.com1.z0.glb.clouddn.com/avatar.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Bigtiger</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories">分类</a></li>
		        
					<li><a href="/tags">标签</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="mail" target="_blank" href="/bigtiger079@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-线性表的链式存储" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/02/线性表的链式存储/" class="article-date">
  	<time datetime="2015-10-02T11:58:27.000Z" itemprop="datePublished">2015-10-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/02/线性表的链式存储/">线性表的链式存储</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>链式存储定义</strong><br>为了表示每个数据元素与其直接后继元素之间的逻辑关系，每个元素除了存储本身的信息外，还需要存储指示其直接后继的信息。<br><img src="http://7xlrdt.com1.z0.glb.clouddn.com/lianbiao_xinxi.png" alt=""></p>
<p>n个节点(ai的存储映像)链接成一个链表, 即为线性表(a1, a2, …, an)的链式存储结构, 因为此链表的每一个节点中只包含一个指针域, 所以叫做单链表. 单链表正是通过每个节点的指针域将线性表的数据元素按期逻辑次序链接在一起<br><img src="http://7xlrdt.com1.z0.glb.clouddn.com/linabiao_list_2.png" alt=""></p>
<p><strong>表头结点</strong><br>链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息<br><strong>数据结点</strong><br>链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息<br><strong>尾结点</strong><br>链表中的最后一个数据结点，其下一元素指针为空，表示无后继。</p>
<h3 id="u8BBE_u8BA1_u4E0E_u5B9E_u73B0"><a href="#u8BBE_u8BA1_u4E0E_u5B9E_u73B0" class="headerlink" title="设计与实现"></a>设计与实现</h3><p>在C语言中可以用结构体来定义链表中的指针域<br>链表中的表头结点也可以用结构体实现</p>
<h4 id="u8282_u70B9_u6307_u9488_u57DF_u5B9A_u4E49"><a href="#u8282_u70B9_u6307_u9488_u57DF_u5B9A_u4E49" class="headerlink" title="节点指针域定义"></a>节点指针域定义</h4><pre><code>typedef struct _tag_LinkListNode LinkListNode;
struct _tag_LinkListNode
{
    LinkListNode* next;
} 
</code></pre><h4 id="u5934_u7ED3_u70B9_u5B9A_u4E49"><a href="#u5934_u7ED3_u70B9_u5B9A_u4E49" class="headerlink" title="头结点定义"></a>头结点定义</h4><pre><code>typedef struct _tag_LinkList
{
    LinkListNode header;
    int length;
}TLinkList 
</code></pre><h4 id="u6570_u636E_u5143_u7D20_u5B9A_u4E49"><a href="#u6570_u636E_u5143_u7D20_u5B9A_u4E49" class="headerlink" title="数据元素定义"></a>数据元素定义</h4><pre><code>struct Value
{
    LinkListNode header;
    int v;
}TLinkList 
</code></pre><h4 id="u6587_u4EF6_u5B9A_u4E49"><a href="#u6587_u4EF6_u5B9A_u4E49" class="headerlink" title="文件定义"></a>文件定义</h4><pre><code>#ifndef _MYLINKLIST_H_
#define _MYLINKLIST_H_

typedef void LinkList;
/*
typedef struct _tag_LinkListNode LinkListNode;
struct _tag_LinkListNode
{
    LinkListNode* next;
};
*/

typedef struct _tag_LinkListNode
{
    struct _tag_LinkListNode* next;
}LinkListNode;

LinkList* LinkList_Create();

void LinkList_Destroy(LinkList* list);

void LinkList_Clear(LinkList* list);

int LinkList_Length(LinkList* list);

int LinkList_Insert(LinkList* list, LinkListNode* node, int pos);

LinkListNode* LinkList_Get(LinkList* list, int pos);

LinkListNode* LinkList_Delete(LinkList* list, int pos);

#endif
</code></pre><h4 id="u521B_u5EFA_u548C_u9500_u6BC1"><a href="#u521B_u5EFA_u548C_u9500_u6BC1" class="headerlink" title="创建和销毁"></a>创建和销毁</h4><pre><code>LinkList* LinkList_Create()
{
    TLinkList *tList = (TLinkList *)malloc(sizeof(TLinkList));
    if (tList == NULL)
    {
        return NULL;
    }
    tList-&gt;header.next = NULL;
    tList-&gt;length = 0;
    return tList;
}

void LinkList_Destroy(LinkList* list)
{
    if (list != NULL)
    {
        free(list);
    }
    return ;
}

void LinkList_Clear(LinkList* list)
{
    TLinkList *tList = list;
    if (tList == NULL)
    {
        return ;
    }
    tList-&gt;length = 0;
    tList-&gt;header.next = NULL;
    return ;
}
</code></pre><h4 id="u83B7_u53D6_u94FE_u8868_u7684_u957F_u5EA6"><a href="#u83B7_u53D6_u94FE_u8868_u7684_u957F_u5EA6" class="headerlink" title="获取链表的长度"></a>获取链表的长度</h4><pre><code>int LinkList_Length(LinkList* list)
{
    TLinkList *tList = list;
    if (tList == NULL)
    {
        return -1;
    }
    return tList-&gt;length;
}
</code></pre><h4 id="u94FE_u8868_u7684_u64CD_u4F5C"><a href="#u94FE_u8868_u7684_u64CD_u4F5C" class="headerlink" title="链表的操作"></a>链表的操作</h4><pre><code>int LinkList_Insert(LinkList* list, LinkListNode* node, int pos)
{
    int i = 0;
    TLinkList  *tList = (TLinkList *)list;
    LinkListNode  *current = NULL;

    if (tList == NULL || node == NULL || pos&lt;0)
    {
        return -1;
    }
    current = &amp;tList-&gt;header;
    //current = (LinkListNode *)list;

    for (i=0; (i&lt;pos)&amp;&amp;current-&gt;next!=NULL; i++ )
    {
        current = current-&gt;next;
    }
    //新节点链接后续链表
    node-&gt;next = current-&gt;next;
    //前面链表链接node
    current-&gt;next = node;
    tList-&gt;length ++;

    return 0;
}

LinkListNode* LinkList_Get(LinkList* list, int pos)
{
    int i = 0;
    TLinkList  *tList = (TLinkList *)list;
    LinkListNode  *current = NULL;
    LinkListNode  *ret = NULL;

    if (list==NULL || pos&lt;0 || pos&gt;=tList-&gt;length)
    {
        return NULL;
    }

    current = &amp;tList-&gt;header;
    for (i=0; i&lt;pos; i++)
    {
        current = current-&gt;next;
    }
    ret = current-&gt;next;

    return ret;
}

LinkListNode* LinkList_Delete(LinkList* list, int pos)
{
    int i = 0;
    TLinkList  *tList = (TLinkList *)list;
    LinkListNode  *current = NULL;
    LinkListNode  *ret = NULL;

    if (list==NULL || pos&lt;0 || pos&gt;=tList-&gt;length)
    {
        return NULL;
    }
    //没有初始化环境
    current = &amp;tList-&gt;header;
    for (i=0; i&lt;pos; i++)
    {
        current = current-&gt;next;
    }
    ret = current-&gt;next;

    current-&gt;next = ret-&gt;next;
    tList-&gt;length --;
    return ret;
}
</code></pre><h3 id="u4F18_u70B9_u548C_u7F3A_u70B9"><a href="#u4F18_u70B9_u548C_u7F3A_u70B9" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>无需一次性定制链表的容量</li>
<li>插入和删除操作无需移动数据元素</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>数据元素必须保存后继元素的位置信息</li>
<li>获取指定数据的元素操作需要顺序访问之前的元素</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线性表/">线性表</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C/">C++</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-线性表-顺序存储的开发和设计" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/30/线性表-顺序存储的开发和设计/" class="article-date">
  	<time datetime="2015-09-30T04:02:27.000Z" itemprop="datePublished">2015-09-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/30/线性表-顺序存储的开发和设计/">线性表-顺序存储的开发和设计</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u7EBF_u6027_u8868_u57FA_u672C_u6982_u5FF5"><a href="#u7EBF_u6027_u8868_u57FA_u672C_u6982_u5FF5" class="headerlink" title="线性表基本概念"></a>线性表基本概念</h2><h3 id="u7EBF_u6027_u8868_u5B9A_u4E49"><a href="#u7EBF_u6027_u8868_u5B9A_u4E49" class="headerlink" title="线性表定义"></a>线性表定义</h3><ul>
<li>线性表(List)是零个或多个数据元素的集合 </li>
<li>线性表中的数据元素之间是有顺序的</li>
<li>线性表中的数据元素个数是有限的</li>
<li>线性表中的数据元素的类型必须相同<br><img src="http://7xlrdt.com1.z0.glb.clouddn.com/lianbiao_xingzuo.png" alt=""></li>
</ul>
<p><strong>数学定义</strong><br>线性表是具有相同类型的 n（ ≥ 0）个数据元素的有限序列（a1, a2, …, an）<br>ai是表项，n 是表长度。</p>
<p><strong>性质</strong><br>a0为线性表的第一个元素，只有一个后继<br> an为线性表的最后一个元素，只有一个前驱<br>除a0和an外的其它元素ai，既有前驱，又有后继<br>线性表能够逐项访问和顺序存取</p>
<h3 id="u7EBF_u6027_u8868_u7684_u64CD_u4F5C"><a href="#u7EBF_u6027_u8868_u7684_u64CD_u4F5C" class="headerlink" title="线性表的操作"></a>线性表的操作</h3><ul>
<li>创建线性表</li>
<li>销毁线性表</li>
<li>清空线性表</li>
<li>将元素插入线性表</li>
<li>将元素从线性表中删除</li>
<li>获取线性表中某个位置的元素</li>
<li>获取线性表的长度</li>
</ul>
<p>线性表在程序中表现为一种特殊的数据类型<br>线性表的操作在程序中的表现为一组函数</p>
<h2 id="h_u6587_u4EF6"><a href="#h_u6587_u4EF6" class="headerlink" title=".h文件"></a>.h文件</h2><pre><code>#ifndef  __MY_SEQLIST_H__
#define __MY_SEQLIST_H__

// #define  ERR_BASE  0
// #define ERR_PARAM   ERR_BASE -1;

//创建并且返回一个空的线性表
List* SeqList_Create();

//销毁一个线性表list
void List_Destroy(List* list);

//将一个线性表list中的所有元素清空, 线性表回到创建时的初始状态
void List_Clear(List* list);

//返回一个线性表list中的所有元素个数
int List_Length(List* list);

//向一个线性表list的pos位置处插入新元素node
int List_Insert(List* list, ListNode* node, int pos);

//获取一个线性表list的pos位置处的元素
ListNode* List_Get(List* list, int pos);

//删除一个线性表list的pos位置处的元素  返回值为被删除的元素，NULL表示删除失败
ListNode* List_Delete(List* list, int pos);

#endif  //__MY_SEQLIST_H__
</code></pre><h2 id="u7EBF_u6027_u8868_u7684_u987A_u5E8F_u5B58_u50A8_u7ED3_u6784"><a href="#u7EBF_u6027_u8868_u7684_u987A_u5E8F_u5B58_u50A8_u7ED3_u6784" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><p><strong>基本概念</strong><br>线性表的顺序存储结构, 指的是用一段地址连续的存储单元一次存储线性表的数据元素</p>
<h3 id="u8BBE_u8BA1_u4E0E_u5B9E_u73B0"><a href="#u8BBE_u8BA1_u4E0E_u5B9E_u73B0" class="headerlink" title="设计与实现"></a>设计与实现</h3><p><strong>插入元素算法</strong></p>
<ol>
<li>判断线性表是否合法</li>
<li>判断插入位置是否合法</li>
<li>把最后一个元素到插入位置的元素后移一个位置</li>
<li>将新元素插入</li>
<li>线性表长度加1</li>
</ol>
<p><strong>获取元素操作</strong></p>
<ol>
<li>判断线性表是否合法</li>
<li>判断位置是否合法</li>
<li>直接通过数组下标的方式获取元素</li>
</ol>
<p><strong>删除元素算法</strong></p>
<ol>
<li>判断线性表是否合法</li>
<li>判断删除位置是否合法</li>
<li>将元素取出</li>
<li>将删除位置后的元素分别向前移动一个位置</li>
<li>线性表长度减1</li>
</ol>
<h3 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h3><pre><code>#include &quot;stdlib.h&quot;
#include &quot;stdio.h&quot;
#include &quot;string.h&quot;
#include &quot;seqlist.h&quot;

typedef struct _tag_SeqList
{
    int capaticy;
    int length;
    unsigned int *node;
}TSeqList
</code></pre><h3 id="u94FE_u8868_u7684_u521B_u5EFA"><a href="#u94FE_u8868_u7684_u521B_u5EFA" class="headerlink" title="链表的创建"></a>链表的创建</h3><pre><code>void * SeqList_Create(int capacity)
{
    TSeqList *ret = NULL;
    if(capacity &lt; 1)
    {
        return NULL;
    }
    ret = (TSeqList *)malloc(sizeof(TSqList));
    if(ret == NULL)
    {
        return NULL;
    }
    ret -&gt;capatcy = capacity;
    ret -&gt;node = (unsigned int *)malloc(sizeof(unsigned *)* capacity);
    if(ret -&gt;node == NULL)
    {
        return NULL;
    }
    ret -&gt;length = 0;
    return ret;
}
</code></pre><p>创建时molloc内存的第二种方式</p>
<pre><code>void * SeqList_Create(int capacity)
{
    TSeqList *ret = NULL;
    //这里将数据内存和节点内存同时molloc出来
    ret = (TSeqList *)malloc(sizeof(TSqList) +　sizeof(unsigned *)* capacity);
    if(ret == NULL)
    {
        return NULL;
    }
    ret -&gt;capatcy = capacity;
    ret -&gt;node = (unsigned int *)(ret+1);
    ret -&gt;length = 0;
    return ret;
}
</code></pre><p>###链表的销毁</p>
<pre><code>void SeqList_Destory(SeqList * list)
{
    if(list == NULL)
    {
        return;
    }
    free(list);
    return;
}
</code></pre><h3 id="u94FE_u8868_u7684_u76F8_u5173_u5C5E_u6027_u7684_u83B7_u53D6"><a href="#u94FE_u8868_u7684_u76F8_u5173_u5C5E_u6027_u7684_u83B7_u53D6" class="headerlink" title="链表的相关属性的获取"></a>链表的相关属性的获取</h3><pre><code>//获取链表的长度
int SeqList_Length(SeqList* list)
{
    //TSeqList *tlist = list;   这里list的地址跟TSeqList的首地址相同, 因此也可以直接赋值
    TSeqList *tlist = (TSeqList *)list;
    if(tlist == NULL)
    {
        return -1;
    }
    return tlist -&gt;length;
}

//获取链表的容量
int SeqList_Capaticy(SeqList* list)
{
    TSeqList *tlist = (TSeqList *)list;
    if(tlist == NULL)
    {
        return -1;
    }
    return tlist-&gt;capaticy;
}
</code></pre><h3 id="u94FE_u8868_u7684_u64CD_u4F5C_28_u589E_u5220_u6539_u67E5_29"><a href="#u94FE_u8868_u7684_u64CD_u4F5C_28_u589E_u5220_u6539_u67E5_29" class="headerlink" title="链表的操作(增删改查)"></a>链表的操作(增删改查)</h3><pre><code>void SeqList_Clear(SeqList* list)
{
    TSeqList *tlist = (TSeqList *)list;
    if(tlist == NULL)
    {
        return;
    }
    tlist -&gt;length = 0;
    return;
}
</code></pre><h4 id="u63D2_u5165_u64CD_u4F5C"><a href="#u63D2_u5165_u64CD_u4F5C" class="headerlink" title="插入操作"></a>插入操作</h4><pre><code>int SeqList_Inster(SeqList* list, SeqListNode* node, int pos)
{
    int i = 0;
    TSeqList *tlist = (TSeqList *)list;
    if(list == NULL || node == NULL)
    {
        return -1;
    }
    if(pos&lt;0 || pos &gt; tlist-&gt;capaticy)
    {
        return -2;
    }
    if(tlist-&gt;length &gt;= tlist-&gt;capaticy)//判断是否已满
    {
        return -3;
    }
    if(pos &gt; tlist-&gt;length)//容错
    {    
        pos = tlist-&gt;length;
    }

    //插入算法有两步
    //从插入的位置后移元素
    for(int i = tlist-&gt;length; i &gt; pos; i++)
    {
        tlist-&gt;node[i] = tlist-&gt;node[i - 1];
    }
    //在pos位置插入元素
    tlist-&gt;node[pos] = (unsigned int)node;//这个地方转换的时候不能加*
    tlist-&gt;length++;
    return 0;
}
</code></pre><blockquote>
<p>注意 length 能表示出现在数组的最后元素位置,最后元素的下标为: tlist-&gt;node[i-1];</p>
</blockquote>
<h4 id="u67E5_u627E_u548C_u5220_u9664_u64CD_u4F5C"><a href="#u67E5_u627E_u548C_u5220_u9664_u64CD_u4F5C" class="headerlink" title="查找和删除操作"></a>查找和删除操作</h4><pre><code>SeqListNode* SeqList_Get(SeqList* list, int pos)
{
    int i = 0;
    TSeqList *tlist = (TSeqList *)list;
    if(list == NULL || pos &lt; 0 || pos&gt; tlist-&gt;length)
    {
        return NULL;
    }
    return (SeqListNode *)tlist-&gt;node[pos];
}

SeqListNode* SeqList_Delete(SeqList* list, int pos)
{
    int i = 0;
    TSeqList *tlist = (TSeqList *)list;
    SeqListNode* ret = NULL;
    if(list == NULL || pos&lt;0 || pos&gt;tlist-&gt;length)
    {
        return NULL;
    }
    ret = (SeqListNode*)tlist-&gt;node[pos];
    for(i = pos-1; i&lt;tlist-&gt;length; i++ )
    {
        tlist-&gt;node[i-1] = tlist-&gt;node[i];
    }
    tlist-&gt;length--;
    return ret;
}
</code></pre><h3 id="u4F18_u70B9_u548C_u7F3A_u70B9"><a href="#u4F18_u70B9_u548C_u7F3A_u70B9" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>无需为线性表中的逻辑关系增加额外的空间</li>
<li>可以快速的获取表中合法位置的元素</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>插入和删除操作需要移动大量元素</li>
<li>当线性表长度变化较大时难以确定存储空间的容量</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线性表/">线性表</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C/">C++</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-STL入门" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/22/STL入门/" class="article-date">
  	<time datetime="2015-09-22T04:00:32.000Z" itemprop="datePublished">2015-09-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/22/STL入门/">STL入门</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="STL_u5165_u95E8"><a href="#STL_u5165_u95E8" class="headerlink" title="STL入门"></a>STL入门</h1><ul>
<li>导入</li>
<li>STL的概念与组成</li>
<li>Iterator（迭代器） </li>
<li>Container（容器）</li>
<li>Algorithm（算法）</li>
<li>Adaptors（配接器）</li>
</ul>
<h2 id="u5BFC_u5165"><a href="#u5BFC_u5165" class="headerlink" title="导入"></a>导入</h2><p>抽象的重要性</p>
<ul>
<li><p>计算机科学的重要进步，许多是由于发掘了新的抽象性质而促成的</p>
</li>
<li><p>面向过程 －＞基于对象 －＞面向对象　-&gt;泛型</p>
</li>
</ul>
<p>面向过程(Procedure-Oriented)的抽象</p>
<ul>
<li><p>抽象出Procedure（Function）的概念，把程序分成若干个子过程。将事物的方法隐藏于各个函数内－－C语言。</p>
</li>
<li><p>适用于处理小型的程序。对大型程序，   子程序之间关系复杂，不易处理变化的需求－－引发软件危机的原因－－需要新的抽象。</p>
</li>
</ul>
<p>面向过程示例</p>
<pre><code>#include &lt;iostream&gt;
using namespace std
void function()
{
    //function很好的隐藏了一系列方法
    ...
}

int main()
{
    function(); //调用子过程时不用考虑其实现细节
}
</code></pre><ul>
<li><p>基于对象(Object-Based)的抽象<br>引入抽象数据类型（ADT，Abstract Data Type）。C++的类，将事物的属性与方法紧密地结合在一起－－VB、带类的C。</p>
</li>
<li><p>与面向过程相比，可以更好地处理变化，一定程度上化解了软件危机。但各个类之间的关系不容易处理，而且程序代码数量比面向过程时更大－－需要新的抽象。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std

//方法(getName) 与属性(name)的紧密结合增加了抽象性
class Person
{
    public: 
        char *getName();
    private:
        char *name;
}
void main()
{
    Person p;
    cout &lt;&lt; &quot;This person&apos;s name is:&quot; &lt;&lt; p.getNmae();
}
</code></pre></li>
</ul>
<p>面向对象(Object-Oriented)的抽象</p>
<ul>
<li><p>抽象出封装、继承、多态( polymorphic )的概念。</p>
</li>
<li><p>与基于对象相比，有更多的间接性。运用多态，我们可以调用某种方法，而不用指定此方法所属的类型。因而达到更进一步的抽象性。</p>
</li>
<li><p>它为我们带来了什么？－－MFC（用面向对象技术封装Windows　API，抽象出一个类体系）</p>
<pre><code>class B                    //基类, 定义了虚函数打印类型信息
{
    public:
        virtual void Print()
        {
            cout &lt;&lt; &quot;The type is B&quot; &lt;&lt; endl;
        }
};

class D1 : public B        //派生类1, 重载了打印函数
{
    public:
        void Print()
        {
            cout &lt;&lt; &quot;The type is D1&quot; &lt;&lt; endl;
        }
};

class D2 : public B        //派生类2, 重载了打印函数
{
    public:
        void Print()
        {
            cout &lt;&lt; &quot;The type is D2&quot; &lt;&lt; endl;
        }
};

int main()
{
    B *pB;
    B b;
    D1 d1;
    D2 d2;

    //根据pB指向的类型, 自动调用相应的函数, 是为多态
    pB = &amp;b;
    pB -&gt;Print();        //输出: The type is B;

    pB = &amp;d1;
    pB -&gt;Print();        //输出: The type is D1;

    pB = &amp;d2;
    pB -&gt;Print();        //输出: The type is D2;
}
</code></pre></li>
</ul>
<p>泛型（Generic）的概念</p>
<ul>
<li><p>Generic是一种抽象 就如 OO是一种抽象。</p>
</li>
<li><p>还没有语法与之相对应－－正在开发中。　（Function、Class、D : public B）</p>
</li>
<li><p>它为我们带来了什么？－－STL。</p>
</li>
</ul>
<h2 id="STL_u7684_u6982_u5FF5"><a href="#STL_u7684_u6982_u5FF5" class="headerlink" title="STL的概念"></a>STL的概念</h2><h3 id="u4F55_u4E3ASTL_uFF1F"><a href="#u4F55_u4E3ASTL_uFF1F" class="headerlink" title="何为STL？"></a>何为STL？</h3><ul>
<li><p>STL(Standard Template Library)是C＋＋标准庫的一部分（80%），是用C＋＋ Template机制来表达泛型的庫。</p>
</li>
<li><p>STL(Standard Template Library)是用泛型技术来设计完成的实例 就如 MFC(Microsoft Foundational Classes)是用面向对象技术来设计完成的实例</p>
</li>
</ul>
<h3 id="STL_u62BD_u8C61_u7684_u662F_u4EC0_u4E48_uFF1F"><a href="#STL_u62BD_u8C61_u7684_u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="STL抽象的是什么？"></a>STL抽象的是什么？</h3><ul>
<li><p>有些算法并不依赖于数据结构的特定实现，而只是依赖于该结构的几个基本的语义属性.</p>
</li>
<li><p>STL抽象出这些基本属性（Concept），成功的将算法与数据结构分离，在没有效率损失的前提下，得到了及大的弹性。</p>
</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code>vector&lt;int&gt; ivec;        //定义一个动态数组
deque&lt;int&gt; ideque;        //定义一个两端开口的数组
.
.
.
//一个泛型算法: 排序
sort(ivec.begin(), ivec.end);
sort(ideque.begin(), ideque.end());
</code></pre><h2 id="STL_u7684_u7EC4_u6210"><a href="#STL_u7684_u7EC4_u6210" class="headerlink" title="STL的组成"></a>STL的组成</h2><p>###六大组件</p>
<ul>
<li>容器(Container)</li>
<li>算法(Algorithm)</li>
<li>迭代器(Iterator)</li>
<li>仿函数(Function object)</li>
<li>适配器(Adapter)</li>
<li>空间配制器(allocator)</li>
</ul>
<p>STL 是通用类模板和算法的集合，它提供给程序员一些标准的数据结构的实现如 queues(队列), lists(链表), 和stacks(栈)等.</p>
<p><strong>C++ STL 提供给程序员以下三类数据结构的实现：</strong></p>
<ul>
<li><p>标准容器类</p>
</li>
<li><p>顺序性容器</p>
<ul>
<li>vector 从后面快速的插入与删除，直接访问任何元素</li>
<li>deque 从前面或后面快速的插入与删除，直接访问任何元素</li>
<li>list 双链表，从任何地方快速插入与删除</li>
</ul>
</li>
<li><p>关联容器</p>
<ul>
<li>set 快速查找，不允许重复值</li>
<li>multiset 快速查找，允许重复值</li>
<li>map 一对多映射，基于关键字快速查找，不允许重复值</li>
<li>multimap 一对多映射，基于关键字快速查找，允许重复值</li>
</ul>
</li>
<li><p>容器适配器</p>
<ul>
<li>stack 后进先出</li>
<li>queue 先进先出</li>
<li>priority_queue 最高优先级元素总是第一个出列</li>
</ul>
</li>
</ul>
<p>程序员使用复杂数据结构的最困难的部分已经由STL完成. 如果程序员想使用包<br>含int数据的stack, 他只要写出如下的代码:</p>
<pre><code>stack&lt;int&gt; myStack;
</code></pre><p>接下来, 他只要简单的调用 <code>push()</code> 和 <code>pop()</code> 函数来操作栈. 借助 C++ 模板的威力, 他可以指定任何的数据类型，不仅仅是int类型. STL stack实现了栈的功能，而不管容纳的是什么数据类型.</p>
<h3 id="vector_u5165_u95E8"><a href="#vector_u5165_u95E8" class="headerlink" title="vector入门"></a>vector入门</h3><p>vector是一个线性顺序结构。相当于数组，但其大小可以不预先指定，并且自动扩展。它可以像数组一样被操作，由于它的特性我们完全可以将vector 看作动态数组。<br>在创建一个vector 后，它会自动在内存中分配一块连续的内存空间进行数据存储，初始的空间大小可以预先指定也可以由vector 默认指定，这个大小即capacity （）函数的返回值。当存储的数据超过分配的空间时vector 会重新分配一块内存块，但这样的分配是很耗时的，在重新分配空间时它会做这样的动作：</p>
<p>首先， vector 会申请一块更大的内存块；</p>
<p>然后，将原来的数据拷贝到新的内存块中；</p>
<p>其次，销毁掉原内存块中的对象（调用对象的析构函数）；</p>
<p>最后，将原来的内存空间释放掉。</p>
<p>如果vector 保存的数据量很大时，这样的操作一定会导致糟糕的性能（ 这也是vector 被设计成比较容易拷贝的值类型的原因）。所以说vector 不是在什么情况下性能都好，只有在预先知道它大小的情况下vector 的性能才是最优的。</p>
<p><strong>vector 的特点：</strong></p>
<p>(1) 指定一块如同数组一样的连续存储，但空间可以动态扩展。即它可以像数组一样操作，并且可以进行动态操作。通常体现在push_back() pop_back() 。</p>
<p>(2) 随机访问方便，它像数组一样被访问，即支持[ ] 操作符和vector.at()</p>
<p>(3) 节省空间，因为它是连续存储，在存储数据的区域都是没有被浪费的，但是要明确一点vector 大多情况下并不是满存的，在未存储的区域实际是浪费的。</p>
<p>(4) 在内部进行插入、删除操作效率非常低，这样的操作基本上是被禁止的。Vector 被设计成只能在后端进行追加和删除操作，其原因是vector 内部的实现是按照顺序表的原理。</p>
<p>(5) 只能在vector 的最后进行push 和pop ，不能在vector 的头进行push 和pop 。</p>
<p>(6) 当动态添加的数据超过vector 默认分配的大小时要进行内存的重新分配、拷贝与释放，这个操作非常消耗性能。 所以要vector 达到最优的性能，最好在创建vector 时就指定其空间大小。Vectors 包含着一系列连续存储的元素,其行为和数组类似。访问Vector中的任意元素或从末尾添加元素都可以在常量级时间复杂度内完成，而查找特定值的<br>元素所处的位置或是在Vector中插入元素则是线性时间复杂度。</p>
<ol>
<li><p>Constructors 构造函数</p>
<p> vector<int> v1; //构造一个空的vector<br> vector<int> v1( 5, 42 ); //构造了一个包含5个值为42的元素的Vector</int></int></p>
</li>
<li><p>Operators 对vector进行赋值或比较</p>
</li>
</ol>
<p>C++ Vectors能够使用标准运算符: ==, !=, &lt;=, &gt;=, &lt;, 和 &gt;.</p>
<p>要访问vector中的某特定位置的元素可以使用 [] 操作符.</p>
<p>两个vectors被认为是相等的,如果:</p>
<ul>
<li>它们具有相同的容量</li>
<li>所有相同位置的元素相等.</li>
</ul>
<p>vectors之间大小的比较是按照词典规则.</p>
<p>3.assign() 对Vector中的元素赋值<br><br><strong>语法:</strong></p>
<pre><code>void assign( input_iterator start, input_iterator end );
// 将区间[start, end)的元素赋到当前vector
void assign( size_type num, const TYPE &amp;val );
// 赋num个值为val的元素到vector中,这个函数将会清除掉为vector赋值以前的内容.
</code></pre><p>4.at() 返回指定位置的元素<br><br><strong>语法:</strong></p>
<pre><code>TYPE at( size_type loc );//差不多等同v[i];但比v[i]安全;
</code></pre><p>5.back() 返回最末一个元素</p>
<p>6.begin() 返回第一个元素的迭代器</p>
<p>7.capacity() 返回vector所能容纳的元素数量(在不重新分配内存的情况下）</p>
<p>8.clear() 清空所有元素</p>
<p>9.empty() 判断Vector是否为空（返回true时为空）</p>
<p>10.end() 返回最末元素的迭代器(译注:实指向最末元素的下一个位置)</p>
<p>11.erase() 删除指定元素<br><br><strong>语法:</strong></p>
<pre><code>iterator erase( iterator loc );//删除loc处的元素
iterator erase( iterator start, iterator end );//删除start和end之间的元素
</code></pre><p>12.front() 返回第一个元素的引用</p>
<p>13.get_allocator() 返回vector的内存分配器</p>
<p>14.insert() 插入元素到Vector中<br><br><strong>语法:</strong></p>
<pre><code>iterator insert( iterator loc, const TYPE &amp;val );
//在指定位置loc前插入值为val的元素,返回指向这个元素的迭代器,
void insert( iterator loc, size_type num, const TYPE &amp;val );
//在指定位置loc前插入num个值为val的元素
void insert( iterator loc, input_iterator start, input_iterator end );
//在指定位置loc前插入区间[start, end)的所有元素
</code></pre><p>15.max_size() 返回Vector所能容纳元素的最大数量（上限）</p>
<p>16.pop_back() 移除最后一个元素</p>
<p>17.push_back() 在Vector最后添加一个元素</p>
<p>18.rbegin() 返回Vector尾部的逆迭代器</p>
<p>19.rend() 返回Vector起始的逆迭代器</p>
<p>20.reserve() 设置Vector最小的元素容纳数量</p>
<pre><code>//为当前vector预留至少共容纳size个元素的空间
</code></pre><p>21.resize() 改变Vector元素数量的大小<br><br><strong>语法:</strong></p>
<pre><code>void resize( size_type size, TYPE val );
//改变当前vector的大小为size,且对新创建的元素赋值val
</code></pre><p>22.size() 返回Vector元素数量的大小</p>
<p>23.swap() 交换两个Vector<br><br><strong>语法:</strong></p>
<pre><code>void swap( vector &amp;from );
</code></pre><h3 id="C++_List_28_u53CC_u5411_u94FE_u8868_29"><a href="#C++_List_28_u53CC_u5411_u94FE_u8868_29" class="headerlink" title="C++ List(双向链表)"></a>C++ List(双向链表)</h3><p>是一个线性链表结构，它的数据由若干个节点构成，每一个节点都包括一个信息块（即实际存储的数据）、一个前驱指针和一个后驱指针。它无需分配指定的内存大小且可以任意伸缩，这是因为它存储在非连续的内存空间中，并且由指针将有序的元素链接起来。</p>
<p>由于其结构的原因， list 随机检索的性能非常的不好，因为它不像vector 那样直接找到元素的地址，而是要从头一个一个的顺序查找，这样目标元素越靠后，它的检索时间就越长。检索时间与目标元素的位置成正比。</p>
<p>虽然随机检索的速度不够快，但是它可以迅速地在任何节点进行插入和删除操作。因为list 的每个节点保存着它在链表中的位置，插入或删除一个元素仅对最多三个元素有所影响，不像vector 会对操作点之后的所有元素的存储地址都有所影响，这一点是vector 不可比拟的。<br>list 的特点：</p>
<p>(1) 不使用连续的内存空间这样可以随意地进行动态操作；</p>
<p>(2) 可以在内部任何位置快速地插入或删除，当然也可以在两端进行push和pop 。</p>
<p>(3) 不能进行内部的随机访问，即不支持[ ] 操作符和vector.at() ；</p>
<p>Lists将元素按顺序储存在链表中， 与向量(vectors)相比， 它允许快速的插入和删除，但是随机访问却比较慢.</p>
<p>1.assign() 给list赋值<br><br><strong>语法:</strong></p>
<pre><code>void assign( input_iterator start, input_iterator end );
//以迭代器start和end指示的范围为list赋值
void assign( size_type num, const TYPE &amp;val );
//赋值num个以val为值的元素。
</code></pre><p>2.back() 返回最后一个元素的引用</p>
<p>3.begin() 返回指向第一个元素的迭代器</p>
<p>4.clear() 删除所有元素</p>
<p>5.empty() 如果list是空的则返回true</p>
<p>6.end() 返回末尾的迭代器</p>
<p>7.erase() 删除一个元素<br><br><strong>语法:</strong></p>
<pre><code>iterator erase( iterator loc );//删除loc处的元素
iterator erase( iterator start, iterator end ); //删除start和end之间的元素
</code></pre><p>8.front() 返回第一个元素的引用</p>
<p>9.get_allocator() 返回list的配置器</p>
<p>10.insert() 插入一个元素到list中<br><br><strong>语法:</strong></p>
<pre><code>iterator insert( iterator loc, const TYPE &amp;val );
//在指定位置loc前插入值为val的元素,返回指向这个元素的迭代器,
void insert( iterator loc, size_type num, const TYPE &amp;val );
//定位置loc前插入num个值为val的元素
void insert( iterator loc, input_iterator start, input_iterator end );
//在指定位置loc前插入区间[start, end)的所有元素
</code></pre><p>11.max_size() 返回list能容纳的最大元素数量</p>
<p>12.merge() 合并两个list<br><br><strong>语法:</strong></p>
<pre><code>void merge( list &amp;lst );//把自己和lst链表连接在一起
void merge( list &amp;lst, Comp compfunction );
//指定compfunction，则将指定函数作为比较的依据。
</code></pre><p>13.pop_back() 删除最后一个元素</p>
<p>14.pop_front() 删除第一个元素</p>
<p>15.push_back() 在list的末尾添加一个元素</p>
<p>16.push_front() 在list的头部添加一个元素</p>
<p>17.rbegin() 返回指向第一个元素的逆向迭代器</p>
<p>18.remove() 从list删除元素<br><br><strong>语法:</strong></p>
<pre><code>void remove( const TYPE &amp;val );
//删除链表中所有值为val的元素
</code></pre><p>19.remove_if() 按指定条件删除元素</p>
<p>20.rend() 指向list末尾的逆向迭代器</p>
<p>21.resize() 改变list的大小<br><br><strong>语法:</strong></p>
<pre><code>void resize( size_type num, TYPE val );
//把list的大小改变到num。被加入的多余的元素都被赋值为val22.
</code></pre><p>22.reverse() 把list的元素倒转</p>
<p>23.size() 返回list中的元素个数</p>
<p>24.sort() 给list排序<br><br><strong>语法:</strong></p>
<pre><code>void sort();//为链表排序，默认是升序
void sort( Comp compfunction );//采用指定函数compfunction来判定两个元素的大小。
</code></pre><p>25.splice() 合并两个list<br><br><strong>语法:</strong></p>
<pre><code>void splice( iterator pos, list &amp;lst );//把lst连接到pos的位置
void splice( iterator pos, list &amp;lst, iterator del );//插入lst中del所指元素到现链表的pos上
void splice( iterator pos, list &amp;lst, iterator start, iterator end );//用start和end指定范围。
</code></pre><p>26.swap() 交换两个list<br><br><strong>语法:</strong></p>
<pre><code>void swap( list &amp;lst );// 交换lst和现链表中的元素
</code></pre><p>27.unique() 删除list中重复的元素<br><br><strong>语法:</strong></p>
<pre><code>void unique();//删除链表中所有重复的元素
void unique( BinPred pr );// 指定pr，则使用pr来判定是否删除。
</code></pre><h3 id="C++_Deque_28_u53CC_u5411_u961F_u5217_29"><a href="#C++_Deque_28_u53CC_u5411_u961F_u5217_29" class="headerlink" title="C++ Deque(双向队列)"></a>C++ Deque(双向队列)</h3><p>是一种优化了的、对序列两端元素进行添加和删除操作的基本序列容器。它允许较为快速地随机访问，但它不像vector 把所有的对象保存在一块连续的内存块，而是采用多个连续的存储块，并且在一个映射结构中保存对这些块及其顺序的跟踪。向deque 两端添加或删除元素的开销很小。它不需要重新分配空间，所以向末端增加元素比vector 更有效。</p>
<p>实际上， deque 是对vector 和list 优缺点的结合，它是处于两者之间的一种容器。</p>
<p>deque 的特点：</p>
<p>(1) 随机访问方便，即支持[ ] 操作符和vector.at() ，但性能没有vector 好；</p>
<p>(2) 可以在内部进行插入和删除操作，但性能不及list ；</p>
<p>(3) 可以在两端进行push 、 pop ；</p>
<p>(4) 相对于verctor 占用更多的内存。</p>
<p>双向队列和向量很相似，但是它允许在容器头部快速插入和删除（就像在尾部一样）。</p>
<p>1.Constructors 创建一个新双向队列<br><br><strong>语法:</strong></p>
<pre><code>deque();//创建一个空双向队列
deque( size_type size );// 创建一个大小为size的双向队列
deque( size_type num, const TYPE &amp;val ); //放置num个val的拷贝到队列中
deque( const deque &amp;from );// 从from创建一个内容一样的双向队列
deque( input_iterator start, input_iterator end );
// start 和 end - 创建一个队列， 保存从start到end的元素。
</code></pre><p>2.Operators 比较和赋值双向队列</p>
<p>//可以使用[]操作符访问双向队列中单个的元素</p>
<p>3.assign() 设置双向队列的值<br><br><strong>语法:</strong></p>
<pre><code>void assign( input_iterator start, input_iterator end);
//start和end指示的范围为双向队列赋值
void assign( Size num, const TYPE &amp;val );//设置成num个val。
</code></pre><p>4.at() 返回指定的元素<br><br><strong>语法:</strong></p>
<pre><code>reference at( size_type pos ); 返回一个引用，指向双向队列中位置pos上的元素
</code></pre><p>5.back() 返回最后一个元素<br><br><strong>语法:</strong></p>
<pre><code>reference back();//返回一个引用，指向双向队列中最后一个元素
</code></pre><p>6.begin() 返回指向第一个元素的迭代器<br><br><strong>语法:</strong></p>
<pre><code>iterator begin();//返回一个迭代器，指向双向队列的第一个元素
</code></pre><p>7.clear() 删除所有元素</p>
<p>8.empty() 返回真如果双向队列为空</p>
<p>9.end() 返回指向尾部的迭代器</p>
<p>10.erase() 删除一个元素<br><br><strong>语法:</strong></p>
<pre><code>iterator erase( iterator pos ); //删除pos位置上的元素
iterator erase( iterator start, iterator end ); //删除start和end之间的所有元素
//返回指向被删除元素的后一个元素
</code></pre><p>11.front() 返回第一个元素的引用</p>
<p>12.get_allocator() 返回双向队列的配置器</p>
<p>13.insert() 插入一个元素到双向队列中<br><br><strong>语法:</strong></p>
<pre><code>iterator insert( iterator pos, size_type num, const TYPE &amp;val ); //pos前插入num个val值
void insert( iterator pos, input_iterator start, input_iterator end );
//插入从start到end范围内的元素到pos前面
</code></pre><p>14.max_size() 返回双向队列能容纳的最大元素个数</p>
<p>15.pop_back() 删除尾部的元素</p>
<p>16.pop_front() 删除头部的元素</p>
<p>17.push_back() 在尾部加入一个元素</p>
<p>18.push_front() 在头部加入一个元素</p>
<p>19.rbegin() 返回指向尾部的逆向迭代器</p>
<p>20.rend() 返回指向头部的逆向迭代器</p>
<p>21.resize() 改变双向队列的大小</p>
<p>22.size() 返回双向队列中元素的个数</p>
<p>23.swap() 和另一个双向队列交换元素<br><br><strong>语法:</strong></p>
<pre><code>void swap( deque &amp;target );// 交换target和现双向队列中元素
</code></pre><h3 id="u4E09_u8005_u6BD4_u8F83"><a href="#u4E09_u8005_u6BD4_u8F83" class="headerlink" title="三者比较"></a>三者比较</h3><p>vector 是一段连续的内存块，而deque 是多个连续的内存块， list 是所有数据元素分开保存，可以是任何两个元素没有连续。</p>
<p>vector 的查询性能最好，并且在末端增加数据也很好，除非它重新申请内存段；适合高效地随机存储。</p>
<p>list 是一个链表，任何一个元素都可以是不连续的，但它都有两个指向上一元素和下一元素的指针。所以它对插入、删除元素性能是最好的，而查询性能非常差；适合大量地插入和删除操作而不关心随机存取的需求。</p>
<p>deque 是介于两者之间，它兼顾了数组和链表的优点，它是分块的链表和多个数组的联合。所以它有被list好的查询性能，有被vector好的插入、删除性能。</p>
<p>如果你需要随即存取又关心两端数据的插入和删除，那么deque是最佳之选。</p>
<h2 id="u5173_u8054_u5BB9_u5668"><a href="#u5173_u8054_u5BB9_u5668" class="headerlink" title="关联容器"></a>关联容器</h2><p><strong>特点</strong></p>
<p>set, multiset, map, multimap 是一种非线性的树结构，具体的说采用的是一种比较高效的特殊的平衡检索二叉树—— 红黑树结构。（至于什么是红黑树，我也不太理解，只能理解到它是一种二叉树结构）因为关联容器的这四种容器类都使用同一原理，所以他们核心的算法是一致的，但是它们在应用上又有一些差别，先描述一下它们之间的差别。</p>
<p>set 又称集合，实际上就是一组元素的集合，但其中所包含的元素的值是唯一的，且是按一定顺序排列的，集合中的每个元素被称作集合中的实例。因为其内部是通过链表的方式来组织，所以在插入的时候比vector 快，但在查找和末尾<br>添加上比vector 慢。</p>
<p>multiset 是多重集合，其实现方式和set 是相似的，只是它不要求集合中的元素是唯一的，也就是说集合中的同一个元素可以出现多次。</p>
<p>map 提供一种“键- 值”关系的一对一的数据存储能力。其“键”在容器中不可重复，且按一定顺序排列（其实我们可以将set 也看成是一种键- 值关系的存储，只是它只有键没有值。它是map 的一种特殊形式）。由于其是按链表的方式存储，它也继承了链表的优缺点。</p>
<p>multimap 和map 的原理基本相似，它允许“键”在容器中可以不唯一。</p>
<p>关联容器的特点是明显的，相对于顺序容器，有以下几个主要特点：</p>
<ol>
<li>其内部实现是采用非线性的二叉树结构，具体的说是红黑树的结构原理实现的；</li>
<li>set 和map 保证了元素的唯一性， mulset 和mulmap 扩展了这一属性，可以允许元素不唯一；</li>
<li>元素是有序的集合，默认在插入的时候按升序排列。</li>
</ol>
<p>基于以上特点，</p>
<ol>
<li><p>关联容器对元素的插入和删除操作比vector 要快，因为vector 是顺序存储，而关联容器是链式存储；比list 要慢，是因为即使它们同是链式结构，但list是线性的，而关联容器是二叉树结构，其改变一个元素涉及到其它元素的变动比list 要多，并且它是排序的，每次插入和删除都需要对元素重新排序；</p>
</li>
<li><p>关联容器对元素的检索操作比vector 慢，但是比list 要快很多。 vector 是顺序的连续存储，当然是比不上的，但相对链式的list 要快很多是因为list 是逐个搜索，它搜索的时间是跟容器的大小成正比，而关联容器 查找的复杂度基本是Log(N) ，比如如果有1000 个记录，最多查找10 次， 1,000,000 个记录，最多查找20 次。容器越大，关联容器相对list 的优越性就越能体现；</p>
</li>
<li><p>在使用上set 区别于vector,deque,list 的最大特点就是set 是内部排序的，这在查询上虽然逊色于vector ，但是却大大的强于list 。</p>
</li>
<li><p>在使用上map 的功能是不可取代的，它保存了“键- 值”关系的数据，而这种键值关系采用了类数组的方式。数组是用数字类型的下标来索引元素的位置，而map 是用字符型关键字来索引元素的位置。在使用上map 也提供了一种类数组操作的方式，即它可以通过下标来检索数据，这是其他容器做不到的，当然也包括set 。（ STL 中只有vector 和map 可以通过类数组的方式操作元素，即如同ele[1] 方式）</p>
</li>
</ol>
<h3 id="C++_Sets__26amp_3B_MultiSets"><a href="#C++_Sets__26amp_3B_MultiSets" class="headerlink" title="C++ Sets &amp; MultiSets"></a>C++ Sets &amp; MultiSets</h3><p>集合(Set)是一种包含已排序对象的关联容器。 多元集合(MultiSets)和集合(Sets)相像，只不过支持重复对象,其用法与set基本相同。</p>
<p>1.begin() 返回指向第一个元素的迭代器</p>
<p>2.clear() 清除所有元素</p>
<p>3.count() 返回某个值元素的个数</p>
<p>4.empty() 如果集合为空，返回true</p>
<p>5.end() 返回指向最后一个元素的迭代器</p>
<p>6.equal_range() 返回第一个&gt;=关键字的迭代器和&gt;关键字的迭代器<br><br><strong>语法:</strong></p>
<pre><code>pair &lt;iterator,iterator&gt;equal_range( const key_type &amp;key );
//key是用于排序的关键字
Set&lt;int&gt; ctr;
</code></pre><p><strong>例如：</strong></p>
<pre><code>Pair&lt;set&lt;int&gt;::iterator,set&lt;int&gt;::iterarot&gt;p;
For(i=0;i&lt;=5;i++) ctr.insert(i);
P=ctr.equal_range(2);
那么*p.first==2;*p.second==3;
</code></pre><p>7.erase() 删除集合中的元素<br><br><strong>语法:</strong></p>
<pre><code>iterator erase( iterator i ); //删除i位置元素
iterator erase( iterator start, iterator end );
//删除从start开始到end(end为第一个不被删除的值)结束的元素
size_type erase( const key_type &amp;key );
//删除等于key值的所有元素（返回被删除的元素的个数）
//前两个返回第一个不被删除的双向定位器,不存在返回末尾
//第三个返回删除个数
</code></pre><p>8.find() 返回一个指向被查找到元素的迭代器<br><br><strong>语法:</strong></p>
<pre><code>iterator find( const key_type &amp;key );
//查找等于key值的元素，并返回指向该元素的迭代器;
//如果没有找到,返回指向集合最后一个元素的迭代器
</code></pre><p>9.get_allocator() 返回集合的分配器</p>
<p>10.insert() 在集合中插入元素<br><br><strong>语法:</strong></p>
<pre><code>iterator insert( iterator i, const TYPE &amp;val ); //在迭代器i前插入val
void insert( input_iterator start, input_iterator end );
//将迭代器start开始到end（ end不被插入） 结束返回内的元素插入到集合中
pair insert( const TYPE &amp;val );
//插入val元素， 返回指向该元素的迭代器和一个布尔值来说明val是否成功被插入
//应该注意的是在集合(Sets中不能插入两个相同的元素)
</code></pre><p>11.lower_bound() 返回指向大于（或等于）某值的第一个元素的迭代器<br><br><strong>语法:</strong></p>
<pre><code>iterator lower_bound( const key_type &amp;key );
//返回一个指向大于或者等于key值的第一个元素的迭代器
</code></pre><p>12.key_comp() 返回一个用于元素间值比较的函数<br><br><strong>语法:</strong></p>
<pre><code>key_compare key_comp();
//返回一个用于元素间值比较的函数对象
</code></pre><p>13.max_size() 返回集合能容纳的元素的最大限值</p>
<p>14.rbegin() 返回指向集合中最后一个元素的反向迭代器</p>
<p><strong>示例：</strong></p>
<pre><code>Set&lt;int&gt; ctr;
Set&lt;int&gt;::reverse_iterator rcp;
For(rcp=ctr.rbegin();rcp!=ctr.rend();rcp++)
Cout&lt;&lt;*rcp&lt;&lt;” ”;
</code></pre><p>15.rend() 返回指向集合中第一个元素的反向迭代器</p>
<p>16.size() 集合中元素的数目</p>
<p>17.swap() 交换两个集合变量<br><br><strong>语法:</strong></p>
<pre><code>void swap( set &amp;object ); //交换当前集合和object集合中的元素
</code></pre><p>18.upper_bound() 返回大于某个值元素的迭代器<br><br><strong>语法:</strong></p>
<pre><code>iterator upwer_bound( const key_type &amp;key );
//返回一个指向大于key值的第一个元素的迭代器
</code></pre><p>19.value_comp() 返回一个用于比较元素间的值的函数<br><br><strong>语法:</strong></p>
<pre><code>iterator upper_bound( const key_type &amp;key );//返回一个用于比较元素间的值的函数对象
</code></pre><h3 id="C++_Maps__26amp_3B_MultiMaps"><a href="#C++_Maps__26amp_3B_MultiMaps" class="headerlink" title="C++ Maps &amp; MultiMaps"></a>C++ Maps &amp; MultiMaps</h3><p>C++ Maps是一种关联式容器，包含“关键字/值”对。</p>
<p>C++ Multimaps和maps很相似，但是MultiMaps允许重复的元素。</p>
<p>1.begin() 返回指向map头部的迭代器</p>
<p>2.clear() 删除所有元素</p>
<p>3.count() 返回指定元素出现的次数<br><br><strong>语法:</strong></p>
<pre><code>size_type count( const KEY_TYPE &amp;key );
//返回map中键值等于key的元素的个数
</code></pre><p>4.empty() 如果map为空则返回true</p>
<p>5.end() 返回指向map末尾的迭代器</p>
<p>6.equal_range() 返回特殊条目的迭代器对<br><br><strong>语法:</strong></p>
<pre><code>pair equal_range( const KEY_TYPE &amp;key );
返回两个迭代器,指向第一个键值为key的元素和指向最后一个键值为key的元素
</code></pre><p>7.erase() 删除一个元素<br><br><strong>语法:</strong></p>
<pre><code>void erase( iterator i ); //删除i元素
void erase( iterator start, iterator end ); //删除从start开始到end（不包括end） 结束的元素
size_type erase( const key_type &amp;key );
//删除等于key值的所有元素（返回被删除的元素的个数）
</code></pre><p>8.find() 查找一个元素<br><br><strong>语法:</strong></p>
<pre><code>iterator find( const key_type &amp;key );
//查找等于key值的元素，并返回指向该元素的迭代器;
//如果没有找到,返回指向集合最后一个元素的迭代器.
</code></pre><p>9.get_allocator() 返回map的配置器</p>
<p>10.insert() 插入元素<br><br><strong>语法:</strong></p>
<pre><code>iterator insert( iterator pos, const pair&lt;KEY_TYPE,VALUE_TYPE&gt; &amp;val );
//插入val到pos的后面，然后返回一个指向这个元素的迭代器
void insert( input_iterator start, input_iterator end );
//插入start到end的元素到map中
pair&lt;iterator, bool&gt; insert( const pair&lt;KEY_TYPE,VALUE_TYPE&gt; &amp;val );
//只有在val不存在时插入val。返回指向被插入元素的迭代器和描述是否插入的bool值
</code></pre><p>11.key_comp() 返回比较元素key的函数<br><br><strong>语法:</strong></p>
<pre><code>key_compare key_comp();
//返回一个用于元素间值比较的函数对象
</code></pre><p>12.lower_bound() 返回键值&gt;=给定元素的第一个位置<br><br><strong>语法:</strong></p>
<pre><code>iterator lower_bound( const key_type &amp;key );
//返回一个指向大于或者等于key值的第一个元素的迭代器
</code></pre><p>13.max_size() 返回可以容纳的最大元素个数</p>
<p>14.rbegin() 返回一个指向map尾部的逆向迭代器</p>
<p>15.rend() 返回一个指向map头部的逆向迭代器</p>
<p>16.size() 返回map中元素的个数</p>
<p>17.swap() 交换两个map<br><br><strong>语法:</strong></p>
<pre><code>void swap( map &amp;obj );
//swap()交换obj和现map中的元素
</code></pre><p>18.upper_bound() 返回键值&gt;给定元素的第一个位置<br><br><strong>语法:</strong></p>
<pre><code>iterator upwer_bound( const key_type &amp;key );
//返回一个指向大于key值的第一个元素的迭代器
</code></pre><p>19.value_comp() 返回比较元素value的函数<br><br><strong>语法:</strong></p>
<pre><code>value_compare value_comp();
//返回一个用于比较元素value的函数
</code></pre><h2 id="u5BB9_u5668_u9002_u914D_u5668"><a href="#u5BB9_u5668_u9002_u914D_u5668" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>特点</p>
<p>STL 中包含三种适配器：栈stack 、队列queue 和优先级priority_queue 。适配器是容器的接口，它本身不能直接保存元素，它保存元素的机制是调用另一种顺序容器去实现，即可以把适配器看作“它保存一个容器，这个容器再保<br>存所有元素”。</p>
<p>STL 中提供的三种适配器可以由某一种顺序容器去实现。默认下stack 和queue 基于deque 容器实现， priority_queue 则基于vector 容器实现。当然在创建一个适配器时也可以指定具体的实现容器，创建适配器时在第二个参数上指定具体的顺序容器可以覆盖适配器的默认实现。<br>由于适配器的特点，一个适配器不是可以由任一个顺序容器都可以实现的。</p>
<p>栈stack 的特点是后进先出，所以它关联的基本容器可以是任意一种顺序容器，因为这些容器类型结构都可以提供栈的操作有求，它们都提供了push_back 、pop_back 和back 操作。</p>
<p>队列queue 的特点是先进先出，适配器要求其关联的基础容器必须提供pop_front 操作，因此其不能建立在vector 容器上。</p>
<h3 id="C++_Stacks_uFF08_u5806_u6808_uFF09"><a href="#C++_Stacks_uFF08_u5806_u6808_uFF09" class="headerlink" title="C++ Stacks（堆栈）"></a>C++ Stacks（堆栈）</h3><p>C++ Stack（堆栈） 是一个容器类的改编，为程序员提供了堆栈的全部功能， ——也就是说实现了一个先进后出（ FILO）的数据结构。</p>
<p>1.empty() 堆栈为空则返回真</p>
<p>2.pop() 移除栈顶元素</p>
<p>3.push() 在栈顶增加元素</p>
<p>4.size() 返回栈中元素数目</p>
<p>5.top() 返回栈顶元素</p>
<h3 id="C++_Queues_28_u961F_u5217_29"><a href="#C++_Queues_28_u961F_u5217_29" class="headerlink" title="C++ Queues(队列)"></a>C++ Queues(队列)</h3><p>C++队列是一种容器适配器，它给予程序员一种先进先出(FIFO)的数据结构。</p>
<p>1.back() 返回一个引用，指向最后一个元素</p>
<p>2.empty() 如果队列空则返回真</p>
<p>3.front() 返回第一个元素</p>
<p>4.pop() 删除第一个元素</p>
<p>5.push() 在末尾加入一个元素</p>
<p>6.size() 返回队列中元素的个数</p>
<h3 id="C++_Priority_Queues_28_u4F18_u5148_u961F_u5217_29"><a href="#C++_Priority_Queues_28_u4F18_u5148_u961F_u5217_29" class="headerlink" title="C++ Priority Queues(优先队列)"></a>C++ Priority Queues(优先队列)</h3><p>C++优先队列类似队列，但是在这个数据结构中的元素按照一定的断言排列有序。</p>
<p>1.empty() 如果优先队列为空，则返回真</p>
<p>2.pop() 删除第一个元素</p>
<p>3.push() 加入一个元素</p>
<p>4.size() 返回优先队列中拥有的元素的个数</p>
<p>5.top() 返回优先队列中有最高优先级的元素</p>
<h2 id="u8FED_u4EE3_u5668"><a href="#u8FED_u4EE3_u5668" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>解释</strong></p>
<p>迭代器是一种对象，它能够用来遍历STL容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上象迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。</p>
<p>迭代器提供一些基本操作符： *、 ++、 ==、！ =、 =。这些操作和C/C++“操作array元素”时的指针接口一致。不同之处在于，迭代器是个所谓的smart pointers，具有遍历复杂数据结构的能力。其下层运行机制取决于其所遍历的数据结构。因此，每一种容器型别都必须提供自己的迭代器。</p>
<p>事实上每一种容器都将其迭代器以嵌套的方式定义于内部。因此各种迭代器的接口相同，型别却不同。这直接导出了泛型程序设计的概念：所有操作行为都使用相同接口，虽然它们的型别不同。</p>
<p><strong>功能特点</strong></p>
<p>迭代器使开发人员不必整个实现类接口。只需提供一个迭代器，即可遍历类中的数据结构， 可被用来访问一个容器类的所包函的全部元素，其行为像一个指针，但是只可被进行增加(++)或减少(–)操作。举一个例子，你可用一个迭代器来实现对vector容器中所含元素的遍历。</p>
<p>如下代码对vector容器对象生成和使用了迭代器：</p>
<pre><code>vector&lt;int&gt; the_vector;
vector&lt;int&gt;::iterator the_iterator;
for( int i=0; i &lt; 10; i++ )
the_vector.push_back(i);
int total = 0;
the_iterator = the_vector.begin();
while( the_iterator != the_vector.end() ) {
total += *the_iterator;
the_iterator++;
}cout &lt;&lt; &quot;Total=&quot; &lt;&lt; total &lt;&lt; endl;
提示：通过对一个迭代器的解引用操作（ *），可以访问到容器所包含的元素。
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C/">C++</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C-中的模板" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/22/C-中的模板/" class="article-date">
  	<time datetime="2015-09-22T03:52:00.000Z" itemprop="datePublished">2015-09-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/22/C-中的模板/">C++中的模板</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u6A21_u677F"><a href="#u6A21_u677F" class="headerlink" title="模板"></a>模板</h2><blockquote>
<p>模板把函数或类要处理的数据类型参数化, 表现为参数的多态性, 称为类属.</p>
<p>模板用于表达逻辑结构相同, 但具体数据类型不同的数据对象的通用行为.</p>
</blockquote>
<h3 id="u4EC0_u4E48_u662F_u6A21_u677F"><a href="#u4EC0_u4E48_u662F_u6A21_u677F" class="headerlink" title="什么是模板"></a>什么是模板</h3><p>类属– 类型参数化, 又称参数模板</p>
<p>使得程序(算法)可以从逻辑功能上抽象, 把被处理的对象(数据)类型作为参数传递</p>
<p>C++ 提供两种模板机制: 函数模板    、类模板</p>
<h3 id="u51FD_u6570_u6A21_u677F"><a href="#u51FD_u6570_u6A21_u677F" class="headerlink" title="函数模板"></a>函数模板</h3><p>考虑求两参数之中大值函数：max(a,b), 对a,b的不同类型都有相同的处理形式:<br></p>
<pre><code>return (a&gt;b)? a:b;
</code></pre><p>用已有方法解决对不同数据类型处理:<br><br>(1)宏替换 </p>
<pre><code>#define max(a,b)(a&gt;b? a:b)
</code></pre><blockquote>
<p>问题  避开类型检查 </p>
</blockquote>
<p>(2)重载</p>
<blockquote>
<p>问题  需要许多重载版本</p>
</blockquote>
<p>(3)使用模板函数</p>
<h4 id="u6A21_u677F_u8BF4_u660E"><a href="#u6A21_u677F_u8BF4_u660E" class="headerlink" title="模板说明"></a>模板说明</h4><p>声明模板中使用的类属参数.形式为:</p>
<pre><code>template&lt;类型形式参数表&gt;
</code></pre><p>类型形式参数的形式为:</p>
<pre><code>typename T1, typename T2, ....., typename Tn
或:    
class T1, class T2, ....., class Tn
</code></pre><p>例如:</p>
<pre><code>template&lt;typename T&gt;
template&lt;typename ElementType&gt;
template&lt;typename NameType, typename DataType&gt;
</code></pre><h4 id="u51FD_u6570_u6A21_u677F_u4E0E_u6A21_u677F_u51FD_u6570"><a href="#u51FD_u6570_u6A21_u677F_u4E0E_u6A21_u677F_u51FD_u6570" class="headerlink" title="函数模板与模板函数"></a>函数模板与模板函数</h4><p>函数模板声明:</p>
<pre><code>template &lt;类型形式参数&gt;
类型  函数名(形式参数表)
{
    语句序列
}
</code></pre><blockquote>
<p>函数模板定义由模板说明核函数定义组成</p>
<p>模板书名的类属参数必须在函数定义中至少出现一次</p>
<p>函数参数表中可以使用类属类型参数, 也可以使用一般类型参数</p>
</blockquote>
<h3 id="u91CD_u8F7D_u51FD_u6570_u6A21_u677F"><a href="#u91CD_u8F7D_u51FD_u6570_u6A21_u677F" class="headerlink" title="重载函数模板"></a>重载函数模板</h3><p>有些特殊情况需要函数模板参与重载</p>
<p>例如:</p>
<pre><code>template &lt;typename T&gt;
T max(T a, T b)
{
    return a&gt;b? a:b;
}

void f(int i, cahr c)
{
    max(i, i);    //OK
    max(c, c);    //OK
    max(i, c);    //error, 无法匹配
    max(c, i);    //error
}
</code></pre><p>重载:</p>
<pre><code>template &lt;typename T&gt;
T max(T a, T b)
{
    return a&gt;b? a:b;
}

int max(int a, int b)    //模板函数重载版本
{
    return a&gt;b? a:b
}

void f(int i, cahr c)
{ 
    max(i, i);    //OK
    max(c, c);    //OK
    max(i, c);    //ok, 由系统提供隐式转换
    max(c, i);    //ok
}
</code></pre><p>匹配约定</p>
<blockquote>
<p>寻找和使用最符合函数名和函数参数类型的函数, 若找到则调用它;</p>
<p>否则,寻找一盒函数模板, 梨花产生一个匹配的模板函数, 若找到则调用它;</p>
<p>否则, 寻找可以通过类型转换进行参数匹配的重载函数, 若找到则调用它</p>
<p>如果按以上步骤均未能找到匹配函数, 则调用错误.</p>
<p>如果调用有多余一个的匹配选择, 则调用匹配出现二义性.</p>
</blockquote>
<ul>
<li>函数模板可以向普通函数一样被重载</li>
<li>C++编译器优先考虑普通函数</li>
<li>如果函数模板可以产生一个更好的匹配, 那么选择模板</li>
<li>可以通过空模板参数列表的语法限定编译器只有通过模板匹配  </li>
</ul>
<p>函数模板的深入理解</p>
<blockquote>
<p>编译器并不是把函数模板处理成能够处理任意类型的函数</p>
<p>编译器从函数模板通过具体类型产生不同的函数</p>
<p>编译器会对函数模板进行两次编译</p>
<p>在声明的地方对模板代码本身进行编译</p>
<p>在调用的地方对函数参数替换后的代码进行编译 </p>
</blockquote>
<h3 id="u7C7B_u6A21_u677F"><a href="#u7C7B_u6A21_u677F" class="headerlink" title="类模板"></a>类模板</h3><p>类模板用于实现类所需数据的类型参数化</p>
<p>类模板在表示如数组、表、图等数据结构咸的特别重要,这些数据结构的表示和算法不收所包含的元素类型影响</p>
<h4 id="u7C7B_u6A21_u677F_u4E0E_u6A21_u677F_u7C7B"><a href="#u7C7B_u6A21_u677F_u4E0E_u6A21_u677F_u7C7B" class="headerlink" title="类模板与模板类"></a>类模板与模板类</h4><p>类模板有模板书名和类说明构成</p>
<pre><code>template&lt;类型形式参数表&gt;
类声明
</code></pre><p>例如:</p>
<pre><code>template&lt;typename Type&gt;
class TClass
{
    //TClass的成员函数
    private:
        Type DateMember;    //类属参数必须至少在类说明中出现一次
    //...
};
</code></pre><p>一个数组类模板</p>
<pre><code>template&lt;typename T&gt;
class Array
{
    public:
        Array(int s);
        virtual ~array();
        virtual const T&amp; Entry(int index) const;
        virtual void Enter(int index, const T&amp; value);
    protected:
        int size;
        T* element;
}
template&lt;typename T&gt; Array&lt;T&gt;::Array(int s)
{
    if(s＞１)
    {
        ｓｉｚｅ　＝ｓ；
    } else
    {
        ｓｉｚｅ　＝１；
    }
    element = new T[size];
}
template&lt;typename T&gt; Array&lt;T&gt;:: ~Array()
{
    delete[] element;
}
template&lt;typename T&gt; const T&amp; Array&lt;T&gt;::Entry(int index)const
{
    return element[index]; 
}
template&lt;typename T&gt; void Array&lt;T&gt;::Enter(int index, const T&amp; value)
{
    element[index] = value;
}
</code></pre><h4 id="u5728_u7C7B_u5C42_u6B21_u4E2D_u7684_u7C7B_u6A21_u677F"><a href="#u5728_u7C7B_u5C42_u6B21_u4E2D_u7684_u7C7B_u6A21_u677F" class="headerlink" title="在类层次中的类模板"></a>在类层次中的类模板</h4><p>一个类模板在类层次结构中既可以是基类也可以是派生类:</p>
<blockquote>
<p>类模板可以从模板类派生</p>
<p>类模板可以从非模板类派生</p>
<p>模板类可以从类模板派生</p>
<p>非模板类可以从类模板派生    </p>
<p>类模板派生普通类, 在定义派生类是要对基类的抽象参数实例化</p>
<p>从普通类派生模板类, 意味着派生类添加了抽象类数据成员</p>
</blockquote>
<p>从类模板A派生普通类B</p>
<pre><code>#include&lt;iostream.h&gt;
template&lt;typename T&gt;        //定义类模板
class A
{
    public:
        A(T x)
        {
            t = x;
        }
        void out()
        {
            cout&lt;&lt; t &lt;&lt; endl;
        }
    protected:
        T t;
}
</code></pre><p>B:</p>
<pre><code>class B:public A&lt;int&gt;
{
    public:
        B(int a, double x):A&lt;int&gt;(a)        //子类调用父类的构造函数
        {
            y = x;
        }
        void out()
        {
            A&lt;int&gt;::out;
            cout&lt;&lt; y &lt;&lt; endl:
        }
    protected:
        double y;
}
</code></pre><h3 id="u7C7B_u6A21_u677F_u9047_u4E0A_u53CB_u5143_u51FD_u6570"><a href="#u7C7B_u6A21_u677F_u9047_u4E0A_u53CB_u5143_u51FD_u6570" class="headerlink" title="类模板遇上友元函数"></a>类模板遇上友元函数</h3><p>为复数类模板用定义重载运算符友元函数</p>
<pre><code>#inclde&lt;iostream.h&gt;
template&lt;typename T&gt;
class Complex
{
    public:
        Complex(T r = 0, T i = 0);
        Complex(T a)
        {
            Real = a;
            Image = 0;
        }
        void print() const;
        friend Complex operator+ (const Complex&lt;T&gt; &amp; c1, const Complex&lt;T&gt; &amp; c2)
        {
            T r = c1.Real +ｃ２．Ｒｅａｌ；
            T i = c1.Image + c2.Image;
            return Complex&lt;T&gt;(r, i); 
        }
        friend Complex operator- (const Complex&lt;T&gt; &amp; c1, const Complex&lt;T&gt; &amp; c2);
        {
            T r = c1.Real -ｃ２．Ｒｅａｌ；
            T i = c1.Image - c2.Image;
            return Complex&lt;T&gt;(r, i); 
        }
        friend Complex operator- (const Complex&lt;T&gt; &amp; c1)
        {
            return Complex&lt;T&gt;(-cReal, -c.Image); 
        }
    private:
        T Real, Image;
};


template&lt;typename T&gt; Complex&lt;T&gt;::Complex(T r, T i)
{
    Real = r;
    Image = i;
}

template&lt;typename T&gt; void Completx&lt;T&gt;::print()const
{
    cout &lt;&lt; &apos;(&apos;&lt;&lt; Real &lt;&lt; &quot;,&quot; &lt;&lt; Image &lt;&lt; &apos;)&apos; &lt;&lt;endl;
}

void main()
{
    Complex&lt;double&gt; c1(2.5, 3.7), c2(4.2, 6.5);
    Complex&lt;double&gt; c;
    c = c1 - c2;
    c.print();
    c = c1 + c2;
    c.print();
    c =- c1/;
    c.print();
}
</code></pre><h3 id="u7C7B_u6A21_u677F_u4E0Estatic_u6210_u5458"><a href="#u7C7B_u6A21_u677F_u4E0Estatic_u6210_u5458" class="headerlink" title="类模板与static成员"></a>类模板与static成员</h3><blockquote>
<p>从类模板实例化的每个模板类有自己的类模板数据成员, 该模板类的所有对象共享一个static数据成员</p>
<p>和非模板类的static数据成员一样, 模板类的static数据成员也应该在文件范围定义和初始化</p>
<p>每个模板类有自己的类模板的static数据成员副本</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp基础/">Cpp基础</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C/">C++</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android中使用软键盘" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/16/Android中使用软键盘/" class="article-date">
  	<time datetime="2015-09-16T02:59:08.000Z" itemprop="datePublished">2015-09-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/16/Android中使用软键盘/">Android中使用软键盘</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##Working with the Soft KeyboardEdit PagePage History</p>
<p>当一个文本文件在你的UI上获得焦点的时候,Android系统就会显示出一个屏幕上的键盘,就是软键盘. 为了提供更好的用户体验,你可以设定你所期望的键盘的风格特性(比如,它是否为一个电话号码或者emial地址) 以及软键盘的的一些行为 (比如 拼写纠错).</p>
<blockquote>
<p>注意: 默认情况下, 软键盘可能在模拟器中不显示. 但是如果你想测试软键盘的功能, 确保打开 AVD (Window =&gt; Android Virtual Device Manager) 并且将你的模拟器的”Hardware Keyboard Present” 设为 false.</p>
</blockquote>
<p><img src="http://7xlrdt.com1.z0.glb.clouddn.com/softKeyboard_1.png" alt=""><br><img src="http://7xlrdt.com1.z0.glb.clouddn.com/softKeyboard_2.png" alt=""><br><img src="http://7xlrdt.com1.z0.glb.clouddn.com/softKeyboard_3.png" alt=""></p>
<h2 id="Showing_Soft_Keyboard_Programmatically"><a href="#Showing_Soft_Keyboard_Programmatically" class="headerlink" title="Showing Soft Keyboard Programmatically"></a>Showing Soft Keyboard Programmatically</h2><p>下面的代码可以让一个指定的View来显示keyboard:</p>
<pre><code>public void showSoftKeyboard(View view){
    if(view.requestFocus()){
        InputMethodManager imm =(InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
        imm.showSoftInput(view,InputMethodManager.SHOW_IMPLICIT);
    }
}
</code></pre><h2 id="Hiding_the_Soft_Keyboard_Programmatically"><a href="#Hiding_the_Soft_Keyboard_Programmatically" class="headerlink" title="Hiding the Soft Keyboard Programmatically"></a>Hiding the Soft Keyboard Programmatically</h2><p>你可以通过 包含edit field的 window token来让InputMethodManager调用hideSoftInputFromWindow 方法来让Android系统强制隐藏软键盘.</p>
<pre><code>public void hideSoftKeyboard(View view){
  InputMethodManager imm =(InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);
  imm.hideSoftInputFromWindow(view.getWindowToken(), 0);
}
</code></pre><h2 id="Adding_a__u201CDone_u201D_Key"><a href="#Adding_a__u201CDone_u201D_Key" class="headerlink" title="Adding a “Done” Key"></a>Adding a “Done” Key</h2><p>在键盘中, 你可以通过下面的<code>imeOptions</code>属性来让你的EditView来隐藏 “Next” 键并且 “Done”键 :</p>
<pre><code>&lt;EditText
  android:imeOptions=&quot;actionDone&quot;&gt;
&lt;/EditText&gt;
</code></pre><p>或者通过java代码:</p>
<pre><code>myEditText.setImeOptions(EditorInfo.IME_ACTION_DONE);
</code></pre><p>更多的<code>imeOptions</code>信息见<a href="http://developer.android.com/reference/android/widget/TextView.html#attr_android%3aimeActionLabel" target="_blank" rel="external">EditText documentation</a>.</p>
<h2 id="Showing_the_Keyboard_when_Activity_Starts"><a href="#Showing_the_Keyboard_when_Activity_Starts" class="headerlink" title="Showing the Keyboard when Activity Starts"></a>Showing the Keyboard when Activity Starts</h2><p>尽管Activity启动的时候Android系统会自定让你的layout中的第一个text field获取焦点, 但它并不会让软键盘显示出来. 为了让keyboard在activity启动的时候显示出来, 你需要在manifest文件中<code>&lt;activity&gt;</code>元素节点中添加 <code>android:windowSoftInputMode</code> 属性 并设置值 “stateVisible” . Check out <a href="http://developer.android.com/training/keyboard-input/visibility.html#ShowOnStart" target="_blank" rel="external">this guide</a> for more details.</p>
<pre><code>&lt;activity
    android:name=&quot;com.example.myactivity&quot;
    android:windowSoftInputMode=&quot;stateVisible&quot; /&gt;
</code></pre><p>我们同样可以通过下面的方式来让软键盘在屏幕中有更好的显示出来:</p>
<pre><code>&lt;activity
    android:name=&quot;com.example.myactivity&quot;
    android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot; /&gt;
</code></pre><p>See the guide on <a href="http://developer.android.com/training/keyboard-input/visibility.html" target="_blank" rel="external">keyboard visibility</a> for more details.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-RecyclerView-创建LayoutManager-Redux" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/14/RecyclerView-创建LayoutManager-Redux/" class="article-date">
  	<time datetime="2015-09-14T13:48:47.000Z" itemprop="datePublished">2015-09-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/14/RecyclerView-创建LayoutManager-Redux/">RecyclerView 创建LayoutManager-Redux</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇文章是RecyclerView系列文章的结尾篇。前三部分的链接在这里 :</p>
<ul>
<li><a href="http://www.bigtiger079.com/2015/09/14/RecyclerView-%E5%88%9B%E5%BB%BALayoutManager-1">第一部分</a></li>
<li><a href="http://www.bigtiger079.com/2015/09/14/RecyclerView-%E5%88%9B%E5%BB%BALayoutManager-2">第二部分</a> </li>
<li><a href="http://www.bigtiger079.com/2015/09/14/RecyclerView-%E5%88%9B%E5%BB%BALayoutManager-3">第三部分</a></li>
</ul>
<p>当我在写这个系列的最后一篇文章，也就是关于predictIve animation的讨论时，我突然想到几个很有意思的点，并且很有讨论价值。这个系列文章以调查RecyclerView是否能够以简单的方式满足竖向、横向滚动的布局需求以及开发者要定制一个LayoutManager的难度有多大开始。这篇文章中我选择了一个基本的网格布局作为自定义layoutManager的示例。</p>
<p>下面这幅图展示了运用这个自定义LayoutManager到RecyclerView的滚动效果。</p>
<p><img src="http://7xlrpi.com1.z0.glb.clouddn.com/recycler_layoutmanager_redux_1.gif" alt=""></p>
<h2 id="u6253_u7834_u5E38_u89C4_u8BBE_u8BA1"><a href="#u6253_u7834_u5E38_u89C4_u8BBE_u8BA1" class="headerlink" title="打破常规设计"></a>打破常规设计</h2><p>无论你打算如何组织Adapter的位置（从左到右，上到下等等）,内容视图的视角都是显示部分不连贯数据集的区域。更确切地说，在第一个和最后一个可视位置之间的Adapter区域的数据项也会在可视区域view的外面。</p>
<p>这是一个很重要的点，因为它与在单轴上滚动的布局大相径庭（从而导致与当前框架下提供的默认布局背道而驰）。这些标准小工具显示，数据集是在一个连接块范围内–从第一个到最后一个可视位置之间不间断。</p>
<p>RecyclerView LayoutManager API会假定有一个可见的数据集合，RecyclerView LayoutManager只会显示数据集合中某个范围内可见的数据项，然后产生一个像上述所展示的网格布局一样的布局效果，这稍微有那么点挑战。在predictive animation里没有什么比这部分更加明显了。为了便于扩展，我感觉在这里指出这些毛病是非常必要的。</p>
<h2 id="u5047_u8BBE1__uFF1A__u4ECE_u4E0D_u53EF_u89C1_u533A_u57DF_u79FB_u9664_u4E00_u4E2A_u6570_u636E_u9879_u4E0D_u4F1A_u5F71_u54CD_u5F53_u524D_u53EF_u89C1_u7684View"><a href="#u5047_u8BBE1__uFF1A__u4ECE_u4E0D_u53EF_u89C1_u533A_u57DF_u79FB_u9664_u4E00_u4E2A_u6570_u636E_u9879_u4E0D_u4F1A_u5F71_u54CD_u5F53_u524D_u53EF_u89C1_u7684View" class="headerlink" title="假设1 ： 从不可见区域移除一个数据项不会影响当前可见的View"></a>假设1 ： 从不可见区域移除一个数据项不会影响当前可见的View</h2><p>当你考虑到一个Adapter移除一个数据项时LinearLayoutManager或者GridLayoutManager会做何反应时，这两个LayoutManager实际上都处理得非常好。如果被移除的数据项是可见的，一个可用的区域将会空置出来，此时就需要一个周边的View进行填充。这意味着周边显示的View必须被布局到这个位置以填补缺口。然而，并没有一个示例表明当一个移除操作执行时会发送一个隐藏视图的操作，唯一被隐藏的视图是那些被显式移除的。如果被移除的View在可见区域之外，那么对于可见区域的布局不会产生影响。在这个情况之下，你不会看到任何动画，它可能做出的修改是数据项被移到其他位置。</p>
<p>从上述的情况看，这与文章开头我们提到的一样，LayoutManager显示的是一个不连续的数据项。然而，这一可视区域的不连续本质使得数据项在屏幕外从可视区域内移除！换种说法，它们的位置处于第一个和最后一个位置之间，但是目前数据项view并不在布局中。这导致的结果就是，屏幕外发生的数据项移除可以并且会影响我们在布局动画处理时view的生成和消失。</p>
<p>在有机会对view的生成进行布局时，预布局是RecyclerView动画的关键阶段。RecyclerView通过其初始位置值将view返回，据此我们可以将内容布局在其初始状态。但是，当view移除与可视区域不相交时。RecyclerView就会通过其最终位置值将view返回。这样一来，在没有附加记账的情况下处理view的生成就变得困难得多。不过话说回来，难是难，也还是可以做到。</p>
<p>在上一篇文章中我们看到的FixedGridLayoutManager，我们不仅要解析可视view，还要听从onItemsRemoved()的回调来找到移除点，并妥当处理所有生成的view案例。RecyclerView确保我们在需要时，该回调会在预布局之前出现（屏幕外案例），但相反情况下会在预布局之后出现。RecyclerView这么做是为了避免这些事件与你的布局产生冲突–其时间点对我们来说只是一个美丽的意外。</p>
<p>我们还需要追踪的一个事实就是，可视移除会以一种我们意料之中的方式偏移view的位置，而屏幕外移除则不会。这也是为什么移除会被冠以不同类型的原因。上一篇文章忽略的一点表明，在屏幕外进行移除时，我们会对view生成逻辑提供一个手动偏移。。。所以当移除可视时，位置之间会相互匹配。</p>
<pre><code>private void fillGrid(int direction, int emptyLeft, int emptyTop, RecyclerView.Recycler recycler,
        boolean preLayout, SparseIntArray removedPositions) {
    …

    for (int i = 0; i &lt; getVisibleChildCount(); i++) {
        int nextPosition = positionOfIndex(i);

        /*
         * When a removal happens out of bounds, the pre-layout positions of items
         * after the removal are shifted to their final positions ahead of schedule.
         * We have to track off-screen removals and shift those positions back
         * so we can properly lay out all current (and appearing) views in their
         * initial locations.
         */
        int offsetPositionDelta = 0;
        if (preLayout) {
            int offsetPosition = nextPosition;

            for (int offset = 0; offset &lt; removedPositions.size(); offset++) {
                //Look for off-screen removals that are less-than this
                if (removedPositions.valueAt(offset) == REMOVE_INVISIBLE
                        &amp;&amp; removedPositions.keyAt(offset) &lt; nextPosition) {
                    //Offset position to match
                    offsetPosition--;
                }
            }
            offsetPositionDelta = nextPosition - offsetPosition;
            nextPosition = offsetPosition;
        }

        if (nextPosition &lt; 0 || nextPosition &gt;= getItemCount()) {
            //Item space beyond the data set, don&apos;t attempt to add a view
            continue;
        }

        …

        if (i % mVisibleColumnCount == (mVisibleColumnCount - 1)) {
            leftOffset = startLeftOffset;
            topOffset += mDecoratedChildHeight;

            //During pre-layout, on each column end, apply any additional appearing views
            if (preLayout) {
                layoutAppearingViews(recycler, view, nextPosition, removedPositions.size(), offsetPositionDelta);
            }
        } else {
            leftOffset += mDecoratedChildWidth;
        }
    }

    …
}
</code></pre><p>之后offsetPositionDelta值会作为我们在预布局中使用到的行/列位置的全局偏移被传递到layoutAppearingViews()。如果不是出于附加记账要求，这一偏移完全可以不必存在。</p>
<h2 id="u5047_u8BBE_232_uFF1A_u6DFB_u52A0_u65B0_u7684_u6570_u636E_u9879_u53EA_u4F1A_u5BFC_u81F4_u540C_u7EA7view_u7684_u6D88_u5931_uFF0C_u800C_u4E0D_u662F_u751F_u6210_u3002"><a href="#u5047_u8BBE_232_uFF1A_u6DFB_u52A0_u65B0_u7684_u6570_u636E_u9879_u53EA_u4F1A_u5BFC_u81F4_u540C_u7EA7view_u7684_u6D88_u5931_uFF0C_u800C_u4E0D_u662F_u751F_u6210_u3002" class="headerlink" title="假设#2：添加新的数据项只会导致同级view的消失，而不是生成。"></a>假设#2：添加新的数据项只会导致同级view的消失，而不是生成。</h2><p>添加了新的数据项之后，反面为真。如果在添加时数据项为可视，那么标准布局管理器会在屏幕外推开不可视的view以便腾出空间。之前没有出现过关于这种行为会同时触发一个或多个同级view滑向可视子类位置的案例。移除也是同样的道理，在可视区域外添加数据项并不会影响可视view，所以通常来说动画也不会起作用。</p>
<p>对于FixedGridLayoutManager或其他任何非连贯区域的布局，在可视区域内还是可视区域外进行添加并没有多大差别。两种情况中我们都需要管理可能出现的view生成和消失。而我们在移除中使用的方案在这里则不可行，因为onItemsAdded()总是在预布局之后被调用。。。这一次我们就没那么幸运地再一次能够碰到美丽的意外了。</p>
<p>缺少了那次回调，关于添加数据项，我们实际上在预布局时就没有多少可做的了。这样一来就变成了布局额外的view以备不时之需，而不布局一定量的额外view就会损害性能这两种情况之间的妥协。FixedGridLayoutManager在添加数据项时不支持预测view生成。</p>
<h2 id="u4E00_u5207_u624D_u521A_u521A_u5F00_u59CB"><a href="#u4E00_u5207_u624D_u521A_u521A_u5F00_u59CB" class="headerlink" title="一切才刚刚开始"></a>一切才刚刚开始</h2><p>RecyclerView APIs是一个新生事物，现有案例中还有非常多的地方需要改进的。同时，它也非常复杂，想要做对并不容易。表面上看起来RecyclerView要求大家付出的努力，背后可能大家要花10倍的精力才能实现。而且这些类型越到后面可能月蛋疼。希望正在尝试这种做法的各位同仁可以视本文为一个预警，不要盲目浪费时间，但同时我们也期待这这个框架的日渐成熟。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RecyclerView/">RecyclerView</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-RecyclerView-创建LayoutManager-3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/14/RecyclerView-创建LayoutManager-3/" class="article-date">
  	<time datetime="2015-09-14T08:43:33.000Z" itemprop="datePublished">2015-09-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/14/RecyclerView-创建LayoutManager-3/">RecyclerView 创建LayoutManager-3</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在之前的文章里，我们讨论了怎样对数据集改变和定量滚动 提供正确的支持。接下来我们会介绍怎样给 LayoutManager 添加 合适的动画效果。</p>
<h2 id="The_Problem_With_Free"><a href="#The_Problem_With_Free" class="headerlink" title="The Problem With Free"></a>The Problem With Free</h2><p>上次我们说到了 notifyDataSetChanged() ，但是使用这个方法 不会有数据改变的动画效果(1)。 RecyclerView 提供了新的 API 让我们可以通知 adapter 做出带有动画效果的改变。它们是：</p>
<ul>
<li>notifyItemInserted() 和 notifyItemRangeInserted()： 在给定位置/范围插入新item(s)。</li>
<li>notifyItemChanged() 和 notifyItemRangeChanged()： 使给定 位置/范围 的 item(s) 无效，数据集并没有结构上的改变。</li>
<li>notifyItemRemoved() 和 notifyItemRangeRemoved()： 移除给定 位置/范围 的 item(s)。</li>
<li>notifyItemMoved()： 将数据集中的一个 item 重定位到一个新的位置。</li>
</ul>
<p>使用这些方法你的 LayoutManager 会得到一个很简单的默认 item 动画。 这些动画是根据当前每一个 view 在改变后是否还存在于 layout 之中生成的。 新的 view 渐入，被移除的 view 淡出，其他 view 移动到新的位置。 下面是我们 grid layout 示例的动画效果：</p>
<p><img src="http://7xlrdt.com1.z0.glb.clouddn.com/layoutmanager_3_1.gif" alt="layoutmanager_1"></p>
<p>不过这里有个问题，一些没有被移除的 item 也淡出了。 这是因为它们在父控件 RecyclerView 的边界中不再可见。 我们想要这些 view 朝着用户期望的方向滑去，但是框架只知道 我们的代码在数据改变后没有显示出这些 item。此外， 新加入的 view 是淡入进来的，让他们从预定位置滑入界面会更好。</p>
<p>我们要给 LayoutManager 加点东西才能实现这些。</p>
<h2 id="Predictive_Item_Animations"><a href="#Predictive_Item_Animations" class="headerlink" title="Predictive Item Animations"></a>Predictive Item Animations</h2><p>下面的图片展示了我们期望的移除 item 动画效果： img 左侧一列 items 滑到右侧填补空白部分的动画很引人注意。 和这个差不多，你可以脑补出在这个位置添加一个 item 时的动画效果。</p>
<p><img src="http://7xlrpi.com1.z0.glb.clouddn.com/recycler_layoutmanager_3_2.gif" alt="layoutmanager_2"></p>
<p>左侧一列 items 滑到右侧填补空白部分的动画很引人注意。 和这个差不多，你可以脑补出在这个位置添加一个 item 时的动画效果。</p>
<p>在第一篇文章里曾提到的，onLayoutChildren() 通常只会 在父控件 RecyclerView 初始化布局 或者 数据集的大小(比如 item 的数量)改变时调用一次。 Predictive Item Animations 这个特性允许我们给 view (基于数据改变产生)的过渡动画 提供更多有用的信息。想要使用这个特性，就要告诉 框架我们的 LayoutManager 提供了这个附加数据：</p>
<pre><code>@Override
public boolean supportsPredictiveItemAnimations() {
    return true;
}
</code></pre><p>有了这个改动，onLayoutChildren()会在每次数据集改变后被调用两次， 一次是”预布局”(pre-layout)阶段，一次是真实布局(real layout)。</p>
<h2 id="u5728_pre-layout__u9636_u6BB5_u8BE5_u505A_u4E9B_u4EC0_u4E48"><a href="#u5728_pre-layout__u9636_u6BB5_u8BE5_u505A_u4E9B_u4EC0_u4E48" class="headerlink" title="在 pre-layout 阶段该做些什么"></a>在 pre-layout 阶段该做些什么</h2><p>在onLayoutChildren()的 pre-layout 阶段， 你应该运行你的布局逻辑设置动画的初始状态。 这需要你在动画执行前布局所有 当前可见的 view 和 在动画后会可见的 view (被称为 APPEARING view)。Appearing views 应该被布局在 屏幕之外，用户期望它进入的位置。框架会捕获他们的位置， 籍此创建更合适的动画效果。</p>
<p>我们可以使用 RecyclerView.State.isPreLayout() 来检测当前处于哪一阶段<br>在 FixedGridLayoutManager 示例中，我们根据数据集的改变 使用 pre-layout 决定哪些 view 被移除。被移除的 view 在 pre-layout 的 Recycler 中仍然会被返回，所以你不用担心 会出现空白位置。如果你想要判断视图是否会被移除， 可以使用LayoutParams.isViewRemoved() 这个方法 。 我们的示例统计了被移除 view 的数量，让我们 对有多少空间会被 appearing views 填充有一个大概的印象。</p>
<pre><code>@Override
public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
    …

    SparseIntArray removedCache = null;
    /*
     * During pre-layout, we need to take note of any views that are
     * being removed in order to handle predictive animations
     */
    if (state.isPreLayout()) {
        removedCache = new SparseIntArray(getChildCount());
        for (int i=0; i &lt; getChildCount(); i++) {
            final View view = getChildAt(i);
            LayoutParams lp = (LayoutParams) view.getLayoutParams();

            if (lp.isItemRemoved()) {
                //Track these view removals as visible
                removedCache.put(lp.getViewPosition(), REMOVE_VISIBLE);
            }
        }
        …
    }

    …

    //Fill the grid for the initial layout of views
    fillGrid(DIRECTION_NONE, childLeft, childTop, recycler, state.isPreLayout(), removedCache);

    …
}
</code></pre><blockquote>
<p>Tip：在 pre-layout 期间，RecyclerView 会尝试用 view 在 adapter 中的位置匹配它们的”原位置”(数据改变前的位置)。 如果你想通过 position 请求一个 view，并且希望这个位置 是这个视图初始化时的位置。就不要在 pre-layout 和 real-layout 期间改变它们。</p>
</blockquote>
<p>示例代码中最后的变动是对fillGrid()进行修改，在这里给 N 个 appearing views 布局，N 是被移除的可见视图个数。 这些 view 永远是从右侧进入的，所以他们被安排在最后一列 可见 view 的后面。</p>
<pre><code>private void fillGrid(int direction, int emptyLeft, int emptyTop, RecyclerView.Recycler recycler,
        boolean preLayout, SparseIntArray removedPositions) {
    …

    for (int i = 0; i &lt; getVisibleChildCount(); i++) {
        int nextPosition = positionOfIndex(i);

        …

        if (i % mVisibleColumnCount == (mVisibleColumnCount - 1)) {
            leftOffset = startLeftOffset;
            topOffset += mDecoratedChildHeight;

            //During pre-layout, on each column end, apply any additional appearing views
            if (preLayout) {
                layoutAppearingViews(recycler, view, nextPosition, removedPositions.size(), …);
            }
        } else {
            leftOffset += mDecoratedChildWidth;
        }
    }

    …
}

private void layoutAppearingViews(RecyclerView.Recycler recycler, View referenceView,
        int referencePosition, int extraCount, int offset) {
    //Nothing to do...
    if (extraCount &lt; 1) return;

    for (int extra = 1; extra &lt;= extraCount; extra++) {
        //Grab the next position after the reference
        final int extraPosition = referencePosition + extra;
        if (extraPosition &lt; 0 || extraPosition &gt;= getItemCount()) {
            //Can&apos;t do anything with this
            continue;
        }

        /*
         * Obtain additional position views that we expect to appear
         * as part of the animation.
         */
        View appearing = recycler.getViewForPosition(extraPosition);
        addView(appearing);

        //Find layout delta from reference position
        final int newRow = getGlobalRowOfPosition(extraPosition + offset);
        final int rowDelta = newRow - getGlobalRowOfPosition(referencePosition + offset);
        final int newCol = getGlobalColumnOfPosition(extraPosition + offset);
        final int colDelta = newCol - getGlobalColumnOfPosition(referencePosition + offset);

        layoutTempChildView(appearing, rowDelta, colDelta, referenceView);
    }
}
</code></pre><p>在 layoutAppearingViews()这个方法里，每一个 appearing view 被布局到它的”全局”位置(就是它在这个网格中占据的行/列)。 虽然位置在屏幕之外，但是为框架创建滑入 view 动画的起始点提供了 必要的数据。</p>
<h2 id="Changes_for_the__u201CReal_u201D_Layout"><a href="#Changes_for_the__u201CReal_u201D_Layout" class="headerlink" title="Changes for the “Real” Layout"></a>Changes for the “Real” Layout</h2><p><a href="http://www.bigtiger079.com/2015/09/14/RecyclerView-%E5%88%9B%E5%BB%BALayoutManager-1">part1</a>中我们已经讨论过布局期间的基本工作， 然而要想为我们的动画提供支持还要做一些修改。 其中之一就是判断有没有 disappearing views。在我们的示例中 是通过运行一个普通的布局过程，然后检查 Recycler 的 scrap heap 之中有没有剩下的 view。</p>
<blockquote>
<p>注意：我们之所以能以这种方式使用 scrap heap 是因为 在每一次布局过程开始前，布局逻辑总是调用了 detachAndScrapAttachedViews()这个方法。 前面说过，这是布局中你需要遵循的最佳实践。</p>
</blockquote>
<p>Views still in scrap that aren’t considered removed are disappearing views. We need to lay these views out in their off-screen positions so the animation system can slide them out of view (instead of just fading them out).</p>
<p>仍在 scrap 中没有被移除的视图就是 disappearing views。 我们需要把它们放置到屏幕之外的位置，以便动画系统 将它们滑出视图(用来取代淡出动画)。</p>
<pre><code>@Override
public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
    …

    if (!state.isPreLayout() &amp;&amp; !recycler.getScrapList().isEmpty()) {
        final List&lt;RecyclerView.ViewHolder&gt; scrapList = recycler.getScrapList();
        final HashSet&lt;View&gt; disappearingViews = new HashSet&lt;View&gt;(scrapList.size());

        for (RecyclerView.ViewHolder holder : scrapList) {
            final View child = holder.itemView;
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            if (!lp.isItemRemoved()) {
                disappearingViews.add(child);
            }
        }

        for (View child : disappearingViews) {
            layoutDisappearingView(child);
        }
    }
}

private void layoutDisappearingView(View disappearingChild) {
    /*
     * LayoutManager has a special method for attaching views that
     * will only be around long enough to animate.
     */
    addDisappearingView(disappearingChild);

    //Adjust each disappearing view to its proper place
    final LayoutParams lp = (LayoutParams) disappearingChild.getLayoutParams();

    final int newRow = getGlobalRowOfPosition(lp.getViewPosition());
    final int rowDelta = newRow - lp.row;
    final int newCol = getGlobalColumnOfPosition(lp.getViewPosition());
    final int colDelta = newCol - lp.column;

    layoutTempChildView(disappearingChild, rowDelta, colDelta, disappearingChild);
}
</code></pre><blockquote>
<p>　小心：布局视图(然后将它们加入container)把它们从 scrap 列表中移除。 在开始变化前，小心处理你需要从 scrap 中获取的视图，否则你可能会 在这个集合上出现并发修改的问题结束运行。</p>
</blockquote>
<p>和之前处理 appearing views 的代码差不多，layoutDisappearingView() 将所有剩余 view 放在与之对应的”全局”位置作为最终布局位置。 给框架提供必要信息创建出适当方向的滑出动画。</p>
<p>下面的图片可以帮你理解FixedGridLayoutManager之中的过程：</p>
<ul>
<li>黑框是 RecyclerView 的可视边界。</li>
<li>Red View：数据集中被移除的 item。</li>
<li>Green View (Appearing View)：开始时没有，在 pre-layout 过程中被布局到屏幕外的item。</li>
<li>Purple Views (Disappearing views)：pre-layout 时期放置在他们的原始位置 ， real-layout 时期被布局到屏幕之外的位置。</li>
</ul>
<p><img src="http://7xlrpi.com1.z0.glb.clouddn.com/recycler_layoutmanager_3_3.gif" alt="layoutmanager_3"></p>
<h2 id="u54CD_u5E94_u5C4F_u5E55_u5916_u7684_u53D8_u52A8"><a href="#u54CD_u5E94_u5C4F_u5E55_u5916_u7684_u53D8_u52A8" class="headerlink" title="响应屏幕外的变动"></a>响应屏幕外的变动</h2><p>你或许注意到在上一节中我们可以判断可视 views 的移除操作。 如果变化出现在可视边界之外会怎样？这取决于你的布局结构， 像这样的变化可能需要你调整布局来达到更好的动画效果。</p>
<p>Adapter 会将这个变化 post 给你的 LayoutManager。你可以覆写 onItemsRemoved(), onItemsMoved(), onItemsAdded() 或者 onItemsChanged() 响应 item 的这些事件，无论 item 在当前布局中是否可见。</p>
<p>如果被移除的范围在可视边界之外， 调用 pre-layout 之前会调用 onItemRemoved()。我们可以利用它收集和这个变化有关的数据，为 这个事件可能触发的 appearing view 改变提供更好的支持。</p>
<p>示例中，我们像之前一样收集被移除的 view，但是将它们标记成不同的类型。</p>
<pre><code>@Override
public void onItemsRemoved(RecyclerView recyclerView, int positionStart, int itemCount) {
    mFirstChangedPosition = positionStart;
    mChangedPositionCount = itemCount;
}

@Override
public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
    …

    SparseIntArray removedCache = null;
    /*
     * During pre-layout, we need to take note of any views that are
     * being removed in order to handle predictive animations
     */
    if (state.isPreLayout()) {
        …

        //Track view removals that happened out of bounds (i.e. off-screen)
        if (removedCache.size() == 0 &amp;&amp; mChangedPositionCount &gt; 0) {
            for (int i = mFirstChangedPosition; i &lt; (mFirstChangedPosition + mChangedPositionCount); i++) {
                removedCache.put(i, REMOVE_INVISIBLE);
            }
        }
    }

    …

    //Fill the grid for the initial layout of views
    fillGrid(DIRECTION_NONE, childLeft, childTop, recycler, state.isPreLayout(), removedCache);

    …
}
</code></pre><blockquote>
<p>TIP：如果被移除的 item 是可见的，这个方法在 pre-layout 之后还会被调用。这也就是为什么 当被移除的可见 views 出现时我们仍要从它们获取数据。</p>
</blockquote>
<p>所有步骤就位，现在我们可以启动这个应用啦。可以看到左边消失的items 移到对应行的后面。右边新出现的 items 滑动进入现有的界面。 现在，新的动画中只有被移除的 item 是淡出的了。</p>
<p><img src="http://7xlrpi.com1.z0.glb.clouddn.com/recycler_layoutmanager_3_4.gif" alt="layoutmanager_4"></p>
<p>未完待续…<br><br>我说过…这应该是这系列中的最后一篇。不过，在编写 FixedGridLayoutManager 动画效果的过程中又出现了些有趣的问题，并不是所有自定义的实现。 所以在下一篇文章里(这次真的是最后一篇了)，我会解决这些问题。</p>
<p>特别感谢 Yiğit Boyar提供技术支持，帮助完成这篇文章。</p>
<p>如果你的 adapter 使用了固定的 IDs ，可以提供足够的数据推测哪些 view 被 移除/添加/等等 框架就会尝试 给它添加动画</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RecyclerView/">RecyclerView</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-RecyclerView-创建LayoutManager-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/14/RecyclerView-创建LayoutManager-2/" class="article-date">
  	<time datetime="2015-09-14T08:21:53.000Z" itemprop="datePublished">2015-09-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/14/RecyclerView-创建LayoutManager-2/">RecyclerView 创建LayoutManager-2</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上次我们讲了创建一个 RecyclerView LayoutManager 的核心步骤。接下来， 我们会介绍如何给普通基于适配器的 View 加入一些附加特性。</p>
<h2 id="Item_Decorations__u652F_u6301"><a href="#Item_Decorations__u652F_u6301" class="headerlink" title="Item Decorations 支持"></a>Item Decorations 支持</h2><p>RecyclerView 有一个很好的特性 RecyclerView.ItemDecoration，它可以给 子视图添加自定义样式，还可以在不修改子视图布局参数的情况下插入 布局属性(margins)。后者就是 LayoutManager 必须提供的约束子视图布局方式。</p>
<p><a href="https://github.com/devunwired/recyclerview-playground" target="_blank" rel="external">RecyclerPlayground</a> 里有几个 decorator 用来介绍它们的实现方式。<br>LayoutManager 中提供了一些辅助方法操作 decorations ，不需要我们自己实现：</p>
<ul>
<li>用getDecoratedLeft()代替child.getLeft()获取子视图的 left 边缘。</li>
<li>用getDecoratedTop()代替getTop()获取子视图的 top 边缘。</li>
<li>用getDecoratedRight()代替getRight()获取子视图的 right 边缘。</li>
<li>用getDecoratedBottom()代替getBottom()获取子视图的 bottom 边缘。</li>
<li>使用 measureChild() 或 measureChildWithMargins() 代替child.measure() 测量来自 Recycler 的新视图。</li>
<li>使用layoutDecorated()代替 child.layout() 布局来自 Recycler 的新视图。</li>
<li>使用 getDecoratedMeasuredWidth()或 getDecoratedMeasuredHeight() 代替 child.getMeasuredWidth()或child.getMeasuredHeight()获取 子视图的测量数据。</li>
</ul>
<p>只要你使用了正确的方法去获取视图的属性和测量数据，RecyclerView 会自己搞定细节部分的处理。</p>
<h2 id="u6570_u636E_u96C6_u6539_u53D8"><a href="#u6570_u636E_u96C6_u6539_u53D8" class="headerlink" title="数据集改变"></a>数据集改变</h2><p>当使用 notifyDataSetChanged()触发 RecyclerView.Adapter 的更新操作时， LayoutManager 负责更新布局中的视图。这时，onLayoutChildren()会被再次调用。 实现这个功能需要我们调整代码，判断出当前状态是生成一个新的视图 还是 adapter 更新期间的视图改变。下面是FixedGridLayoutManager中的填充方法的完整实现：</p>
<pre><code>@Override
public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
    //We have nothing to show for an empty data set but clear any existing views
    if (getItemCount() == 0) {
        detachAndScrapAttachedViews(recycler);
        return;
    }

    //...on empty layout, update child size measurements
    if (getChildCount() == 0) {
        //Scrap measure one child
        View scrap = recycler.getViewForPosition(0);
        addView(scrap);
        measureChildWithMargins(scrap, 0, 0);

        /*
         * We make some assumptions in this code based on every child
         * view being the same size (i.e. a uniform grid). This allows
         * us to compute the following values up front because they
         * won&apos;t change.
         */
        mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap);
        mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap);

        detachAndScrapView(scrap, recycler);
    }

    updateWindowSizing();

    int childLeft;
    int childTop;
    if (getChildCount() == 0) { //First or empty layout
        /*
         * Reset the visible and scroll positions
         */
        mFirstVisiblePosition = 0;
        childLeft = childTop = 0;
    } else if (getVisibleChildCount() &gt; getItemCount()) {
        //Data set is too small to scroll fully, just reset position
        mFirstVisiblePosition = 0;
        childLeft = childTop = 0;
    } else { //Adapter data set changes
        /*
         * Keep the existing initial position, and save off
         * the current scrolled offset.
         */
        final View topChild = getChildAt(0);
        if (mForceClearOffsets) {
            childLeft = childTop = 0;
            mForceClearOffsets = false;
        } else {
            childLeft = getDecoratedLeft(topChild);
            childTop = getDecoratedTop(topChild);
        }

        /*
         * Adjust the visible position if out of bounds in the
         * new layout. This occurs when the new item count in an adapter
         * is much smaller than it was before, and you are scrolled to
         * a location where no items would exist.
         */
        int lastVisiblePosition = positionOfIndex(getVisibleChildCount() - 1);
        if (lastVisiblePosition &gt;= getItemCount()) {
            lastVisiblePosition = (getItemCount() - 1);
            int lastColumn = mVisibleColumnCount - 1;
            int lastRow = mVisibleRowCount - 1;

            //Adjust to align the last position in the bottom-right
            mFirstVisiblePosition = Math.max(
                    lastVisiblePosition - lastColumn - (lastRow * getTotalColumnCount()), 0);

            childLeft = getHorizontalSpace() - (mDecoratedChildWidth * mVisibleColumnCount);
            childTop = getVerticalSpace() - (mDecoratedChildHeight * mVisibleRowCount);

            //Correct cases where shifting to the bottom-right overscrolls the top-left
            // This happens on data sets too small to scroll in a direction.
            if (getFirstVisibleRow() == 0) {
                childTop = Math.min(childTop, 0);
            }
            if (getFirstVisibleColumn() == 0) {
                childLeft = Math.min(childLeft, 0);
            }
        }
    }

    //Clear all attached views into the recycle bin
    detachAndScrapAttachedViews(recycler);

    //Fill the grid for the initial layout of views
    fillGrid(DIRECTION_NONE, childLeft, childTop, recycler);
}
</code></pre><p>我们根据有没有已经被 attach 的子视图来判断当前是一个新的布局还是一个更新操作。 如果是更新，我们根据第一个可见视图的 position（通过监测视图左上角是哪个子视图） 和当前 x/y 滑动的位移这些信息去执行新的 fillGrid()，同时保证左上角的 item 位置不变。</p>
<p>下面是一些需要特殊处理得情况：</p>
<ul>
<li>当新的数据集很小，不足以滑动时，布局会将左上角重置为 position 是 0 的item。</li>
<li>如果新的数据集很小，保持当前位置会使滚动超出边界。 我们就应该调整第一个 item 的位置，以便和右下角对齐。</li>
</ul>
<h2 id="onAdapterChanged_28_29"><a href="#onAdapterChanged_28_29" class="headerlink" title="onAdapterChanged()"></a>onAdapterChanged()</h2><p>这个方法提供了另一个重置布局的场所，设置新的 adapter 会触发这个事件 (在这，setAdapter会被再次调用)。 这个阶段你可以安全的返回一个与之前 adapter 完全不同的视图。所以， 示例中我们移除了所有当前视图(并没有回收它们)。</p>
<pre><code>@Override
public void onAdapterChanged(RecyclerView.Adapter oldAdapter, RecyclerView.Adapter newAdapter) {
    //Completely scrap the existing layout
    removeAllViews();
}
</code></pre><p>移除视图会触发一个新的布局过程，当 onLayoutChildren() 被再次调用时， 我们的代码会执行创建新视图的布局过程，因为现在没有 attched 的子视图。</p>
<h2 id="Scroll_to_Position"><a href="#Scroll_to_Position" class="headerlink" title="Scroll to Position"></a>Scroll to Position</h2><p>另一个重要的特性就是给 LayoutManager 添加滚动到特定位置的功能。 可以带有有动画效果，也可以没有，下面是对应的两个回调方法。</p>
<h3 id="scrollToPosition_28_29"><a href="#scrollToPosition_28_29" class="headerlink" title="scrollToPosition()"></a>scrollToPosition()</h3><p>当 layout 应该立即将所给位置设为第一个可见 item 时，调用 RecyclerView 的 scrollToPosition()。 在一个 vertical list 里，item 应该放在顶部；horizontal list 中，通常放在左边。在我们的 网格布局中，被选中的 item 应该放在视图的左上角。</p>
<pre><code>@Override
public void scrollToPosition(int position) {
    if (position &gt;= getItemCount()) {
        Log.e(TAG, &quot;Cannot scroll to &quot;+position+&quot;, item count is &quot;+getItemCount());
        return;
    }

    //Ignore current scroll offset, snap to top-left
    mForceClearOffsets = true;
    //Set requested position as first visible
    mFirstVisiblePosition = position;
    //Trigger a new view layout
    requestLayout();
}
</code></pre><p>因为有一个良好的 onLayoutChildren() 实现，这里就可以简单的更新目标位置并触发一个 新的 fill 操作。</p>
<h3 id="smoothScrollToPosition_28_29"><a href="#smoothScrollToPosition_28_29" class="headerlink" title="smoothScrollToPosition()"></a>smoothScrollToPosition()</h3><p>在带有动画的情况下，我们需要使用一些稍微不同的方法。 在这方法里我们需要创建一个 RecyclerView.SmoothScroller实例， 然后在方法返回前请求startSmoothScroll()启动动画。</p>
<p>RecyclerView.SmoothScroller 是提供 API 的抽象类，含有四个方法：</p>
<ul>
<li>onStart()：当滑动动画开始时被触发。</li>
<li>onStop()：当滑动动画停止时被触发。</li>
<li>onSeekTargetStep()：当 scroller 搜索目标 view 时被重复调用，这个方法负责读取提供的 dx/dy ，然后更新应该在这两个方向移动的距离。<ul>
<li>这个方法有一个RecyclerView.SmoothScroller.Action实例做参数。 通过向 action 的 update()方法传递新的 dx, dy, duration 和 Interpolator ， 告诉 view 在下一个阶段应该执行怎样的动画。</li>
<li><strong>NOTE：</strong> 如果动画耗时过长，框架会对你发出警告， 应该调整动画的步骤，尽量和框架标准的动画耗时相同。</li>
</ul>
</li>
<li>onTargetFound()：只在目标视图被 attach 后调用一次。 这是将目标视图要通过动画移动到准确位置最后的场所。<ul>
<li>在内部，当 view 被 attach 时使用 LayoutManager 的 findViewByPosition() 方法 查找对象。如果你的 LayoutManager 可以有效匹配 view 和 position ， 可以覆写这个方法来优化性能。默认提供的实现是通过每次遍历所有子视图查找。</li>
</ul>
</li>
</ul>
<p>你可以自己实现一个 scroller 达到你想要的效果。不过这里我们只使用系统提供的 LinearSmoothScroller 就好了。只需实现一个方法computeScrollVectorForPosition()， 然后告诉 scroller 初始方向还有从当前位置滚动到目标位置的大概距离。</p>
<pre><code>@Override
public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, final int position) {
    if (position &gt;= getItemCount()) {
        Log.e(TAG, &quot;Cannot scroll to &quot;+position+&quot;, item count is &quot;+getItemCount());
        return;
    }

    /*
     * LinearSmoothScroller&apos;s default behavior is to scroll the contents until
     * the child is fully visible. It will snap to the top-left or bottom-right
     * of the parent depending on whether the direction of travel was positive
     * or negative.
     */
    LinearSmoothScroller scroller = new LinearSmoothScroller(recyclerView.getContext()) {
        /*
         * LinearSmoothScroller, at a minimum, just need to know the vector
         * (x/y distance) to travel in order to get from the current positioning
         * to the target.
         */
        @Override
        public PointF computeScrollVectorForPosition(int targetPosition) {
            final int rowOffset = getGlobalRowOfPosition(targetPosition)
                    - getGlobalRowOfPosition(mFirstVisiblePosition);
            final int columnOffset = getGlobalColumnOfPosition(targetPosition)
                    - getGlobalColumnOfPosition(mFirstVisiblePosition);

            return new PointF(columnOffset * mDecoratedChildWidth, rowOffset * mDecoratedChildHeight);
        }
    };
    scroller.setTargetPosition(position);
    startSmoothScroll(scroller);
}
</code></pre><p>在这个实现中，和现有 ListView 的行为相似，无论是 RecyclerView 的哪个方向滚动， 当视图完全可见时滚动就会停止。</p>
<h2 id="u63A5_u4E0B_u6765_uFF1F"><a href="#u63A5_u4E0B_u6765_uFF1F" class="headerlink" title="接下来？"></a>接下来？</h2><p>我们现在已经有些起色了！事实上还有很多可以实现的功能。在下篇文章中，我们会介绍 如何给你的 LayoutManager 提供数据集改变时的动画效果。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RecyclerView/">RecyclerView</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-RecyclerView-创建LayoutManager-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/14/RecyclerView-创建LayoutManager-1/" class="article-date">
  	<time datetime="2015-09-14T06:25:15.000Z" itemprop="datePublished">2015-09-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/14/RecyclerView-创建LayoutManager-1/">RecyclerView 创建LayoutManager-1</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>现如今，如果你是 Android 开发者，你肯定听说过 RecyclerView 这个控件；<br>它是一个已经加入 support library 之中的新组件，通过方便的视图复用轻松实现自定义高效的视图集。<br>已经有很多优秀的文章介绍了 RecyclerView 基础，讲解如何使用RecyclerView 提供的内建部分，包括 item animations。所以，我们就不再重复前人的工作了，下面是一些帮你入门的资料：</p>
<ul>
<li><a href="http://www.grokkingandroid.com/first-glance-androids-recyclerview/" target="_blank" rel="external">A First Glance at Android’s RecyclerView</a></li>
<li><a href="http://lucasr.org/2014/07/31/the-new-twowayview/" target="_blank" rel="external">The new TwoWayView</a></li>
<li><a href="https://github.com/gabrielemariotti/RecyclerViewItemAnimators" target="_blank" rel="external">RecyclerViewItemAnimators</a></li>
</ul>
<p>我们的这个系列文章会关注 RecyclerView 底层细节，涉及到创建你自己的LayoutManager，做些比单一的 垂直/水平 滚动列表稍稍复杂的东西。</p>
<blockquote>
<p>在我们开始前，你需要知道 LayoutManager API 之所以能够让我们实现<br>强大复杂的布局是因为它只替你做了很少的工作；这就意味着你不得不自己完成数量可观的代码。如果要在一个项目中使用自定义视图，<br>不要陷入过度优化或过度泛化代码之中。你只需要关心在你的用例中需要实现的特性就可以了。</p>
</blockquote>
<h2 id="RecyclerView_Playground"><a href="#RecyclerView_Playground" class="headerlink" title="RecyclerView Playground"></a>RecyclerView Playground</h2><p>这个系列中所有的代码段都取自 <a href="https://github.com/devunwired/recyclerview-playground" target="_blank" rel="external">RecyclerView Playground sample</a> 这个项目，示例应用里包含了各个方面使用 RecyclerView 的实例，从创建简单的 list到自定义 LayoutManagers。</p>
<p>本文的代码来自 FixedGridLayoutManager ，一个可以垂直和水平滚动的二维的网格布局。</p>
<blockquote>
<p>support library 里也有一个自定义的 LayoutManager；本质上是一个自定义 vertical linear list 的实现：<br>[SDK_PATH]/extras/android/compatibility/samples/Support7Demos/src/com/example/android/supportv7/widget/RecyclerViewActivity.java<br>同时，Android L 和 新的 support libraries 可能还没加入 AOSP之中，不过 RecyclerView 提供了 JAR 资源，可以在这里找到：<br>[SDK_PATH]/extras/android/m2repository/com/android/support/recyclerview-v7/21.0.0-rc1/recyclerview-v7-21.0.0-rc1-sources.jar</p>
</blockquote>
<h2 id="The_Recycler"><a href="#The_Recycler" class="headerlink" title="The Recycler"></a>The Recycler</h2><p>首先，了解下 API 的结构。当你需要从一个可能再生的前子视图中回收旧的 view 或者 获取新的 view 时，你的 LayoutManager 可以访问一个 Recycler 实例。<br>Recycler 也免掉了直接访问 view 当前适配器方法的麻烦。当你的LayoutManager 需要一个新的子视图时，只要调用 getViewForPosition()<br>这个方法，Recycler 会决定到底是从头创建一个新的视图还是重用一个已存在的废弃视图。<br>你的 LayoutManager 需要及时将不再显示的视图传递给 Recycler，避免 Recycler 创建不必要的 view 对象。</p>
<h2 id="Detach_vs-_Remove"><a href="#Detach_vs-_Remove" class="headerlink" title="Detach vs. Remove"></a>Detach vs. Remove</h2><p>布局更新时有两个方法处理已存在的子视图：detach 和remove (分离和移除)。Detach 是一个轻量的记录 view 操作。<br>被 detach 的视图在你的代码返回前能够重新连接。可以通过 Recycler在不 重新绑定/重新构建 子视图的情况下修改已连接子视图的索引。<br>Remove 意味着这个 view 已经不需要了。任何被永久移除的 view 都应该放到 Recycler 中，方便以后重用，不过 API 并没有强制要求。被 remove 的视图是否被回收取决于你。</p>
<h3 id="Scrap_vs-_Recycle"><a href="#Scrap_vs-_Recycle" class="headerlink" title="Scrap vs. Recycle"></a>Scrap vs. Recycle</h3><p>Recycler 有两级视图缓存系统： scrap heap 和 recycle pool (垃圾堆和回收池)，Scrap heap 是一个轻量的集合，视图可以不经过适配器直接返回给LayoutManager 。通常被 detach但会在同一布局重新使用的视图会临时储存在这里。Recycle pool 存放的是那些假定并没有得到正确数据(相应位置的数据)的视图，因此它们都要经过适配器重新绑定后才能返回给 LayoutManager。当要给 LayoutManager 提供一个新 view 时，Recycler 首先会检查 scrap heap 有没有对应的 position/id；如果有对应的内容，就直接返回数据不需要通过适配器重新绑定。如果没有的话，Recycler 就会从 recycle pool 里弄一个合适的视图出来，然后用 adapter 给它绑定必要的数据(就是调用 RecyclerView.Adapter.bindViewHolder() ) 再返回。如果 recycle pool 中也不存在有效 view ，就会在绑定数据前创建新的 view (就是 RecyclerView.Adapter.createViewHolder() )，最后返回数据。</p>
<h2 id="u7ECF_u9A8C_u6CD5_u5219"><a href="#u7ECF_u9A8C_u6CD5_u5219" class="headerlink" title="经验法则"></a>经验法则</h2><p>只要你原意，LayoutManager 的 API 允许你独立完成所有这些任务，所以可能的组合有点多。通常来说，如果你想要临时整理并且希望稍后在同一布局中重新使用某个 view 的话，可以对它调用 detachAndScrapView() 。如果基于当前布局你不再需要某个 view 的话，对其调用 removeAndRecycleView() 。</p>
<h2 id="Building_The_Core"><a href="#Building_The_Core" class="headerlink" title="Building The Core"></a>Building The Core</h2><p>LayoutManager 需要实时添加，测量和布局所有它需要的子视图。当用户滚动屏幕时，布局管理器将来决定什么时候添加新的子视图，什么时候可以 detache/scrap (分离/废弃)视图。你需要实现下面这些方法创建一个可行的 LayoutManager 最小系统。</p>
<h3 id="generateDefaultLayoutParams_28_29"><a href="#generateDefaultLayoutParams_28_29" class="headerlink" title="generateDefaultLayoutParams()"></a>generateDefaultLayoutParams()</h3><p>事实上你只要重写这个方法你的 LayoutManager 就能编译通过了。实现也很简单，返回一个你想要默认应用给所有从Recycler 中获得的子视图做参数的 RecyclerView.LayoutParams 实例。这些参数会在对应的 getViewForPosition() 返回前赋值给相应的子视图。</p>
<pre><code>@Override
public RecyclerView.LayoutParams generateDefaultLayoutParams() {
    return new RecyclerView.LayoutParams(
        RecyclerView.LayoutParams.WRAP_CONTENT,
        RecyclerView.LayoutParams.WRAP_CONTENT);
}
</code></pre><h3 id="onLayoutChildren_28_29"><a href="#onLayoutChildren_28_29" class="headerlink" title="onLayoutChildren()"></a>onLayoutChildren()</h3><p>onLayoutChildren() 是 LayoutManager 的主入口。它会在 view 需要初始化布局时调用，当适配器的数据改变时(或者整个适配器被换掉时)会再次调用。</p>
<p>注意！这个方法不是在每次你对布局作出改变时调用的。它是 初始化布局 或者 在数据改变时重置子视图布局的好位置。</p>
<p>在接下来的部分，我们会分析在适配器更新时是怎样使用它基于当前可见元素刷新布局的。现在，我们将简单地解决这个问题当做子视图布局第一关。</p>
<p>下面是 FixedGridLayoutManager 示例的精简版：</p>
<pre><code>@Override
public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
      //Scrap measure one child
      View scrap = recycler.getViewForPosition(0);
      addView(scrap);
      measureChildWithMargins(scrap, 0, 0);
      /*
        * We make some assumptions in this code based on every child
        * view being the same size (i.e. a uniform grid). This allows
        * us to compute the following values up front because they
        * won&apos;t change.
        */
      mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap);
      mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap);
      detachAndScrapView(scrap, recycler);
      updateWindowSizing();
      int childLeft;
      int childTop;
      /*
        * Reset the visible and scroll positions
        */
      mFirstVisiblePosition = 0;
      childLeft = childTop = 0;
      //Clear all attached views into the recycle bin
      detachAndScrapAttachedViews(recycler);
      //Fill the grid for the initial layout of views
      fillGrid(DIRECTION_NONE, childLeft, childTop, recycler);
}
</code></pre><p>我们会对子视图做一些记录和安排(为了简便，假设来自适配器的所有子视图都是一样大的)，确保所有已存在的视图在 scrap heap 之中。我将<br>大部分工作抽象到 fillGrid() 这个辅助方法中以便重用。我们很快就会看到这个方法在更新可见视图和滚动屏幕中被大量调用。</p>
<blockquote>
<p>就像是自定义实现一个 ViewGroup，你负责触发测量和布局每一个从 Recycler 获取到的子视图。API 没有直接完成这项工作 。</p>
</blockquote>
<p>通常来说，在这类方法之中你需要完成的主要步骤如下：</p>
<ol>
<li>在滚动事件结束后检查所有附加视图当前的偏移位置。</li>
<li>判断是否需要添加新视图填充由滚动屏幕产生的空白部分。并从 Recycler 中获取视图。</li>
<li>判断当前视图是否不再显示。移除它们并放置到 Recycler 中。</li>
<li>判断剩余视图是否需要整理。发生上述变化后可能 需要你修改视图的子索引来更好地和它们的适配器位置校准。</li>
</ol>
<p>注意我们放进 FixedGridLayoutManager.fillGrid() 里填充 RecyclerView 的主要步骤。</p>
<p>当到达最大行数时，这个 manager 将位置从右到左排序，封装。</p>
<ol>
<li><p>清点目前我们所有的视图。将他们 Detach 以便稍后重新连接。</p>
<pre><code>SparseArray&lt;View&gt; viewCache = new SparseArray&lt;View&gt;(getChildCount());
//...
if (getChildCount() != 0) {
    //...
    //Cache all views by their existing position, before updating counts
      for (int i=0; i &lt; getChildCount(); i++) {
        int position = positionOfIndex(i);
        final View child = getChildAt(i);
        viewCache.put(position, child);
      }
      //Temporarily detach all views.
      // Views we still need will be added back at the proper index.
      for (int i=0; i &lt; viewCache.size(); i++) {
        detachView(viewCache.valueAt(i));
      }
}
</code></pre></li>
<li><p>测量/布局每一个当前可见的子视图。重新连接已有的视图很简单；新的视图是从 Recycler 之中获取的。</p>
<pre><code>for (int i = 0; i &lt; getVisibleChildCount(); i++) {
      //...
      //Layout this position
      View view = viewCache.get(nextPosition);
      if (view == null) {
        /*
           * The Recycler will give us either a newly constructed view,
           * or a recycled view it has on-hand. In either case, the
           * view will already be fully bound to the data by the
            * adapter for us.
           */
        view = recycler.getViewForPosition(nextPosition);
        addView(view);
        /*
           * It is prudent to measure/layout each new view we
            * receive from the Recycler. We don&apos;t have to do
           * this for views we are just re-arranging.
           */
        measureChildWithMargins(view, 0, 0);
        layoutDecorated(view, leftOffset, topOffset,
        leftOffset + mDecoratedChildWidth,
        topOffset + mDecoratedChildHeight);
      } else {
        //Re-attach the cached view at its new index
        attachView(view);
        viewCache.remove(nextPosition);
      }
      //...
}
</code></pre></li>
<li><p>最终，所有在第一步中 detach 并且没有被重新连接的视图都不可见。将它们移入 Recycler 中，以备后用。</p>
<pre><code>for (int i=0; i &lt; viewCache.size(); i++) {
    recycler.recycleView(viewCache.valueAt(i));
}
</code></pre></li>
</ol>
<p>说明一下，先将所有视图 detach 之后再将需要的视图重新连接是为了保持每一个视图子索引的顺序 (就是 getChildAt() 的索引)。我们希望可见视图从左上到右下的索引从 0 开始，到 getChildCount()-1 结束。当我们上下滑动视图，新的子视图被添加，它的索引顺序会变得不可靠。我们需要保留正确的索引来在任意点上定位每一个视图。在一个简单地LayoutManager (比如 LinearLayoutManager)中，子视图可以轻松地插入list 的两端， 记录层就没有存在的必要了。</p>
<h2 id="u6DFB_u52A0_u7528_u6237_u4EA4_u4E92"><a href="#u6DFB_u52A0_u7528_u6237_u4EA4_u4E92" class="headerlink" title="添加用户交互"></a>添加用户交互</h2><p>目前，我们已经有一个非常好的初始布局，但是它并不能动起来。RecyclerView 的关键就在于当用户浏览一组数据时动态提供视图。覆盖一些方法就能实现我们的目的。</p>
<h3 id="canScrollHorizontally_28_29__26amp_3B_canScrollVertically_28_29"><a href="#canScrollHorizontally_28_29__26amp_3B_canScrollVertically_28_29" class="headerlink" title="canScrollHorizontally() &amp; canScrollVertically()"></a>canScrollHorizontally() &amp; canScrollVertically()</h3><p>这些方法很简单，在你想要滚动方向对应的方法里返回 true ，不想要滚动方向对应的方法里返回 false。</p>
<pre><code>@Override
public boolean canScrollVertically() {
    //We do allow scrolling
    return true;
}
</code></pre><h3 id="scrollHorizontallyBy_28_29__26amp_3B_scrollVerticallyBy_28_29"><a href="#scrollHorizontallyBy_28_29__26amp_3B_scrollVerticallyBy_28_29" class="headerlink" title="scrollHorizontallyBy() &amp; scrollVerticallyBy()"></a>scrollHorizontallyBy() &amp; scrollVerticallyBy()</h3><p>在这里你应该实现 content 移动的逻辑。RecyclerView 已经处理了 scrolling和 <a href="http://www.google.com/design/spec/patterns/gestures.html#gestures-touch-mechanics" target="_blank" rel="external">flinging</a> (注：Fling: Gross gesture, no on-screen target)触摸操作，不需要处理 MotionEvents 或者 GestureDetectors 这些麻烦事。<br>你只需要完成下面这三个任务：</p>
<ol>
<li>将所有的子视图移动适当的位置 (对的，你得自己做这个)。</li>
<li>决定移动视图后 添加/移除 视图。</li>
<li>返回滚动的实际距离。框架会根据它判断你是否触碰到边界。</li>
</ol>
<p>在 FixedGridLayoutManager 里，这两个方法很像。这里是精简后的垂直滚动实现：</p>
<pre><code>@Override
public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler,
    RecyclerView.State state) {
  if (getChildCount() == 0) {
    return 0;
  }
  //Take top measurements from the top-left child
  final View topView = getChildAt(0);
  //Take bottom measurements from the bottom-right child.
  final View bottomView = getChildAt(getChildCount()-1);
  //Optimize the case where the entire data set is too small to scroll
  int viewSpan = getDecoratedBottom(bottomView) - getDecoratedTop(topView);
  if (viewSpan &lt;= getVerticalSpace()) {
    //We cannot scroll in either direction
    return 0;
  }
  int delta;
  int maxRowCount = getTotalRowCount();
  boolean topBoundReached = getFirstVisibleRow() == 0;
  boolean bottomBoundReached = getLastVisibleRow() &gt;= maxRowCount;
  if (dy &gt; 0) { // Contents are scrolling up
    //Check against bottom bound
    if (bottomBoundReached) {
      //If we&apos;ve reached the last row, enforce limits
      int bottomOffset;
      if (rowOfIndex(getChildCount() - 1) &gt;= (maxRowCount - 1)) {
        //We are truly at the bottom, determine how far
        bottomOffset = getVerticalSpace() - getDecoratedBottom(bottomView)
            + getPaddingBottom();
      } else {
        /*
         * Extra space added to account for allowing bottom space in the grid.
         * This occurs when the overlap in the last row is not large enough to
         * ensure that at least one element in that row isn&apos;t fully recycled.
         */
        bottomOffset = getVerticalSpace() - (getDecoratedBottom(bottomView)
            + mDecoratedChildHeight) + getPaddingBottom();
      }
      delta = Math.max(-dy, bottomOffset);
    } else {
      //No limits while the last row isn&apos;t visible
      delta = -dy;
    }
  } else { // Contents are scrolling down
    //Check against top bound
    if (topBoundReached) {
      int topOffset = -getDecoratedTop(topView) + getPaddingTop();
      delta = Math.min(-dy, topOffset);
    } else {
      delta = -dy;
    }
  }
  offsetChildrenVertical(delta);
  if (dy &gt; 0) {
    if (getDecoratedBottom(topView) &lt; 0 &amp;&amp; !bottomBoundReached) {
      fillGrid(DIRECTION_DOWN, recycler);
     } else if (!bottomBoundReached) {
      fillGrid(DIRECTION_NONE, recycler);
     }
  } else {
    if (getDecoratedTop(topView) &gt; 0 &amp;&amp; !topBoundReached) {
      fillGrid(DIRECTION_UP, recycler);
    } else if (!topBoundReached) {
      fillGrid(DIRECTION_NONE, recycler);
    }
  }
  /*
   * Return value determines if a boundary has been reached
   * (for edge effects and flings). If returned value does not
   * match original delta (passed in), RecyclerView will draw
   * an edge effect.
   */
  return -delta;
}
</code></pre><p>我们获得了滚动距离(dx/dy)的增量来验证。方法的第一部分判断按照所给的距离(标志给了滚动方向)滚动会不会超过边界。如果会，我们需要计算出视图实际滚动的距离。</p>
<p>在这个方法里，我们需要自己手工移动这些视图。offsetChildrenVertical() 和 offsetChildrenHorizontal()这两个方法 可以帮助我们处理匀速移动。如果你不实现它，你的视图就不会滚动。</p>
<p>移动视图操作完成后，我们触发另一个填充操作，根据滚动的距离替换视图。</p>
<p>最后，将实际位移距离应用给子视图。RecyclerView 根据这个值判断是否绘制到达边界的效果。一般意义上，如果返回值不等于传入的值就意味着需要绘制边缘的发光效果了。如果你返回了一个带有错误方向的值，框架的函数会把这个当做一个大的变化你将不能获得正确的边缘发光特效。</p>
<p>除了用来判断绘制边界特效外，返回值还被用来决定什么时候取消 flings。返回错误的值会让你失去对 content fling 的控制。框架会认为你已经提前触碰到边缘并取消了 fling。</p>
<h2 id="u70ED_u8EAB_u7ED3_u675F_7E"><a href="#u70ED_u8EAB_u7ED3_u675F_7E" class="headerlink" title="热身结束~"></a>热身结束~</h2><p>目前，我们已经实现了基本的功能。它少了很多的细节部分，不过滚动和适当的视图回收已经完成了。关于自定义 LayoutManager 还有很多要说的东西。接下来 ，我们会细致的介绍 decorations, data set changes还有实现滚动到特定位置。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RecyclerView/">RecyclerView</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Manifest文件属性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/13/Manifest文件属性/" class="article-date">
  	<time datetime="2015-09-13T13:54:18.000Z" itemprop="datePublished">2015-09-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/13/Manifest文件属性/">Manifest文件属性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u4E00_u3001_u5173_u4E8EAndroidManifest-xml"><a href="#u4E00_u3001_u5173_u4E8EAndroidManifest-xml" class="headerlink" title="一、关于AndroidManifest.xml"></a>一、关于AndroidManifest.xml</h2><p>AndroidManifest.xml 是每个android程序中必须的文件。它位于整个项目的根目录，描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders, Services, 和Intent Receivers,还能指定permissions和instrumentation（安全控制和测试）</p>
<h2 id="u4E8C_u3001AndroidManifest-xml_u7ED3_u6784"><a href="#u4E8C_u3001AndroidManifest-xml_u7ED3_u6784" class="headerlink" title="二、AndroidManifest.xml结构"></a>二、AndroidManifest.xml结构</h2><pre><code>&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;
&lt;manifest&gt;
    &lt;application&gt;
           &lt;activity&gt;
           &lt;intent-filter&gt;
               &lt;action/&gt;
               &lt;category/&gt;
            &lt;/intent-filter&gt;
         &lt;/activity&gt;
         &lt;activity-alias&gt;
             &lt;intent-filter&gt;&lt;/intent-filter&gt;
            &lt;meta-data/&gt;
         &lt;/activity-alias&gt;
         &lt;service&gt;
             &lt;intent-filter&gt;&lt;/intent-filter&gt;
            &lt;meta-data/&gt;
         &lt;/service&gt;
         &lt;receiver&gt;
             &lt;intent-filter&gt;&lt;/intent-filter&gt;
            &lt;meta-data/&gt;
         &lt;/receiver&gt;
         &lt;provider&gt;
            &lt;grant-uri-permission/&gt;
            &lt;meta-data/&gt;
         &lt;/provider&gt;
        &lt;uses-library/&gt;
    &lt;/application&gt;
    &lt;uses-permission/&gt;
    &lt;permission/&gt;
    &lt;permission-tree/&gt;
    &lt;permission-group/&gt;
    &lt;instrumentation/&gt;
    &lt;uses-sdk/&gt;
    &lt;uses-configuration/&gt; 
    &lt;uses-feature/&gt; 
    &lt;supports-screens/&gt;
&lt;/manifest&gt;
</code></pre><h2 id="u4E09_u3001_u5404_u4E2A_u8282_u70B9_u7684_u8BE6_u7EC6_u4ECB_u7ECD"><a href="#u4E09_u3001_u5404_u4E2A_u8282_u70B9_u7684_u8BE6_u7EC6_u4ECB_u7ECD" class="headerlink" title="三、各个节点的详细介绍"></a>三、各个节点的详细介绍</h2><p>上面就是整个am(androidManifest).xml的结构，下面以外向内开始阐述～～</p>
<h3 id="1_u3001_u7B2C_u4E00_u5C42_28Manifest_29_3A_28_u5C5E_u6027_29"><a href="#1_u3001_u7B2C_u4E00_u5C42_28Manifest_29_3A_28_u5C5E_u6027_29" class="headerlink" title="1、第一层(Manifest):(属性)"></a>1、第一层(Manifest):(属性)</h3><pre><code>&lt;manifest  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
      package=&quot;com.woody.test&quot;
      android:sharedUserId=&quot;string&quot;
      android:sharedUserLabel=&quot;string resource&quot;
      android:versionCode=&quot;integer&quot;
      android:versionName=&quot;string&quot;
      android:installLocation=[&quot;auto&quot; | &quot;internalOnly&quot; | &quot;preferExternal&quot;] &gt;
&lt;/manifest&gt;
</code></pre><p> A、xmlns:android<br>定义android命名空间，一般为<a href="http://schemas.android.com/apk/res/android，这样使得Android中各种标准属性能在文件中使用，提供了大部分元素中的数据。" target="_blank" rel="external">http://schemas.android.com/apk/res/android，这样使得Android中各种标准属性能在文件中使用，提供了大部分元素中的数据。</a></p>
<p>B、package<br>指定本应用内java主程序包的包名，它也是一个应用进程的默认名称</p>
<p>C、sharedUserId<br>表明数据权限，因为默认情况下，Android给每个APK分配一个唯一的UserID，所以是默认禁止不同APK访问共享数据的。若要共享数据，第一可以采用Share Preference方法，第二种就可以采用sharedUserId了，将不同APK的sharedUserId都设为一样，则这些APK之间就可以互相共享数据了。</p>
<p>D、sharedUserLabel<br>一个共享的用户名，它只有在设置了sharedUserId属性的前提下才会有意义</p>
<p>E、versionCode<br>是给设备程序识别版本(升级)用的必须是一个interger值代表app更新过多少次，比如第一版一般为1，之后若要更新版本就设置为2，3等等。。。</p>
<p> F、versionName<br>这个名称是给用户看的，你可以将你的APP版本号设置为1.1版，后续更新版本设置为1.2、2.0版本等等。。。</p>
<p>G、installLocation<br>安装参数，是Android2.2中的一个新特性，installLocation有三个值可以选择：internalOnly、auto、preferExternal</p>
<blockquote>
<p>选择preferExternal,系统会优先考虑将APK安装到SD卡上(当然最终用户可以选择为内部ROM存储上，如果SD存储已满，也会安装到内部存储上)</p>
<p>选择auto，系统将会根据存储空间自己去适应</p>
<p>选择internalOnly是指必须安装到内部才能运行<br>(注：需要进行后台类监控的APP最好安装在内部，而一些较大的游戏APP最好安装在SD卡上。现默认为安装在内部，如果把APP安装在SD卡上，首先得 设置你的level为8，并且要配置android:installLocation这个参数的属性为preferExternal)</p>
</blockquote>
<h3 id="2_u3001_u7B2C_u4E8C_u5C42_28Application_29_3A_u5C5E_u6027"><a href="#2_u3001_u7B2C_u4E8C_u5C42_28Application_29_3A_u5C5E_u6027" class="headerlink" title="2、第二层(Application):属性"></a>2、第二层(Application):属性</h3><p>一个AndroidManifest.xml中必须含有一个Application标签，这个标签声明了每一个应用程序的组件及其属性(如icon,label,permission等)</p>
<pre><code>&lt;application  android:allowClearUserData=[&quot;true&quot; | &quot;false&quot;]
     android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;]
     android:backupAgent=&quot;string&quot;
     android:debuggable=[&quot;true&quot; | &quot;false&quot;]
     android:description=&quot;string resource&quot;
     android:enabled=[&quot;true&quot; | &quot;false&quot;]
     android:hasCode=[&quot;true&quot; | &quot;false&quot;]
     android:icon=&quot;drawable resource&quot;
     android:killAfterRestore=[&quot;true&quot; | &quot;false&quot;]
     android:label=&quot;string resource&quot;
     android:manageSpaceActivity=&quot;string&quot;
     android:name=&quot;string&quot;
     android:permission=&quot;string&quot;
     android:persistent=[&quot;true&quot; | &quot;false&quot;]
     android:process=&quot;string&quot;
     android:restoreAnyVersion=[&quot;true&quot; | &quot;false&quot;]
     android:taskAffinity=&quot;string&quot;
     android:theme=&quot;resource or theme&quot; &gt;
&lt;/application&gt;
</code></pre><p> A、android:allowClearUserData(‘true’ or ‘false’)<br>用户是否能选择自行清除数据，默认为true，程序管理器包含一个选择允许用户清除数据。当为true时，用户可自己清理用户数据，反之亦然</p>
<p> B、android:allowTaskReparenting(‘true’ or ‘false’)<br>是否允许activity更换从属的任务，比如从短信息任务切换到浏览器任务</p>
<p>C、android:backupAgent<br>这也是Android2.2中的一个新特性，设置该APP的备份，属性值应该是一个完整的类名，如com.project.TestCase，此属性并没有默认值，并且类名必须得指定(就是个备份工具，将数据备份到云端的操作)</p>
<p> D、android:debuggable<br>这个从字面上就可以看出是什么作用的，当设置为true时，表明该APP在手机上可以被调试。默认为false,在false的情况下调试该APP，就会报以下错误：<br>Device XXX requires that applications explicitely declare themselves as debuggable in their manifest.<br>Application XXX does not have the attribute ‘debuggable’ set to TRUE in its manifest and cannot be debugged.</p>
<p>E、android:description/android:label<br>此两个属性都是为许可提供的，均为字符串资源，当用户去看许可列表(android:label)或者某个许可的详细信息 (android:description)时，这些字符串资源就可以显示给用户。label应当尽量简短，之需要告知用户该许可是在保护什么功能就行。 而description可以用于具体描述获取该许可的程序可以做哪些事情，实际上让用户可以知道如果他们同意程序获取该权限的话，该程序可以做什么。我 们通常用两句话来描述许可，第一句描述该许可，第二句警告用户如果批准该权限会可能有什么不好的事情发生</p>
<p>F、android:enabled<br>Android系统是否能够实例化该应用程序的组件，如果为true，每个组件的enabled属性决定那个组件是否可以被 enabled。如果为false，它覆盖组件指定的值；所有组件都是disabled。</p>
<p>G、android:hasCode(‘true’ or ‘false’)<br>表示此APP是否包含任何的代码，默认为true，若为false，则系统在运行组件时，不会去尝试加载任何的APP代码<br>一个应用程序自身不会含有任何的代码，除非内置组件类，比如Activity类，此类使用了AliasActivity类，当然这是个罕见的现象<br>(在Android2.3可以用标准C来开发应用程序，可在androidManifest.xml中将此属性设置为false,因为这个APP本身已经不含有任何的JAVA代码了)</p>
<p>H、android:icon<br>这个很简单，就是声明整个APP的图标，图片一般都放在drawable文件夹下<br>I、android:killAfterRestore<br>J、android:manageSpaceActivity<br>K、android:name<br>为应用程序所实现的Application子类的全名。当应用程序进程开始时，该类在所有应用程序组件之前被实例化。<br>若该类(比方androidMain类)是在声明的package下，则可以直接声明android:name=”androidMain”,但此类是在 package下面的子包的话，就必须声明为全路径或android:name=”package名称.子包名成.androidMain”</p>
<p>L、android:permission<br>设置许可名，这个属性若在<application>上定义的话，是一个给应用程序的所有组件设置许可的便捷方式，当然它是被各组件设置的许可名所覆盖的</application></p>
<p>M、android:presistent<br>该应用程序是否应该在任何时候都保持运行状态,默认为false。因为应用程序通常不应该设置本标识，持续模式仅仅应该设置给某些系统应用程序才是有意义的。</p>
<p>N、android:process<br>应用程序运行的进程名，它的默认值为<manifest>元素里设置的包名，当然每个组件都可以通过设置该属性来覆盖默认值。如果你想两个应 用程序共用一个进程的话，你可以设置他们的android:process相同，但前提条件是他们共享一个用户ID及被赋予了相同证书的时候</manifest></p>
<p>O、android:restoreAnyVersion<br>同样也是android2.2的一个新特性，用来表明应用是否准备尝试恢复所有的备份，甚至该备份是比当前设备上更要新的版本，默认是false</p>
<p>P、android:taskAffinity<br>拥有相同的affinity的Activity理论上属于相同的Task，应用程序默认的affinity的名字是<manifest>元素中设定的package名</manifest></p>
<p>Q、android:theme<br>是一个资源的风格，它定义了一个默认的主题风格给所有的activity,当然也可以在自己的theme里面去设置它，有点类似style。</p>
<h3 id="3_u3001_u7B2C_u4E09_u5C42_28Activity_29_3A_u5C5E_u6027"><a href="#3_u3001_u7B2C_u4E09_u5C42_28Activity_29_3A_u5C5E_u6027" class="headerlink" title="3、第三层(Activity):属性"></a>3、第三层(Activity):属性</h3><pre><code> &lt;activity android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;]
     android:alwaysRetainTaskState=[&quot;true&quot; | &quot;false&quot;]
     android:clearTaskOnLaunch=[&quot;true&quot; | &quot;false&quot;]
     android:configChanges=[&quot;mcc&quot;, &quot;mnc&quot;, &quot;locale&quot;,
                        &quot;touchscreen&quot;, &quot;keyboard&quot;, &quot;keyboardHidden&quot;,
                        &quot;navigation&quot;, &quot;orientation&quot;, &quot;screenLayout&quot;,
                        &quot;fontScale&quot;, &quot;uiMode&quot;]
     android:enabled=[&quot;true&quot; | &quot;false&quot;]
     android:excludeFromRecents=[&quot;true&quot; | &quot;false&quot;]
     android:exported=[&quot;true&quot; | &quot;false&quot;]
     android:finishOnTaskLaunch=[&quot;true&quot; | &quot;false&quot;]
     android:icon=&quot;drawable resource&quot;
     android:label=&quot;string resource&quot;
     android:launchMode=[&quot;multiple&quot; | &quot;singleTop&quot; |
                     &quot;singleTask&quot; | &quot;singleInstance&quot;]
     android:multiprocess=[&quot;true&quot; | &quot;false&quot;]
     android:name=&quot;string&quot;
     android:noHistory=[&quot;true&quot; | &quot;false&quot;]  
     android:permission=&quot;string&quot;
     android:process=&quot;string&quot;
     android:screenOrientation=[&quot;unspecified&quot; | &quot;user&quot; | &quot;behind&quot; |
                                &quot;landscape&quot; | &quot;portrait&quot; |
                                &quot;sensor&quot; | &quot;nosensor&quot;]
     android:stateNotNeeded=[&quot;true&quot; | &quot;false&quot;]
     android:taskAffinity=&quot;string&quot;
     android:theme=&quot;resource or theme&quot;
     android:windowSoftInputMode=[&quot;stateUnspecified&quot;,
                              &quot;stateUnchanged&quot;, &quot;stateHidden&quot;,
                              &quot;stateAlwaysHidden&quot;, &quot;stateVisible&quot;,
                              &quot;stateAlwaysVisible&quot;, &quot;adjustUnspecified&quot;,
                              &quot;adjustResize&quot;, &quot;adjustPan&quot;] &gt;   
&lt;/activity&gt;
</code></pre><p>(注：有些在application中重复的就不多阐述了)</p>
<p>1、android:alwaysRetainTaskState<br>是否保留状态不变， 比如切换回home, 再从新打开，activity处于最后的状态。比如一个浏览器拥有很多状态(当打开了多个TAB的时候)，用户并不希望丢失这些状态时，此时可将此属性设置为true</p>
<p>2、android:clearTaskOnLaunch<br>比如 P 是 activity, Q 是被P 触发的 activity, 然后返回Home, 重新启动 P，是否显示 Q</p>
<p>3、android:configChanges<br>当配置list发生修改时， 是否调用 onConfigurationChanged() 方法  比如 “locale|navigation|orientation”. </p>
<p> 这个我用过,主要用来看手机方向改变的. android手机在旋转后,layout会重新布局, 如何做到呢?<br>正常情况下. 如果手机旋转了.当前Activity后杀掉,然后根据方向重新加载这个Activity. 就会从onCreate开始重新加载.</p>
<p>如果你设置了 这个选项, 当手机旋转后,当前Activity之后调用onConfigurationChanged() 方法. 而不跑onCreate方法等.</p>
<p>4、android:excludeFromRecents<br>是否可被显示在最近打开的activity列表里，默认是false</p>
<p>5、android:finishOnTaskLaunch<br>当用户重新启动这个任务的时候，是否关闭已打开的activity，默认是false<br>如果这个属性和allowTaskReparenting都是true,这个属性就是王牌。Activity的亲和力将被忽略。该Activity已经被摧毁并非re-parented</p>
<p>6、android:launchMode(Activity加载模式)<br>在多Activity开发中，有可能是自己应用之间的Activity跳转，或者夹带其他应用的可复用Activity。可能会希望跳转到原来某个 Activity实例，而不是产生大量重复的Activity。这需要为Activity配置特定的加载模式，而不是使用默认的加载模式</p>
<p>Activity有四种加载模式：<br>standard、singleTop、singleTask、singleInstance(其中前两个是一组、后两个是一组)，默认为standard </p>
<ul>
<li>standard：就是intent将发送给新的实例，所以每次跳转都会生成新的activity。</li>
<li>singleTop：也是发送新的实例，但不同standard的一点是，在请求的Activity正好位于栈顶时(配置成singleTop的Activity)，不会构造新的实例</li>
<li>singleTask：和后面的singleInstance都只创建一个实例，当intent到来，需要创建设置为singleTask的Activity的时候，系统会检查栈里面是否已经有该Activity的实例。如果有直接将intent发送给它。</li>
<li>singleInstance：<br>首先说明一下task这个概念，Task可以认为是一个栈，可放入多个Activity。比如启动一个应用，那么Android就创建了一个Task，然 后启动这个应用的入口Activity，那在它的界面上调用其他的Activity也只是在这个task里面。那如果在多个task中共享一个 Activity的话怎么办呢。举个例来说，如果开启一个导游服务类的应用程序，里面有个Activity是开启GOOGLE地图的，当按下home键退 回到主菜单又启动GOOGLE地图的应用时，显示的就是刚才的地图，实际上是同一个Activity，实际上这就引入了singleInstance。 singleInstance模式就是将该Activity单独放入一个栈中，这样这个栈中只有这一个Activity，不同应用的intent都由这个 Activity接收和展示，这样就做到了共享。当然前提是这些应用都没有被销毁，所以刚才是按下的HOME键，如果按下了返回键，则无效</li>
</ul>
<p>7、android:multiprocess<br>是否允许多进程，默认是false</p>
<p>8、android:noHistory<br>当用户从Activity上离开并且它在屏幕上不再可见时，Activity是否从Activity stack中清除并结束。默认是false。Activity不会留下历史痕迹</p>
<p>9、android:screenOrientation<br>activity显示的模式</p>
<ul>
<li><p>默认为unspecified：由系统自动判断显示方向</p>
</li>
<li><p>landscape横屏模式，宽度比高度大</p>
</li>
<li><p>portrait竖屏模式, 高度比宽度大</p>
</li>
<li><p>user模式，用户当前首选的方向</p>
</li>
<li><p>behind模式：和该Activity下面的那个Activity的方向一致(在Activity堆栈中的)</p>
</li>
<li><p>sensor模式：有物理的感应器来决定。如果用户旋转设备这屏幕会横竖屏切换</p>
</li>
<li><p>nosensor模式：忽略物理感应器，这样就不会随着用户旋转设备而更改了</p>
</li>
</ul>
<p>10、android:stateNotNeeded<br>activity被销毁或者成功重启时是否保存状态</p>
<p>11、android:windowSoftInputMode<br>activity主窗口与软键盘的交互模式，可以用来避免输入法面板遮挡问题，Android1.5后的一个新特性。</p>
<p>这个属性能影响两件事情：</p>
<pre><code>【A】当有焦点产生时，软键盘是隐藏还是显示

【B】是否减少活动主窗口大小以便腾出空间放软键盘
</code></pre><p>各值的含义：</p>
<pre><code>【A】stateUnspecified：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置

【B】stateUnchanged：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示

【C】stateHidden：用户选择activity时，软键盘总是被隐藏

【D】stateAlwaysHidden：当该Activity主窗口获取焦点时，软键盘也总是被隐藏的

【E】stateVisible：软键盘通常是可见的

【F】stateAlwaysVisible：用户选择activity时，软键盘总是显示的状态

【G】adjustUnspecified：默认设置，通常由系统自行决定是隐藏还是显示

【H】adjustResize：该Activity总是调整屏幕的大小以便留出软键盘的空间

【I】adjustPan：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分
</code></pre><p>12、android:allowTaskReparenting<br>与许任务重定向 , 如果设置为true , 则之前打开的页面依然存在.</p>
<h3 id="4_u3001_u7B2C_u56DB_u5C42_28intent-filter_29"><a href="#4_u3001_u7B2C_u56DB_u5C42_28intent-filter_29" class="headerlink" title="4、第四层(intent-filter)"></a>4、第四层(intent-filter)</h3><p>结构图：<br>    <intent-filter android:icon="drawable resource" android:label="string resource" android:priority="integer"><br>        <action><br>        <category><br>        <data><br>    </data></category></action></intent-filter> </p>
<p>intent-filter属性 </p>
<ul>
<li>android:priority(解释：有序广播主要是按照声明的优先级别，如A的级别高于B，那么，广播先传给A，再传给B。优先级别就是用设置priority属性来确定，范围是从-1000～1000，数越大优先级别越高)</li>
</ul>
<p>Intent filter内会设定的资料包括action,data与category三种。也就是说filter只会与intent里的这三种资料作对比动作</p>
<ul>
<li><p>action属性<br>action很简单，只有android:name这个属性。常见的android:name值为android.intent.action.MAIN，表明此activity是作为应用程序的入口。有关android:name具体有哪些值，可参照这个网址：<a href="http://hi.baidu.com/linghtway/bl" target="_blank" rel="external">http://hi.baidu.com/linghtway/bl</a> … d053170ff477a7.html</p>
</li>
<li><p>category属性<br>category也只有android:name属性。常见的android:name值为android.intent.category.LAUNCHER(决定应用程序是否显示在程序列表里)<br>有关android:name具体有哪些值，可参照这个网址： <a href="http://chroya.javaeye.com/blog/685871" target="_blank" rel="external">http://chroya.javaeye.com/blog/685871</a></p>
</li>
<li><p>data属性<br>  &lt;data  android:host=”string”</p>
<pre><code>android:mimeType=&quot;string&quot;
android:path=&quot;string&quot;
android:pathPattern=&quot;string&quot;
android:pathPrefix=&quot;string&quot;
android:port=&quot;string&quot;
android:scheme=&quot;string&quot;/&gt;
</code></pre></li>
</ul>
<p>【1】每个<data>元素指定一个URI和数据类型（MIME类型）。它有四个属性scheme、host、port、path对应于URI的每个部分：<br>scheme://host:port/path<br>scheme的值一般为”http”，host为包名，port为端口号，path为具体地址。如：<a href="http://com.test.project:200/folder/etc" target="_blank" rel="external">http://com.test.project:200/folder/etc</a><br>其中host和port合起来构成URI的凭据(authority)，如果host没有指定，则port也会被忽略<br>要让authority有意义，scheme也必须要指定。要让path有意义，scheme+authority也必须要指定</data></p>
<p>【2】mimeType（指定数据类型），若mimeType为’Image’，则会从content Provider的指定地址中获取image类型的数据。还有’video’啥的，若设置为video/mp4，则表示在指定地址中获取mp4格式的video文件</p>
<p>【3】而pathPattern和PathPrefix主要是为了格式化path所使用的</p>
<h3 id="5_u3001_u7B2C_u56DB_u5C42_28meta-data_29"><a href="#5_u3001_u7B2C_u56DB_u5C42_28meta-data_29" class="headerlink" title="5、第四层(meta-data)"></a>5、第四层(meta-data)</h3><pre><code>&lt;meta-data android:name=&quot;string&quot;
    android:resource=&quot;resource specification&quot;
    android:value=&quot;string&quot;/&gt;
</code></pre><p>这是该元素的基本结构.可以包含在<activity> <activity-alias> <service> <receiver>四个元素中。</receiver></service></activity-alias></activity></p>
<ul>
<li>android:name（解释：元数据项的名字，为了保证这个名字是唯一的，采用java风格的命名规范，如com.woody.project.fried)</li>
<li>android:resource(解释：资源的一个引用，指定给这个项的值是该资源的id。该id可以通过方法Bundle.getInt()来从meta-data中找到。)</li>
<li>android:value(解释：指定给这一项的值。可以作为值来指定的数据类型并且组件用来找回那些值的Bundle方法：[getString],[getInt],[getFloat],[getString],[getBoolean])</li>
</ul>
<h3 id="6_u3001_u7B2C_u4E09_u5C42_28activity-alias_29_u5C5E_u6027"><a href="#6_u3001_u7B2C_u4E09_u5C42_28activity-alias_29_u5C5E_u6027" class="headerlink" title="6、第三层(activity-alias)属性"></a>6、第三层(activity-alias)属性</h3><pre><code>&lt;activity-alias android:enabled=[&quot;true&quot; | &quot;false&quot;]
    android:exported=[&quot;true&quot; | &quot;false&quot;]
    android:icon=&quot;drawable resource&quot;
    android:label=&quot;string resource&quot;
    android:name=&quot;string&quot;
    android:permission=&quot;string&quot;
    android:targetActivity=&quot;string&quot;&gt;
    &lt;intent-filter/&gt;     
    &lt;meta-data/&gt;
&lt;/activity-alias&gt;
</code></pre><p><activity-alias>是为activity创建快捷方式的，如下实例：</activity-alias></p>
<pre><code>&lt;activity android:name=&quot;.shortcut&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
&lt;activity-alias android:name=&quot;.CreateShortcuts&quot; 
    android:targetActivity=&quot;.shortcut&quot; 
    android:label=&quot;@string/shortcut&quot;&gt;
    &lt;intent-filter&gt;
    &lt;action android:name=&quot;android.intent.action.CREATE_SHORTCUT&quot; /&gt;
    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity-alias&gt;
</code></pre><p>其中android.targetActivity是指向对应快捷方式的activity,如上述的shortcut(此Activity名)<br>android:label是指快捷方式的名称，而快捷方式的图标默认是给定的application图标</p>
<h3 id="7_u3001_u7B2C_u4E09_u5C42_28service_29"><a href="#7_u3001_u7B2C_u4E09_u5C42_28service_29" class="headerlink" title="7、第三层(service)"></a>7、第三层(service)</h3><p>【1】service与activity同级，与activity不同的是，它不能自己启动的，运行在后台的程序，如果我们退出应用时，Service进程并没有结束，它仍然在后台运行。比如听音乐，网络下载数据等，都是由service运行的</p>
<p>【2】service生命周期：Service只继承了onCreate(),onStart(),onDestroy()三个方法，第一次启动 Service时，先后调用了onCreate(),onStart()这两个方法，当停止Service时，则执行onDestroy()方法，如果 Service已经启动了，当我们再次启动Service时，不会在执行onCreate()方法，而是直接执行onStart()方法</p>
<p>【3】service与activity间的通信<br>Service后端的数据最终还是要呈现在前端Activity之上的，因为启动Service时，系统会重新开启一个新的进程，这就涉及到不同进程间通信的问题了(AIDL)，Activity与service间的通信主要用IBinder负责。</p>
<p>【4】<br>    <service android:enabled="["true"" |="" "false"]="" android:exported[="true" android:icon="drawable resource" android:label="string resource" android:name="string" android:permission="string" android:process="string"><br>    </service><br>service标签内的属性之前已有描述，在此不重复了～</p>
<h3 id="8_u3001_u7B2C_u4E09_u5C42_28receiver_29"><a href="#8_u3001_u7B2C_u4E09_u5C42_28receiver_29" class="headerlink" title="8、第三层(receiver)"></a>8、第三层(receiver)</h3><p>receiver的属性与service一样，这里就不显示了<br>BroadcastReceiver：用于发送广播，broadcast是在应用程序之间传输信息的一种机制，而BroadcastReceiver是对发送出来的 Broadcast进行过滤接受并响应的一类组件，具体参照<a href="http://kevin2562.javaeye.com/blog/686787" target="_blank" rel="external">http://kevin2562.javaeye.com/blog/686787</a></p>
<h3 id="9_u3001_u7B2C_u4E09_u5C42_28provider_29_u5C5E_u6027"><a href="#9_u3001_u7B2C_u4E09_u5C42_28provider_29_u5C5E_u6027" class="headerlink" title="9、第三层(provider)属性"></a>9、第三层(provider)属性</h3><pre><code>&lt;provider android:authorities=&quot;list&quot;
      android:enabled=[&quot;true&quot; | &quot;false&quot;]
      android:exported=[&quot;true&quot; | &quot;false&quot;]
      android:grantUriPermissions=[&quot;true&quot; | &quot;false&quot;]
      android:icon=&quot;drawable resource&quot;
      android:initOrder=&quot;integer&quot;
      android:label=&quot;string resource&quot;
      android:multiprocess=[&quot;true&quot; | &quot;false&quot;]
      android:name=&quot;string&quot;
      android:permission=&quot;string&quot;
      android:process=&quot;string&quot;
      android:readPermission=&quot;string&quot;
      android:syncable=[&quot;true&quot; | &quot;false&quot;]
      android:writePermission=&quot;string&quot;&gt;
    &lt;grant-uri-permission/&gt;
    &lt;meta-data/&gt;
&lt;/provider&gt;
</code></pre><p>contentProvider(数据存储)<br>【1】android:authorities：标识这个ContentProvider，调用者可以根据这个标识来找到它</p>
<p>【2】android:grantUriPermission：对某个URI授予的权限</p>
<p>【3】android:initOrder</p>
<h3 id="10_u3001_u7B2C_u4E09_u5C42uses-library"><a href="#10_u3001_u7B2C_u4E09_u5C42uses-library" class="headerlink" title="10、第三层uses-library"></a>10、第三层<code>uses-library</code></h3><p>用户库，可自定义。所有android的包都可以引用</p>
<h3 id="11_u3001_u7B2C_u4E00_u5C42_supports-screens"><a href="#11_u3001_u7B2C_u4E00_u5C42_supports-screens" class="headerlink" title="11、第一层 supports-screens"></a>11、第一层 <code>supports-screens</code></h3><pre><code>&lt;supports-screens  android:smallScreens=[&quot;true&quot; | &quot;false&quot;] 
    android:normalScreens=[&quot;true&quot; | &quot;false&quot;] 
    android:largeScreens=[&quot;true&quot; | &quot;false&quot;] 
    android:anyDensity=[&quot;true&quot; | &quot;false&quot;] /&gt;
</code></pre><p>这是在android1.6以后的新特性，支持多屏幕机制<br>各属性含义：这四个属性，是否支持大屏，是否支持中屏，是否支持小屏，是否支持多种不同密度</p>
<h3 id="12_u3001_u7B2C_u4E8C_u5C42uses-configuration_u4E0Euses-feature_u6027_u80FD_u90FD_u5DEE_u4E0D_u591A"><a href="#12_u3001_u7B2C_u4E8C_u5C42uses-configuration_u4E0Euses-feature_u6027_u80FD_u90FD_u5DEE_u4E0D_u591A" class="headerlink" title="12、第二层uses-configuration与uses-feature性能都差不多"></a>12、第二层<code>uses-configuration</code>与<code>uses-feature</code>性能都差不多</h3><pre><code> &lt;uses-configuration  android:reqFiveWayNav=[&quot;true&quot; | &quot;false&quot;] 
        android:reqHardKeyboard=[&quot;true&quot; | &quot;false&quot;]
        android:reqKeyboardType=[&quot;undefined&quot; | &quot;nokeys&quot; | &quot;qwerty&quot; |   &quot;twelvekey&quot;]
        android:reqNavigation=[&quot;undefined&quot; | &quot;nonav&quot; | &quot;dpad&quot; |  &quot;trackball&quot; | &quot;wheel&quot;]
        android:reqTouchScreen=[&quot;undefined&quot; | &quot;notouch&quot; | &quot;stylus&quot; | &quot;finger&quot;] /&gt;
&lt;uses-feature android:glEsVersion=&quot;integer&quot;
          android:name=&quot;string&quot;
          android:required=[&quot;true&quot; | &quot;false&quot;] /&gt;
</code></pre><p>这两者都是在描述应用所需要的硬件和软件特性，以便防止应用在没有这些特性的设备上安装。</p>
<p>###13、第二层<code>uses-sdk</code> </p>
<pre><code>&lt;uses-sdk android:minSdkVersion=&quot;integer&quot;
     android:targetSdkVersion=&quot;integer&quot;
     android:maxSdkVersion=&quot;integer&quot;/&gt;
</code></pre><p>描述应用所需的api level，就是版本，目前是android 2.2 = 8，android2.1 = 7，android1.6 = 4，android1.5=3<br>在此属性中可以指定支持的最小版本，目标版本以及最大版本</p>
<h3 id="14_u3001_u7B2C_u4E8C_u5C42_instrumentation"><a href="#14_u3001_u7B2C_u4E8C_u5C42_instrumentation" class="headerlink" title="14、第二层 instrumentation"></a>14、第二层 instrumentation</h3><pre><code>&lt;instrumentation android:functionalTest=[&quot;true&quot; | &quot;false&quot;]
       android:handleProfiling=[&quot;true&quot; | &quot;false&quot;]
       android:icon=&quot;drawable resource&quot;
       android:label=&quot;string resource&quot;
       android:name=&quot;string&quot;
       android:targetPackage=&quot;string&quot;/&gt;
</code></pre><p>定义一些用于探测和分析应用性能等等相关的类，可以监控程序。在各个应用程序的组件之前instrumentation类被实例化<br>android:functionalTest(解释：instrumentation类是否能运行一个功能测试，默认为false)</p>
<h3 id="15_u3001_26lt_3Bpermission_26gt_3B_u3001_26lt_3Buses-permission_26gt_3B_u3001_26lt_3Bpermission-tree_/_26gt_3B_u3001_26lt_3Bpermission-group_/_26gt_3B_u533A_u522B_uFF5E"><a href="#15_u3001_26lt_3Bpermission_26gt_3B_u3001_26lt_3Buses-permission_26gt_3B_u3001_26lt_3Bpermission-tree_/_26gt_3B_u3001_26lt_3Bpermission-group_/_26gt_3B_u533A_u522B_uFF5E" class="headerlink" title="15、&lt;permission&gt;、&lt;uses-permission&gt;、&lt;permission-tree /&gt;、&lt;permission-group /&gt;区别～"></a>15、<code>&lt;permission&gt;、&lt;uses-permission&gt;、&lt;permission-tree /&gt;</code>、<code>&lt;permission-group /&gt;</code>区别～</h3><p>最常用的当属<code>&lt;uses-permission&gt;</code>，当我们需要获取某个权限的时候就必须在我们的manifest文件中声明，此<code>&lt;uses-permission&gt;</code>与<code>&lt;application&gt;</code>同级，具体权限列表请看此处<br>通常情况下我们不需要为自己的应用程序声明某个权限，除非你提供了供其他应用程序调用的代码或者数据。这个时候你才需要使用<code>&lt;permission&gt;</code> 这个标签。很显然这个标签可以让我们声明自己的权限。比如：<br>    <permission android:name="com.teleca.project.MY_SECURITY" .=""><br>那么在activity中就可以声明该自定义权限了，如：<br>    <application .=""><br>        <activity android:name="XXX" .=""><br>        android:permission=”com.teleca.project.MY_SECURITY”&gt; </activity><br>    </application><br>当然自己声明的permission也不能随意的使用，还是需要使用<uses-permission>来声明你需要该权限<br><code>&lt;permission-group&gt;</code>就是声明一个标签，该标签代表了一组permissions，而<code>&lt;permission-tree&gt;</code>是为一组permissions声明了一个namespace。</uses-permission></permission></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Bigtiger
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>