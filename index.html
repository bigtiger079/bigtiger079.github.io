<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Bigtiger&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Bigtiger's blog">
<meta property="og:url" content="http://www.bigtiger079.com/index.html">
<meta property="og:site_name" content="Bigtiger's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bigtiger's blog">
<meta name="twitter:description">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xlrpi.com1.z0.glb.clouddn.com/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Bigtiger</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/categories">分类</a></li>
				        
							<li><a href="/tags">标签</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="mail" target="_blank" href="/bigtiger079@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/Cpp基础/" style="font-size: 10px;">Cpp基础</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JNI/" style="font-size: 10px;">JNI</a> <a href="/tags/RecyclerView/" style="font-size: 16.67px;">RecyclerView</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/linux/" style="font-size: 20px;">linux</a> <a href="/tags/线性表/" style="font-size: 13.33px;">线性表</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Bigtiger</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xlrpi.com1.z0.glb.clouddn.com/avatar.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Bigtiger</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories">分类</a></li>
		        
					<li><a href="/tags">标签</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="mail" target="_blank" href="/bigtiger079@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-Android嵌套滑动机制学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/08/Android嵌套滑动机制学习/" class="article-date">
  	<time datetime="2015-12-08T03:32:42.000Z" itemprop="datePublished">2015-12-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/08/Android嵌套滑动机制学习/">Android嵌套滑动机制学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u6ED1_u52A8_u5D4C_u5957_u673A_u5236_u4E2D_u51E0_u4E2A_u91CD_u8981_u7684_u7C7B"><a href="#u6ED1_u52A8_u5D4C_u5957_u673A_u5236_u4E2D_u51E0_u4E2A_u91CD_u8981_u7684_u7C7B" class="headerlink" title="滑动嵌套机制中几个重要的类"></a>滑动嵌套机制中几个重要的类</h2><p>NestedScrollingChild<br>NestedScrollingParent<br>NestedScrollingChildHelper<br>NestedScrollingParentHelper</p>
<p>以上四个类都在support-v4包中提供，Lollipop的View默认实现了几种方法。</p>
<h3 id="NestedScrollingChild"><a href="#NestedScrollingChild" class="headerlink" title="NestedScrollingChild"></a>NestedScrollingChild</h3><p>该接口是用于给希望和支持联合操作的父View进行交互的子View来实现的, 实现该接口的View还应该创建一个用final修饰的NestedScrollingChildHelper的一个实例, 并把View实现的方法代理给NestedScrollingChildHelper中相名的方法.</p>
<p>接口中的方法说明:</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置View是否可以嵌套滑动</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setNestedScrollingEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></span>;</span><br><span class="line"><span class="comment">//跟上面的方法配对的, 获取当前View是否可以嵌套滑动</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isNestedScrollingEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//沿着给定的轴线开始嵌套滑动</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="keyword">int</span> axes)</span></span>;</span><br><span class="line"><span class="comment">//停止滑动</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">stopNestedScroll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasNestedScrollingParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在滚动过程中分发滚动信息Dispatch one step of a nested scroll in progress.</span><br><span class="line">* @param dxConsumed 在这一步滚动过程中已经消耗的水平滚动距离(像素)</span><br><span class="line">* @param dyConsumed 在这一步滚动过程中已经消耗的垂直滚动距离(像素)</span><br><span class="line">* @param dxUnconsumed 当前视图在这一步滚动过程中还未消耗的水平滚动距离(像素)</span><br><span class="line">* @param dyUnconsumed 当前视图在这一步滚动过程中还未消耗的垂直滚动距离(像素)</span><br><span class="line">* @param offsetInWindow 可选类型. </span><br><span class="line">* @return 如果父view接受了它的滚动参数，进行了部分消费，则这个函数返回true，否则为false</span><br><span class="line">* 这个函数一般在子view处理scroll后调用</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="keyword">int</span>[] offsetInWindow)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">在子View的onInterceptTouchEvent或者onTouch中(一般在MontionEvent.ACTION_MOVE事件里)，调用该方法通知父View滑动的距离。</span><br><span class="line">该方法的第三第四个参数返回父view消费掉的scroll长度和子View的窗体偏移量。如果这个scroll没有被消费完，</span><br><span class="line">则子view进行处理剩下的一些距离，由于窗体进行了移动，如果你记录了手指最后的位置，需要根据第四个参数offsetInWindow计算偏移量，</span><br><span class="line">才能保证下一次的touch事件的计算是正确的。</span><br><span class="line">如果父view接受了它的滚动参数，进行了部分消费，则这个函数返回true，否则为false。</span><br><span class="line">这个函数一般在子view处理scroll前调用。</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>[] offsetInWindow)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedFling</span><span class="params">(<span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY, <span class="keyword">boolean</span> consumed)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedPreFling</span><span class="params">(<span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>dispatchNestedPreScroll中的consumed参数:<br>它是一个int型的数组，长度为2，第一个元素是父view消费的x方向的滚动距离；第二个元素是父view消费的y方向的滚动距离，如果这两个值不为0，则子view需要对滚动的量进行一些修正。正因为有了这个参数，使得我们处理滚动事件的时候，思路更加清晰，不会像以前一样被一堆的滚动参数搞混。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-认识-JNI开发" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/26/认识-JNI开发/" class="article-date">
  	<time datetime="2015-10-26T07:00:09.000Z" itemprop="datePublished">2015-10-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/26/认识-JNI开发/">认识 JNI开发</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JNI - Java Native Interface;</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNI/">JNI</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/笔记/">笔记</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/10/26/认识-JNI开发/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-linux网络编程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/25/linux网络编程/" class="article-date">
  	<time datetime="2015-10-25T08:56:04.000Z" itemprop="datePublished">2015-10-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/25/linux网络编程/">linux网络编程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TCP/IP_u4E0E_u5957_u63A5_u5B57"><a href="#TCP/IP_u4E0E_u5957_u63A5_u5B57" class="headerlink" title="TCP/IP与套接字"></a>TCP/IP与套接字</h2><p>套接字是通信端点的抽象</p>
<p>与文件描述符一样,套接字需要用套接字描述符</p>
<p>套接字在Linux上也是通过文件实现的,所以传统的write和read同样适用于套接字</p>
<p>当服务器和应用程序需要和其他进程通信的时候就会使用套接字</p>
<p>一对对接的套接字接口构成了进程间交流数据的一个通道</p>
<p>这些进程可能是windows或者linux以及IOS,android都可以互相通信</p>
<p>通信域用来说明套接字接口通信协议的语义</p>
<p>每个域都定义了一套协议、控制和解释名字规则，以及套接口的地址格式</p>
<p>对于internet域来说,套接字地址格式是一个IP地址和端口号</p>
<p>internet域套接字用于联网通信,他们可以用在几乎任何支持TCP/IP的网络通信程序上</p>
<h2 id="TCP_u901A_u4FE1"><a href="#TCP_u901A_u4FE1" class="headerlink" title="TCP通信"></a>TCP通信</h2><p>一个程序使用套接字需要执行4个步骤</p>
<ul>
<li>分配套接口和初始化</li>
<li>连接</li>
<li>发送或接收数据</li>
<li>关闭套接字</li>
</ul>
<p>涉及到的调用包括socket、bind、listen、connect、accept、recv、send</p>
<h3 id="u5206_u914D_u5957_u63A5_u53E3_u548C_u521D_u59CB_u5316"><a href="#u5206_u914D_u5957_u63A5_u53E3_u548C_u521D_u59CB_u5316" class="headerlink" title="分配套接口和初始化"></a>分配套接口和初始化</h3><blockquote>
<p>我们需要第一件工作就是分配套接口<br>套接口可以看做是文件描述符<br>不论是server端还是client端,第一步都是一样的</p>
</blockquote>
<p>每个套接口都是一个通信的通道<br>两个进程通过套接口建立连接后就可以发送和接收数据了</p>
<pre><code># include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int socket(int domain, int type, int protocol);
</code></pre><p>系统调用socket带有一下参数</p>
<ul>
<li>int domain</li>
<li>int type</li>
<li>int protocol (这个值一般取0)</li>
<li>成功返回套接字描述符, 失败返回-1, 并设置errno</li>
</ul>
<h4 id="domian_u8BF4_u660E"><a href="#domian_u8BF4_u660E" class="headerlink" title="domian说明"></a>domian说明</h4><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AF_UNIX</td>
<td>UNIX内部使用</td>
</tr>
<tr>
<td>AF_INET</td>
<td>TCP/IP协议</td>
</tr>
<tr>
<td>AF_ISO</td>
<td>国际标准组织协议</td>
</tr>
<tr>
<td>AF_NS</td>
<td>Xerox网络协议</td>
</tr>
</tbody>
</table>
<h4 id="type_u8BF4_u660E"><a href="#type_u8BF4_u660E" class="headerlink" title="type说明"></a>type说明</h4><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SOCK_STREAM</td>
<td>使用TCP可靠连接</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>使用UDP不可靠连接</td>
</tr>
</tbody>
</table>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><pre><code>int bind(int sockfd, const struct sockaddr *my_addr, socklen_t addrlen);
</code></pre><blockquote>
<p>bind将进程和一个套接口联系起来,bind通常用于服务器进程为接入客户连接建立一个套接口<br>参数sockfd是函数socket调用返回的套接口值<br>参数my_addr是函数结构sockaddr的地址<br>参数addrlen设置my_addr能容纳的最大字节数<br>成功返回0,失败返回-1, 并设置errno</p>
</blockquote>
<h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><pre><code>int listen(int sockfd, int backlog);
</code></pre><blockquote>
<p>创建了套接口并且使用bind将它和一个进程关联起来以后,服务端就需要调用listen来监听指定端口的客户端连接<br>参数sockfd是调用socket返回的套接口描述符<br>参数backlog设置接入队列的大小, 通常把这个值设置的足够大就可以了<br>成功返回0,失败返回-1,并设置errno</p>
</blockquote>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><pre><code>int accept(int sockfd, struct sockaddr, *addr, socklen_t *addrlen);
</code></pre><blockquote>
<p>当有客户端连接到服务器,它们就会排入队列,直到服务端准备好处理它们为止,accept会返回一个新的套接口,同时原来的套接口继续listen指定端口号<br>参数sockfd是调用socket返回的套接口描述符<br>参数addr指向结构sockaddr地址<br>参数addrlen设置了addr能容纳的最大字节数<br>成功返回新的套接字,失败返回-1,并设置errno</p>
</blockquote>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><pre><code>int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);
</code></pre><blockquote>
<p>客户端调用connect与服务端进行连接<br>参数sockfd是调用socket返回的套接口描述符<br>参数addr指向结构sockaddr地址<br>参数addrlen设置了addr能容纳的最大字节数<br>成功返回0,失败返回-1, 并设置errno</p>
</blockquote>
<p>客户端和服务端建立了连接就可以在客户端和服务端之间传输数据了, 需要两个系统调用</p>
<ul>
<li>send—发送数据</li>
<li>recv—接收数据</li>
</ul>
<p>一个套接口既可以发送数据,也可以接受数据</p>
<h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><pre><code>ssize_t send(int s, const void *buf, size_t len, int flags);
</code></pre><blockquote>
<p>send函数用来发送数据<br>参数s是已经建立连接的套接口<br>参数buf是发送数据内存buffer地址指针<br>参数len指明buffer的大小,单位字节<br>参数flags一般为0<br>成功返回发送的字节数,失败返回-1,并设置errno</p>
</blockquote>
<h3 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h3><pre><code>ssize_t recv(int s, const void *buf, size_t len, int flags);
</code></pre><blockquote>
<p>recv函数用来接收数据<br>参数s是已经建立连接的套接口<br>参数buf是接收数据内存buffer地址指针<br>参数len指明buffer的大小,单位字节<br>参数flags一般为0<br>成功返回发送的字节数,失败返回-1,并设置errno</p>
</blockquote>
<p>当用完套接口以后,就该释放套接口所占用的资源了,可通过close来关闭</p>
<blockquote>
<p>当试图向一个已经关闭的套接口写或者读数据就会出错</p>
</blockquote>
<h3 id="u8BBE_u7F6E_u5957_u63A5_u53E3"><a href="#u8BBE_u7F6E_u5957_u63A5_u53E3" class="headerlink" title="设置套接口"></a>设置套接口</h3><pre><code>int setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen);
</code></pre><blockquote>
<p>setsockopt函数设置套接口<br>常见的用法为:</p>
</blockquote>
<pre><code>int on = 1;
setsockopt(st, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on));
</code></pre><blockquote>
<p>由于TCP套接字状态TIME_WAIT引起该套接字关闭后约保留2到4分钟,在此期间bind绑定该端口会失败<br>SO_REUSEADDR指示系统地址可重用 </p>
</blockquote>
<h3 id="u793A_u4F8B_u4EE3_u7801"><a href="#u793A_u4F8B_u4EE3_u7801" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="u5BA2_u6237_u7AEF"><a href="#u5BA2_u6237_u7AEF" class="headerlink" title="客户端"></a>客户端</h4><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;pthread.h&gt;

void *recvsocket(void *arg)//接收client端socket数据的线程
{
    int st = *(int *)arg;
    char s[1024];

    while(1)
    {
        memset(s, 0, sizeof(s));
        int rc = recv(st, s, sizeof(s), 0);
        if (rc &lt;= 0)//如果recv返回小于等于0，代表socket已经关闭或者出错了
            break;
        printf(&quot;%s\n&quot;, s);

    }
    return NULL;
}

void *sendsocket(void *arg)//向client端socket发送数据的线程
{
    int st = *(int *)arg;
    char s[1024];

    while(1)
    {
        memset(s, 0, sizeof(s));
        read(STDIN_FILENO, s, sizeof(s));//从键盘读取用户输入信息
        send(st, s, strlen(s), 0);
    }
    return NULL;
}

int main(int arg, char *args[])
{
    if (arg &lt; 3)
        return -1;

    int port = atoi(args[2]);
    int st = socket(AF_INET, SOCK_STREAM, 0); //初始化socket，

    struct sockaddr_in addr; //定义一个IP地址的结构
    memset(&amp;addr, 0, sizeof(addr));
    addr.sin_family = AF_INET; //设置结构地址类型为TCP/IP地址
    addr.sin_port = htons(port); //指定一个端口号：8080，htons:将short类型从host字节类型到net字节类型转化
    addr.sin_addr.s_addr = inet_addr(args[1]); //将字符串类型的IP地址转化为int，赋给addr结构成员.

    //调用connect连接到结构addr指定的IP地址和端口号
    if (connect(st, (struct sockaddr *) &amp;addr, sizeof(addr)) == -1)
    {
        printf(&quot;connect failed %s\n&quot;, strerror(errno));
        return EXIT_FAILURE;
    }

    pthread_t thrd1, thrd2;
    pthread_create(&amp;thrd1, NULL, recvsocket, &amp;st);
    pthread_create(&amp;thrd2, NULL, sendsocket, &amp;st);
    pthread_join(thrd1, NULL);
    //pthread_join(thrd2, NULL);
    close(st); //关闭socket
    return EXIT_SUCCESS;

}
</code></pre><h4 id="u670D_u52A1_u7AEF"><a href="#u670D_u52A1_u7AEF" class="headerlink" title="服务端"></a>服务端</h4><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;pthread.h&gt;


struct ps{
    int st;
    pthread_t *thr;
};

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

int status = 0;

void *recvsocket(void *arg)//接收client端socket数据的线程
{
    struct ps *p = (struct ps *)arg;
    int st = p-&gt;st;
    char s[1024];

    while(1)
    {
        memset(s, 0, sizeof(s));
        int rc = recv(st, s, sizeof(s), 0);
        if (rc &lt;= 0)//如果recv返回小于等于0，代表socket已经关闭或者出错了
            break;
        printf(&quot;%s\n&quot;, s);

    }
    pthread_mutex_lock(&amp;mutex);
    status = 0;
    pthread_mutex_unlock(&amp;mutex);
    pthread_cancel(*(p-&gt;thr));//被cancel掉的线程内部没有使用锁。
    return NULL;
}

void *sendsocket(void *arg)//向client端socket发送数据的线程
{
    int st = *(int *)arg;
    char s[1024];

    while(1)
    {
        memset(s, 0, sizeof(s));
        read(STDIN_FILENO, s, sizeof(s));//从键盘读取用户输入信息
        send(st, s, strlen(s), 0);
    }
    return NULL;
}




int main(int arg, char *args[])
{
    if (arg &lt; 2)
    {
        return -1;
    }

    int port = atoi(args[1]);
    int st = socket(AF_INET, SOCK_STREAM, 0);//初始化socket


    int on = 1;
    if (setsockopt(st, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) == -1)
    {
        printf(&quot;setsockopt failed %s\n&quot;, strerror(errno));
        return EXIT_FAILURE;
    }


    struct sockaddr_in addr;//定义一个IP地址结构
    memset(&amp;addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;//将addr结构的属性定位为TCP/IP地址
    addr.sin_port = htons(port);//将本地字节顺序转化为网络字节顺序。
    addr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY代表这个server上所有的地址

    //将IP与server程序绑定
    if (bind(st, (struct sockaddr *) &amp;addr, sizeof(addr)) == -1)
    {
        printf(&quot;bind failed %s\n&quot;, strerror(errno));
        return EXIT_FAILURE;
    }

    //server端开始listen，
    if (listen(st, 20) == -1)
    {
        printf(&quot;listen failed %s\n&quot;, strerror(errno));
        return EXIT_FAILURE;
    }
    int client_st = 0;//client端socket
    //socklen_t len = 0;
    struct sockaddr_in client_addr;//表示client端的IP地址
    //void *p = &amp;client_addr;

    pthread_t thrd1, thrd2;


    while (1)
    {
        memset(&amp;client_addr, 0, sizeof(client_addr));
        socklen_t len = sizeof(client_addr);
        //accept会阻塞，直到有客户端连接过来，accept返回client的socket描述符
        client_st = accept(st, (struct sockaddr *)&amp;client_addr , &amp;len);
        pthread_mutex_lock(&amp;mutex);//为全局变量加一个互斥锁，防止与线程函数同时读写变量的冲突
        status++;
        pthread_mutex_unlock(&amp;mutex);//解锁
        if (status &gt; 1)//代表这是第二个socket连接
        {
            close(client_st);
            continue;
        }

        if (client_st == -1)
        {
            printf(&quot;accept failed %s\n&quot;, strerror(errno));
            return EXIT_FAILURE;
        }

        printf(&quot;accept by %s\n&quot;, inet_ntoa(client_addr.sin_addr));
        struct ps ps1;
        ps1.st = client_st;
        ps1.thr = &amp;thrd2;
        pthread_create(&amp;thrd1, NULL, recvsocket, &amp;ps1);
        pthread_detach(thrd1);//设置线程为可分离
        pthread_create(&amp;thrd2, NULL, sendsocket, &amp;client_st);
        pthread_detach(thrd2);//设置线程为可分离
    }
    close(st);//关闭server端listen的socket
    return EXIT_SUCCESS;
}
</code></pre><h2 id="UDP_u901A_u4FE1"><a href="#UDP_u901A_u4FE1" class="headerlink" title="UDP通信"></a>UDP通信</h2><p><strong>UDP和TC的对比:</strong></p>
<ul>
<li>UDP处理的细节比TCP少</li>
<li>UDP不能保证消息被传送到目的地</li>
<li>UDP不能保证数据包的传递顺序</li>
<li>TCP处理UDP不处理的细节</li>
<li>TCP是面向连接的协议</li>
<li>UDP无连接协议</li>
<li>TCP保持一个连接</li>
<li>UDP只是把数据包发送出去而已</li>
</ul>
<p><strong>TCP的优点:</strong></p>
<ul>
<li>TCP提供以认可的方式显示的创建连接和终止连接</li>
<li>TCP保证可靠的,顺序的以及不会重复的数据传输</li>
<li>TCP处理流控制</li>
<li>TCP允许数据优先</li>
<li>如果数据没有传送到,TCP套接字会返回出错提示</li>
<li>TCP通过保持连接并将数据块分成更小的分片来处理大数据,而无需程序员编码处理</li>
</ul>
<p><strong>TCP的缺点:</strong></p>
<ul>
<li>TCP需要创建并保持一个连接, 给系统带来很大开销</li>
<li>TCP数据传输效率低</li>
</ul>
<p><strong>UDP的优点:</strong></p>
<ul>
<li>UDP不要求保持一个连接</li>
<li>UDP没有因接收方没有收到数据包重传而带来开销</li>
<li>设计UDP的目的是用于短应用和控制消息</li>
<li>在一个数据包接一个数据包基础上,UDP要求的网络带宽比TCP小</li>
</ul>
<p><strong>UDP的缺点:</strong></p>
<ul>
<li>程序员必须创建代码监测数据包的正确性,必要时重传</li>
<li>程序员必须把大数据包分片</li>
</ul>
<p>使用UDP与TCP所用的代码基本类似, 唯一的区别在于socket函数调用的时候的一个参数的不同</p>
<pre><code># include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int socket(int domain, int type, int protocol);
</code></pre><blockquote>
<p>参数type为SOCK_STREAM代表TCP, SOCK_DGRAM代表UDP<br>对于TCP和UDP都可以使用recvfrom函数,但recv只能TCP使用</p>
</blockquote>
<h3 id="u4F7F_u7528UDP_u53D1_u9001_u6570_u636E"><a href="#u4F7F_u7528UDP_u53D1_u9001_u6570_u636E" class="headerlink" title="使用UDP发送数据"></a>使用UDP发送数据</h3><pre><code>ssize_他sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);
</code></pre><blockquote>
<p>UDP不需要握手机制,也不需要确认另一个系统是否有服务端在listen</p>
</blockquote>
<h3 id="UDP_u793A_u4F8B_u4EE3_u7801"><a href="#UDP_u793A_u4F8B_u4EE3_u7801" class="headerlink" title="UDP示例代码"></a>UDP示例代码</h3><h4 id="u53D1_u9001_u7AEF"><a href="#u53D1_u9001_u7AEF" class="headerlink" title="发送端"></a>发送端</h4><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;pthread.h&gt;

int main(int arg, char *args[])
{
    if (arg &lt; 3)
        return -1;

    int st = socket(AF_INET, SOCK_DGRAM, 0);//建立socket的时候第二个参数值为SOCK_DGRAM
    if (st == -1)
    {
        printf(&quot;socket failed %s\n&quot;, strerror(errno));
        return 0;
    }

    int port = atoi(args[2]);


    int on = 1;
    if (setsockopt(st, SOL_SOCKET, SO_BROADCAST, &amp;on, sizeof(on)) == -1)//设置UDP socket可以发送广播消息
    {
        printf(&quot;setsockopt failed %s\n&quot;, strerror(errno));
        return EXIT_FAILURE;
    }



    struct sockaddr_in addr;
    memset(&amp;addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = inet_addr(args[1]);
    char buf[1024];
    while (1)
    {
        memset(buf, 0, sizeof(buf));
        read(STDIN_FILENO, buf, sizeof(buf));//读取用户键盘输入
        if (sendto(st, buf, strlen(buf), 0, (struct sockaddr *) &amp;addr,sizeof(addr)) == -1)//udp使用sendto发送消息
        {
            printf(&quot;sendto failed %s\n&quot;, strerror(errno));
            break;
        }
    }
    close(st);
    return EXIT_SUCCESS;
}
</code></pre><h4 id="u63A5_u6536_u7AEF"><a href="#u63A5_u6536_u7AEF" class="headerlink" title="接收端"></a>接收端</h4><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;pthread.h&gt;

int main(int arg, char *args[])
{
    if (arg &lt; 2)
        return -1;

    int st = socket(AF_INET, SOCK_DGRAM, 0);
    if (st == -1)
    {
        printf(&quot;socket failed %s\n&quot;, strerror(errno));
        return 0;
    }

    int port = atoi(args[1]);
    struct sockaddr_in addr;
    memset(&amp;addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    if (bind(st, (struct sockaddr *)&amp;addr, sizeof(addr)) == -1)//UDP接收数据，也需要绑定IP
    {
        printf(&quot;bind failed %s\n&quot;, strerror(errno));
        return -1;
    }
    char buf[1024];
    struct sockaddr_in client_addr;
    socklen_t len = sizeof(client_addr);
    while(1)
    {
        memset(&amp;client_addr, 0, sizeof(client_addr));
        memset(buf, 0, sizeof(buf));
        if(recvfrom(st, buf, sizeof(buf), 0,(struct sockaddr *)&amp;client_addr, &amp;len) == -1)
        {
            printf(&quot;recvfrom failed %s\n&quot;, strerror(errno));
            break;
        }
        else
        {

            printf(&quot;%s recv is %s\n&quot;, inet_ntoa(client_addr.sin_addr), buf);
        }
    }
    close(st);
    return 0;
}
</code></pre><h2 id="u975E_u963B_u585Esocket_u4E0Eepoll"><a href="#u975E_u963B_u585Esocket_u4E0Eepoll" class="headerlink" title="非阻塞socket与epoll"></a>非阻塞socket与epoll</h2><h3 id="u963B_u585Esocket"><a href="#u963B_u585Esocket" class="headerlink" title="阻塞socket"></a>阻塞socket</h3><ul>
<li>阻塞调用是指调用结果返回之前,当前线程会被挂起,函数只有在得到结果之后才会返回</li>
<li>对于文件操作read,fread函数调用会将线程阻塞</li>
<li>对于socket,accept与recv、recvfrom函数调用会将线程阻塞</li>
<li>为了避免整个线程被阻塞后挂起,所以在阻塞模式下,往往需要采用多线程技术</li>
<li>一个进程中可并发的线程总数是有限的,在处理大量客户端socket连接(比如上万个client socket),通过线程并发处理socket并不方便,效率也不高</li>
</ul>
<h3 id="u975E_u963B_u585Esocket"><a href="#u975E_u963B_u585Esocket" class="headerlink" title="非阻塞socket"></a>非阻塞socket</h3><ul>
<li>非阻塞调用是指调用立刻返回</li>
<li>在非阻塞模式下,accept与recv、recvfrom函数调用会立刻返回</li>
<li>在nonblocking状态下调用accept函数,如果没有客户端socket连接请求,那么accept函数返回-1,同时errno值为EAGAIN或者EWOULDBLOCK,这两个宏定义都为整数11</li>
<li>在nonblocking状态下调用recv、recvfrom函数，如果没有数据，函数返回-1，同时errno值为11；如果socket已经关闭，函数返回0</li>
<li>在nonblocking状态下对一个已经关闭的socket调用send函数，将引发SIGPIPE信号，进程必须捕捉这个信号，因为SIGPIPE系统默认的处理方式是关闭进程</li>
</ul>
<h3 id="fcntl_u51FD_u6570_u8C03_u7528"><a href="#fcntl_u51FD_u6570_u8C03_u7528" class="headerlink" title="fcntl函数调用"></a>fcntl函数调用</h3><p>fcntl函数可以将文件或者socket描述符设置为阻塞或者非阻塞状态</p>
<pre><code>int fcntl(int fd, int cmd, .../*arg*/);
</code></pre><blockquote>
<p>参数fd为要设置的文件描述符或者socket<br>参数cmd,F_GETFL为得到目前状态,F_SETFL为设置状态<br>宏定义O_NOBLOCK代表非阻塞,0代表阻塞<br>返回值为描述符当前状态    </p>
</blockquote>
<h4 id="fcntl_u51FD_u6570_u8C03_u7528_u8BBE_u7F6E_u975E_u963B_u585E_u793A_u4F8B"><a href="#fcntl_u51FD_u6570_u8C03_u7528_u8BBE_u7F6E_u975E_u963B_u585E_u793A_u4F8B" class="headerlink" title="fcntl函数调用设置非阻塞示例"></a>fcntl函数调用设置非阻塞示例</h4><pre><code>int opts = fcntl(st, F_GETFL);
if(opts &lt; 0)
{
    printf(&quot;fcntl failed s%\n&quot;, strerror(errno));
}
opts = opts | O_NONBLOCK;
if(fcntl(st, F_SETEL, opts) &lt;0)
{
    printf(&quot;fcntl failed %s\n&quot;, strerror(errno));
}
</code></pre><h3 id="epoll_u7684_u7CFB_u7EDF_u8C03_u7528_u51FD_u6570"><a href="#epoll_u7684_u7CFB_u7EDF_u8C03_u7528_u51FD_u6570" class="headerlink" title="epoll的系统调用函数"></a>epoll的系统调用函数</h3><ul>
<li><p>epoll_create<br>epoll_create用来创建一个epoll文件描述符</p>
</li>
<li><p>epoll_ctl<br>epoll_ctl用来添加/修改/删除需要侦听的文件描述符及其事件</p>
</li>
<li><p>epoll_wait<br>epoll_wait接收发生在被侦听的描述符上的,用户感兴趣的IO事件</p>
</li>
<li><p>epoll文件描述符用完后,需要colse关闭</p>
</li>
<li>每次添加/修改/删除文件描述符都需要调用epoll_ctl,所以要尽量少调用epoll_ctl</li>
</ul>
<h4 id="epoll_create"><a href="#epoll_create" class="headerlink" title="epoll_create"></a>epoll_create</h4><pre><code>int epoll_create(int size);
</code></pre><blockquote>
<p>epoll_create创建一个epoll的句柄<br>参数size指定epoll所支持的最大句柄数<br>函数会返回一个新的epoll句柄,之后的所有操作将通过这个句柄来进行操作<br>在用完句柄之后,需要用<code>close()</code>来关闭这个创建出来的epoll句柄</p>
</blockquote>
<h4 id="epoll_ctl"><a href="#epoll_ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><pre><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
</code></pre><blockquote>
<p>参数epfd是epoll_create()返回值<br>op表示动作,用三个宏来表示:</p>
<ul>
<li>EPOLL_CTL_ADD:注册新的fd到epfd中;</li>
<li>EPOLL_CTL_MOD:修改已经注册的fd的监听事件</li>
<li>EPOLL_CTL_DEL:从epfd中删除一个fd<br>参数fd是需要监听的socket描述符<br>参数event通知内核需要监听什么事件</li>
</ul>
</blockquote>
<h4 id="struct_epoll_event_u7ED3_u6784_u5982_u4E0B_3A"><a href="#struct_epoll_event_u7ED3_u6784_u5982_u4E0B_3A" class="headerlink" title="struct epoll_event结构如下:"></a>struct epoll_event结构如下:</h4><pre><code>typedef union epoll_data{
    void *ptr;
    int fd;
    __uint32_t u32;
    __unit64_t u64;
}epoll_data_t;

struct epoll_event{
    __unit32_t events;/*Epoll events*/
    epoll_data_t data; /*User data variable*/
};
</code></pre><h4 id="events_u5B9A_u4E49_3A"><a href="#events_u5B9A_u4E49_3A" class="headerlink" title="events定义:"></a>events定义:</h4><ul>
<li>EPOLLIN:表示对应的文件描述符可以读(包括对端SOCKET正常关闭)</li>
<li>EPOLLOUT:表示对应的文件描述符可以写</li>
<li>EPOLLPRI:表示对应的文件描述符有紧急的数据可读(这里应该表示有带外数据到来)</li>
<li>EPOLLERR:表示对应的文件描述符发生错误</li>
<li>EPOLLHUP:表示对应的文件描述符被挂断</li>
<li>EPOLLET:将EPOLL设为边缘触发(Edge Triggered)模式,这是相对于水平触发(Level Triggered)来说的</li>
<li>EPOLLONESHOT:只监听一次事件,当监听完这次事件后,如果还需要继续监听这个socket的话,需要再次把这个socket加入到EPOLL队列里</li>
</ul>
<h4 id="epoll_wait"><a href="#epoll_wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><pre><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
</code></pre><blockquote>
<p>参数epfd是<code>epoll_create()</code>的返回值<br>参数events是一个epoll_events*的指针,当epoll_wait这个函数操作成功后,eploo_events里面讲储存所有的读写事件<br>参数maxevents是当前需要监听的所有socket句柄数<br>参数timeout是epoll_wait的超时,为0的时候,表示马上返回,为-1的时候表示一直等下去,知道有事件范围,正整数表示等这么长时间<br>一般如果网络主循环是单独的线程的话,可以用-1来等,这样可以保证一些效率,如果是和主逻辑在同一个线程的话,则可以用0来保证主循环的效率</p>
</blockquote>
<p>epoll_wait范围之后应该是一个循环,遍历所有的事件</p>
<h4 id="epoll_u793A_u4F8B"><a href="#epoll_u793A_u4F8B" class="headerlink" title="epoll示例"></a>epoll示例</h4><pre><code>ssize_t socket_recv(int st)
{
    char buf[1024];
    memset(buf, 0, sizeof(buf));
    ssize_t rc = recv(st, buf, sizeof(buf), 0);
    if( rc &lt;= 0)
    {
        printf(&quot;recv %s\n&quot;, buf);
        send(st, buf,rc,0);
    }
    return rc;
}

int socket_accept(int listen_st)
{
    struct sockaddr_in client_addr;
    socklen_t len = sizeof(client_addr);
    memset(&amp;client_addr, 0, sizeof(client_addr));
    int client_st = accept(listen_st, (struct sockaddr *)&amp;client_addr, &amp;len);
    if(client_st &lt; 0)
    {
        printf(&quot;accept failed %s\n&quot;, strerror(errno));
    }
    else
    {
        printf(&quot;accept by %s\n&quot;, inet_ntoa(client_addr.sin_addr));
    }
    return client_st;
}

int socket_create(int port)
{
    int st = socket(AF_INET, SOCKET_STREAM, 0);
    int on = 1;
    if(setsocketopt(st, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) == -1)
    {
        printf(&quot;setsocketopt failed %s&quot;, strerror(errno));
        return 0;
    }
    struct sockaddr_in addr;
    memset(&amp;addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.addr = htonl(INADDR_ANY);
    if(bind(st, (struct sockaddr *)&amp;addr, sizeof(addr)) == -1)
    {
        printf(&quot;bind port %d failed %s&quot;,port, strerror(errno));
        return 0;
    }
    if(listen(st, 300) == -1)
    {
        printf(&quot;listen failed %s&quot;, strerror(errno));
        return0;
    }
    return st;
}

int main(int args, char *agrs[])
{
    if(args&lt;2)
        return -1;
    int iport = atoi(arg[1]);
    int listen_st = socket_create(iport);
    if(listen_st ==0)
        return -1;

    struct epoll_event ev, events[100]; //声明epoll_event结构体的变量,ev用于注册事件,数组用户回传要处理的事件
    int epfd = epoll_create(100);    //生成用于处理accept的epoll专用的文件描述符
    setnonblocking(listen_st);//把socket设置为非阻塞方式
    ev.data.fdd = listen_st; //设置要处理的事件相关的文件描述符
    ev.events = EPOLLIN | EPOLLERR | EPOLLHUP; //设置要处理的事件类型
    epoll_ctl(epfd, EPOLL_CTL_ADD, listen_st, &amp;ev);

    int st = 0;
    while(0)
    {
        int ndfs = epoll_wait(epfd, events, 100, -1);//等待epoll事件发生
        if(ndfs == -1)
        {
            printf(&quot;epoll_wait failed %s&quot;, strerror(errno));
            break;
        }
        int i;
        for(i = 0; i &lt;nfds ;i++)
        {
            if(events[i].data.fd &lt;0)
                continue;
            if(events[i].data.fd == litsten_st)//监听到一个socket用户连接到了绑定的SOCKET端口,建立新的连接
            {
                st = socket_accept(listen_st);
                if(st &gt;=0)
                {
                    setnonblocking(st);
                    ev.data.fd = st;
                    ev.events = EPOLLIN|EPOLLERR|EPOLLHUP;//设置要处理的事件类型
                    epoll_ctl(epfd, EPOLL_CTL_ADD, st, &amp;ev);
                    continue;
                }
            }

            //client端的socket有事件到达 
            if(events[i].events &amp; EPOLLIN)//socket收到数据
            {
                st = events[i].data.fd;
                if(socket_recv(st) &lt;= 0)
                {
                    close(st);
                    events[i].data.fd = -1;
                }
            }
            if(events[i].events &amp; EPOLLERR ||events[i].events &amp; EPOLLHUP )//socket错误
            {
                st = events[i].data.fd;
                close(st);
                events[i].data.fd = -1;
            }
        }
    }
    close(epfd);
    return 0;
}
</code></pre><h2 id="u5C0F_u7A8D_u95E8"><a href="#u5C0F_u7A8D_u95E8" class="headerlink" title="小窍门"></a>小窍门</h2><h3 id="u5C06_u57DF_u540D_u8F6C_u5316_u4E3AIP_u5730_u5740"><a href="#u5C06_u57DF_u540D_u8F6C_u5316_u4E3AIP_u5730_u5740" class="headerlink" title="将域名转化为IP地址"></a>将域名转化为IP地址</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

const char *getIPAddrbyHostname(const char *hostname)
{
    static char s[128];
    memset(s,0,sizeof(s));
    struct hostnet *h;
    h = gethostbyname(hostname);
    strcpy(s, inet_ntoa(*((struct in_addr *)h-&gt;h_addr)));
    return s;
}
</code></pre><h3 id="u5C06struct_sockaddr_in_u8F6C_u5316_u4E3AIP_u5730_u5740"><a href="#u5C06struct_sockaddr_in_u8F6C_u5316_u4E3AIP_u5730_u5740" class="headerlink" title="将struct sockaddr_in转化为IP地址"></a>将struct sockaddr_in转化为IP地址</h3><pre><code>const char *getIPAddrbyaddr_in(struct sockaddr_in *client_addr)
{
    return inet_ntoa(client_addr-&gt;sin_addr);
}

void sockaddr_toa(sonst struct sockaddr_in *addr, char *IPAddr)
{
    unsigned char *p = (unsigned char *)&amp;(addr-&gt;sin_addr.s_addr);
    sprintf(IPAddr, &quot;%u.%u.%u.%u&quot;,p[0],p[1],p[2],p[3]);
}
</code></pre><h3 id="u5F97_u5230socket_u81EA_u8EAB_u7684sockaddr_u548Csocket_u8FDE_u63A5_u7684_u8FDC_u7AEFsockaddr"><a href="#u5F97_u5230socket_u81EA_u8EAB_u7684sockaddr_u548Csocket_u8FDE_u63A5_u7684_u8FDC_u7AEFsockaddr" class="headerlink" title="得到socket自身的sockaddr和socket连接的远端sockaddr"></a>得到socket自身的sockaddr和socket连接的远端sockaddr</h3><pre><code>//得到远端sockaddr
int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

//得到自身sockaddr
int getsockname(int sockfd, struct sockaddr *addr, socklen *addrlen);
</code></pre><h2 id="Linux_u4E2D_u5B57_u7B26_u96C6_u8F6C_u5316"><a href="#Linux_u4E2D_u5B57_u7B26_u96C6_u8F6C_u5316" class="headerlink" title="Linux中字符集转化"></a>Linux中字符集转化</h2><pre><code>#include &lt;iconv.h&gt;
iconv_t iconv_open(const char *tocode, const char *fromcode);
size_t iconv(iconv_t cd, char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);
int iconv_close(iconv_t cd);
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C/">C++</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Linux信号处理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/25/Linux信号处理/" class="article-date">
  	<time datetime="2015-10-25T08:49:31.000Z" itemprop="datePublished">2015-10-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/25/Linux信号处理/">Linux信号处理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u4FE1_u53F7_u6982_u5FF5"><a href="#u4FE1_u53F7_u6982_u5FF5" class="headerlink" title="信号概念"></a>信号概念</h2><ul>
<li>程序执行的时候,几乎任何时刻都会发生事件</li>
<li>信号通常用来向一个进程通知事件</li>
<li>信号是不可提前预知的,所以信号是异步的</li>
<li>信号随时都可能发生,接收信号的进程也可以没有控制权</li>
<li>每个信号名都以SIG开头,信号名的定义在<signal.h>中</signal.h></li>
</ul>
<p>许多情况下都会出现信号,如硬件异常,非法内存引用,软件异常等<br>前面讲过的kill函数就是向目标进程发一个SIGKILL信号,就和kill命令一样<br>当进程收到一个信号,它可以对信号采取如下三种措施之一:</p>
<ul>
<li>忽略这个信号</li>
<li>捕获这个信号,这需要执行一段称为信号处理去的特殊代码</li>
<li>允许执行信号的默认操作 </li>
</ul>
<p>当信号发生的事件出现时,比如硬件异常,就会产生一个针对具体进程的信号<br>当进程对发送给它的信号采取措施的时候,就叫该信号被传送<br>产生信号和递送信号之间的时间间隔称为信号未决</p>
<p>信号的部署是指进程如何响应信号<br>进程可以忽略信号、用默认操作处理信号、响应这个信号<br>进程不能简单的通过判断一个变量，例如errno来判断是否出现了一个信号</p>
<h3 id="u5E38_u89C1_u4FE1_u53F7_u8BF4_u660E"><a href="#u5E38_u89C1_u4FE1_u53F7_u8BF4_u660E" class="headerlink" title="常见信号说明"></a>常见信号说明</h3><table>
<thead>
<tr>
<th>信号名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGHUP</td>
<td>终止控制终端或进程</td>
</tr>
<tr>
<td>SIGINT</td>
<td>键盘产生的中断(Ctrl-C)</td>
</tr>
<tr>
<td>SIGQUIT　</td>
<td>键盘产生的退出</td>
</tr>
<tr>
<td>SIGILL</td>
<td>非法指令</td>
</tr>
<tr>
<td>SIGTRAP</td>
<td>debug中断</td>
</tr>
<tr>
<td>SIGABRT／SIGIOT　</td>
<td>　异常中止</td>
</tr>
<tr>
<td>SIGBUS／SIGEMT　</td>
<td>　总线异常/EMT指令</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>　浮点运算溢出</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>终强制进程终止,这是个不能被捕捉或忽略的信号,kill9发送该信号</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>　用户信号,进程可自定义用途</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>　非法内存地址引用,该信号只是进程进行了一次无效的内存引用</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>　用户信号，进程可自定义用途</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>向某个没有读取的管道中写入数据,如果写到管道时读取进程已终止,就产生该信号</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>　时钟中断(闹钟),调用alarm设置计时器超时时,产生此信号</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>　进程终止,由kill命令(1)发送的系统默认终止信号</td>
</tr>
<tr>
<td>SIGSTKFLT</td>
<td>　协处理器栈错误</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>　子进程退出或中断</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>　如进程停止状态则开始运行</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>　停止进程运行</td>
</tr>
<tr>
<td>SIGSTP</td>
<td>键盘产生的停止 Ctrl+Z</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>后台进程请求输入</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>后台进程请求输出</td>
</tr>
<tr>
<td>SIGURG</td>
<td>socket发生紧急情况</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>CPU时间限制被打破</td>
</tr>
<tr>
<td>SIGXFSZ</td>
<td>文件大小限制被打破</td>
</tr>
<tr>
<td>SIGVTALRM</td>
<td>虚拟定时时钟</td>
</tr>
<tr>
<td>SIGPROF</td>
<td>profile timer clock</td>
</tr>
<tr>
<td>SIGWINCH忽略</td>
<td>窗口尺寸调整</td>
</tr>
<tr>
<td>SIGIO/SIGPOLL</td>
<td>I/O可用</td>
</tr>
<tr>
<td>SIGPWR</td>
<td>电源异常</td>
</tr>
<tr>
<td>SIGSYS／SYSUNUSED</td>
<td>系统调用异常</td>
</tr>
</tbody>
</table>
<h2 id="u6355_u83B7_u4FE1_u53F7"><a href="#u6355_u83B7_u4FE1_u53F7" class="headerlink" title="捕获信号"></a>捕获信号</h2><p>pause函数挂起调用它的进程,直到有任何消息到达<br>调用进程必须由能力处理送达的信号, 否则信号的默认部署就会发生</p>
<pre><code>#include &lt;unistd.h&gt;
int pause(void)
</code></pre><blockquote>
<p>只有进程捕获到一个信号的时候pause才返回,如果递送到的信号引发了对信号的处理, 那么处理工作将在pause返回前执行<br>pause总是返回-1,并且变量errno设置为EINTR</p>
</blockquote>
<p>发送信号和捕获信号是相辅相成的<br>每个进程能够决定响应除了DIGSTOP和SIGKILL之外的其他所有信号<br>SIGSTOP和SIGKILL不能被捕获或者忽略<br>捕获信号并不是真的去捕获它, 而是等待信号被发送过来</p>
<p>当执行一个程序时,所有信号的状态都是系统默认或者忽略<br>当一个进程调用fork的时候,妻子进城继承父进程的信号处理方式,所以信号捕捉函数的地址在进程中是有意义的</p>
<h3 id="u5B9A_u4E49_u4FE1_u53F7_u5904_u7406_u5668"><a href="#u5B9A_u4E49_u4FE1_u53F7_u5904_u7406_u5668" class="headerlink" title="定义信号处理器"></a>定义信号处理器</h3><blockquote>
<p>某些情况下,一个信号的默认动作就是所希望的行为,但更多场合下,你可以改变默认行为或者执行额外的代码<br>如果想改变默认行为就必须定义并安装一个自定义的信号处理器</p>
</blockquote>
<h4 id="u6307_u5411_u51FD_u6570_u7684_u6307_u9488"><a href="#u6307_u5411_u51FD_u6570_u7684_u6307_u9488" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h4><ul>
<li>可以用指针变量指向整型变量、字符串、数组、结构体、也可指向一个函数</li>
<li>一个函数在编译时被分配一个入口地址，这个入口地址就成为函数指针</li>
<li>可以用一个指针变量指向一个函数，然后通过该指针变量调用此函数</li>
</ul>
<h4 id="u56DE_u8C03_u51FD_u6570"><a href="#u56DE_u8C03_u51FD_u6570" class="headerlink" title="回调函数"></a>回调函数</h4><ul>
<li>回调函数就是通过函数指针调用的函数</li>
<li>如果把函数的指针（地址）作为参数传递给另一个函数， 当这个指针被用来调用其所指向的函数时，我们就是说这是回调函数</li>
<li>回调函数不是由该函数的实现方式直接调用，而是在特定的事件或条件发生时由另外的一方调用，用于对该事件或条件进行响应</li>
</ul>
<h4 id="signal_u51FD_u6570"><a href="#signal_u51FD_u6570" class="headerlink" title="signal函数"></a>signal函数</h4><p>UNIX/LINUX处理信号最常用的接口是signal函数</p>
<blockquote>
<p>在命令行使用kill命令,向指定进程发送信号</p>
</blockquote>
<p>使用kill函数</p>
<pre><code>#include &lt;signal.h&gt;
void (*signal(int signo, void (*fun)(int)));
</code></pre><blockquote>
<p>参数signo是前面表格的信号名<br>参数func是接受到此信号后要调用的函数,该函数有一个int型参数, int代表捕获到的信号值</p>
</blockquote>
<p>进程捕捉到信号并对信号进行处理时,进程正在执行指令序列就被信号处理程序临时中断,它首先执行该信号处理程序中的指令<br>如果信号处理程序返回(没有调用exit(0)或者abort),则继续执行行在捕捉到信号是进程正在执行的正常指令序列<br>在信号处理程序中,不能判断捕捉到信号是进程正在何处执行</p>
<h2 id="u53D1_u9001_u4FE1_u53F7"><a href="#u53D1_u9001_u4FE1_u53F7" class="headerlink" title="发送信号"></a>发送信号</h2><h3 id="u53D1_u9001_u4FE1_u53F7-1"><a href="#u53D1_u9001_u4FE1_u53F7-1" class="headerlink" title="发送信号"></a>发送信号</h3><p>使用kill命令</p>
<blockquote>
<p>在命令行使用kill命令, 向指定进程发送信号</p>
</blockquote>
<p>使用kill函数</p>
<pre><code>#include &lt;signal.h&gt;
#include &lt;sys/types.h&gt;
int kill(pid_t pid, int sig);
</code></pre><blockquote>
<p>参数pid指定一个要杀死的进程,而sig是要发送的信号</p>
</blockquote>
<p>使用raise函数</p>
<pre><code>#include &lt;signal.h&gt;
int raise(int signo);
</code></pre><blockquote>
<p>kill函数将信号发送给进程,raise函数允许进程向自身发送信号<br>raise(signo)等价于kill(getpid(),signo) </p>
</blockquote>
<p>alarm函数设置了一个定时器,当定时器到了就发送SIGALRM信号</p>
<pre><code>#include &lt;unistd.h&gt;
unsigned int alarm(unsigned int seconds);
</code></pre><blockquote>
<p>seconds是计时器事件到后时钟的秒数<br>如果没有设置其他超时,函数返回0,否则返回值为前面安排超时中保留的秒数<br>一个进程只能设置一次超时<br>把seconds设置为0可以取消前面的超时设置</p>
</blockquote>
<p>abort函数</p>
<pre><code>void abort(void);
</code></pre><blockquote>
<p>该函数发送SIGABRT信号给调用进程,进程不应该忽略这个信号<br>即使进程捕捉到SIGABRT这个信号,进程还是会异常退出<br>让进程捕捉SIGABRT的意图是,在进程终止前由其执行所需的清理操作</p>
</blockquote>
<p>sleep函数</p>
<pre><code>unsigned int sleep(unsigned int seconds);
</code></pre><blockquote>
<p>参数seconds指定了睡眠时间<br>超过seconds指定时间,函数返回<br>调用进程捕捉到一个信号并从信号处理程序返回</p>
</blockquote>
<h2 id="u6539_u8FDB_u7684_u6355_u83B7_u4FE1_u53F7_u673A_u5236"><a href="#u6539_u8FDB_u7684_u6355_u83B7_u4FE1_u53F7_u673A_u5236" class="headerlink" title="改进的捕获信号机制"></a>改进的捕获信号机制</h2><p>sigaction函数的功能是检查或修改与制定信号相关联的处理动作,该函数取代了signal函数</p>
<pre><code>#include &lt;signal.h&gt;
int sigaction(int signo, const struct sigaction *act, struct sigaction *oact);
</code></pre><blockquote>
<p>成功返回0, 失败返回-1<br>参数signo是要检测或者修改其具体动作的信号编号(或同事执行这两种操作)<br>如果act指针非空, 则要修改其动作<br>如果oact指针非空,则系统由oact指针返回该信号的上一个动作</p>
</blockquote>
<pre><code>struct sigaction{
    void (*sa_handler)(int);
    void (*sa_sigaction)(int, siginfo_t*, void *);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
}
</code></pre><h4 id="sigaction__u4F7F_u7528_u6A21_u677F"><a href="#sigaction__u4F7F_u7528_u6A21_u677F" class="headerlink" title="sigaction 使用模板"></a>sigaction 使用模板</h4><pre><code>int signal1(int signo, void (*fun)(int))
{
    struct sigaction act, oact;
    act.sa_handler = func;
    sigemptyset(&amp;act.sa_mask);    //初始化&amp;act.sa_mask
    act.sa_flags = 0;
    return sigaction(signo, &amp;act, &amp;oact);
}
</code></pre><h2 id="u4F7F_u7528_u81EA_u5B9A_u4E49_u4FE1_u53F7"><a href="#u4F7F_u7528_u81EA_u5B9A_u4E49_u4FE1_u53F7" class="headerlink" title="使用自定义信号"></a>使用自定义信号</h2><h3 id="u4FE1_u53F7_u7684_u53D1_u9001_u548C_u6355_u6349_u793A_u4F8B"><a href="#u4FE1_u53F7_u7684_u53D1_u9001_u548C_u6355_u6349_u793A_u4F8B" class="headerlink" title="信号的发送和捕捉示例"></a>信号的发送和捕捉示例</h3><h4 id="u53D1_u9001SIGUSR1_u4FE1_u53F7"><a href="#u53D1_u9001SIGUSR1_u4FE1_u53F7" class="headerlink" title="发送SIGUSR1信号"></a>发送SIGUSR1信号</h4><pre><code>int main(int arg, char *args[])
{
    if(arg &gt;1)
     {
        kill(atoi(args[1], SIGUSR1));
        printf(&quot;send to %d\n&quot;, atoi(args[1]));
    }
    return 0;
}
</code></pre><h4 id="u6355_u83B7SIGUSR1_u4FE1_u53F7"><a href="#u6355_u83B7SIGUSR1_u4FE1_u53F7" class="headerlink" title="捕获SIGUSR1信号"></a>捕获SIGUSR1信号</h4><pre><code>void catch_Signal(int sign)
{
    switch(sign)
    {
    case SIGINT:
        printf(&quot;SIGINT Signal\n&quot;);
        exit(0);
    case SIGUSR1:
        printf(&quot;SIGUSR1 Signal\n&quot;);
    }
}

int main(int arg, char *args[])
{
    signal(SIGINT, catch_Signal);
    signal(SIGUSR1, catch_Signal);
    printf(&quot;pid = d%\n&quot;, getpid());
    while(1)
    {
        sleep(1);
    }        
    return 0;
}
</code></pre><h2 id="u5B88_u62A4_u8FDB_u7A0B"><a href="#u5B88_u62A4_u8FDB_u7A0B" class="headerlink" title="守护进程"></a>守护进程</h2><ul>
<li>守护进程十一个后台服务, 它无需用户输入就能运行,经常提供某种服务</li>
<li>Linux作为服务器,主要的进程也都是为系统或者用户提供后台服务功能</li>
<li>常见的守护进程有web服务器、邮件服务器以及数据库服务器等等</li>
<li>守护进程不能够控制终端，所以任何输入或者输出都需要做特殊处理</li>
<li>守护进程看上去似乎很神秘，但如果牢记几条规则而且知道几个关键函数，工作就很简单了</li>
<li>首先执行fork后让父进程退出</li>
<li>和多数程序一样,一个守护进程是从shell脚本或者命令行启动的</li>
<li>但守护进程和应用程序不一样,因为他们不是交互式的–它们在后台因为没有控制终端</li>
<li>父进程在fork子进程退出后就消除了控制终端</li>
<li>守护进程既不需要从标准输入设备读信息,也不需要从标准输出设备输出信息</li>
<li>下一步是在子进程中调用setsid,取消进程和任何控制终端的关联</li>
<li>下一步是让根目录称为子进程的当前工作目录</li>
<li>因为任何进程如果他的当前目录是在一个被安装的文件系统上,那么就会妨碍这个文件系统被卸载</li>
<li>接下来设置进程的umask为0</li>
<li>为了避免守护进程集成的umask收到创建文件和目录操作的干扰,这一步是必要的</li>
<li>如果一个进程集成了父进程的umask 055,它屏蔽掉了group和other的读和执行权限,如果守护进程接着创建了一个文件,那么group和other用户操作这个文件会带来麻烦</li>
<li>守护进程调用umask 0避免了这种情况,当创建文件的时候给予守护进程更大的灵活性</li>
<li>最后关闭子进程继承的任何不必要的文件描述符</li>
<li>对于子进程来说,没有理由保持从父进程继承来的打开的文件描述符</li>
<li>具体关闭哪些取决于具体的守护进程需要和要求,很难精确地说明规则</li>
</ul>
<h4 id="u521B_u5EFA_u5B88_u62A4_u8FDB_u7A0B_u6B65_u9AA4_u603B_u7ED3"><a href="#u521B_u5EFA_u5B88_u62A4_u8FDB_u7A0B_u6B65_u9AA4_u603B_u7ED3" class="headerlink" title="创建守护进程步骤总结"></a>创建守护进程步骤总结</h4><ol>
<li>父进程中执行fork后,执行exit退出</li>
<li>在子进程中调用setsid</li>
<li>让根目录”/“成为进程的工作目录</li>
<li>把子进程的umask变为0</li>
<li>关闭任何不需要的文件描述符</li>
</ol>
<h3 id="setsid_u51FD_u6570"><a href="#setsid_u51FD_u6570" class="headerlink" title="setsid函数"></a>setsid函数</h3><pre><code>pid_t setsid();
</code></pre><blockquote>
<p>setsid函数创建一个新会话和一个新进程组,然后守护进程成为新会话的会话领导,以及新进程组的进程组领导<br>setsid调用还保证新会话没有控制终端<br>如果调用进程已经是一个进程组的领导进程,setsid调用失败<br>setsid调用成功返回会话ID,失败返回-1,并且设置errno</p>
</blockquote>
<h3 id="chdir_u51FD_u6570"><a href="#chdir_u51FD_u6570" class="headerlink" title="chdir函数"></a>chdir函数</h3><pre><code>int chdir(const char *pathname)
</code></pre><blockquote>
<p>chdir 函数根据参数pathname设置当前工作<br>chdir 调用成功返回0, 失败返回-1, 并设置errno </p>
</blockquote>
<h3 id="umask_u51FD_u6570"><a href="#umask_u51FD_u6570" class="headerlink" title="umask函数"></a>umask函数</h3><pre><code>mode_t umask(mode_t mask);
</code></pre><blockquote>
<p>umask调用把守护进程的umask设置为0,这样取消了来自父进程的umask,它们能够潜在的干扰创建文件和目录</p>
</blockquote>
<h4 id="u521B_u5EFA_u5B88_u62A4_u8FDB_u7A0B_u793A_u4F8B"><a href="#u521B_u5EFA_u5B88_u62A4_u8FDB_u7A0B_u793A_u4F8B" class="headerlink" title="创建守护进程示例"></a>创建守护进程示例</h4><pre><code>void setdaemon()
{
    pid_t pid,sid;
    pid = fork();
    if(pid &lt;0)
    {
        printf(&quot;fork failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    if(pid&gt;0)
    {
        exit(EXIT_SUCCESS);
    }
    if((sid = setsid())&lt;0)
    {
        printf(&quot;setsid fialed\n&quot;);
        exit(EXIT_FIALURE);
    }
    if((chdir(&quot;/&quot;))&lt;0)
    {
        printf(&quot;chdir failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    umask();
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
    close(STDIN_FILENO);
}
</code></pre><h3 id="syslog__u65E5_u5FD7_u670D_u52A1"><a href="#syslog__u65E5_u5FD7_u670D_u52A1" class="headerlink" title="syslog 日志服务"></a>syslog 日志服务</h3><p>一旦系统调用setsid,它就不再有控制终端</p>
<p>可以通过syslog提供服务,记录守护进程的各种输出信息</p>
<p>openlog函数打开日志,syslog写入日志, closelog关闭日志</p>
<pre><code>#include &lt;syslog.h&gt;
void openlog(const char *ident, int option, int facility);
void syslog(int priority, const char *format, ...);
void closelog(void);
</code></pre><blockquote>
<p>openlog函数发起到系统日志服务器的连接,参数ident是要向每个消息加入的字符串,典型的情况是要设置成程序的名称</p>
</blockquote>
<p>参数option是下面一个或多个值的”或”</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOG_CONS</td>
<td>如果系统日志服务器不能用,写入控制台</td>
</tr>
<tr>
<td>LOG_NDELAY</td>
<td>立即打开连接,正常情况下,直到发送第一条消息才打开连接</td>
</tr>
<tr>
<td>LOG_PERROR</td>
<td>打印输出到stderr</td>
</tr>
<tr>
<td>LOG_PID</td>
<td>每条消息中包含进程PID</td>
</tr>
</tbody>
</table>
<p>参数facitity指定程序发送消息的类型</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOG_AUTHPRIV</td>
<td>安全授权消息</td>
</tr>
<tr>
<td>LOG_CRON</td>
<td>时钟守护进程: cron和at</td>
</tr>
<tr>
<td>LOG_DAEMON</td>
<td>其他系统守护进程</td>
</tr>
<tr>
<td>LOG_KERN</td>
<td>内核消息</td>
</tr>
<tr>
<td>LOG_LPR</td>
<td>打印机子系统</td>
</tr>
<tr>
<td>LOG_MAIL</td>
<td>邮件子系统</td>
</tr>
<tr>
<td>LOG_USER</td>
<td>默认</td>
</tr>
</tbody>
</table>
<p>参数priority指定消息的重要性</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOG_EMERG</td>
<td>系统不能使用</td>
</tr>
<tr>
<td>LOG_ALERT</td>
<td>立即采取措施</td>
</tr>
<tr>
<td>LOG_CRIT</td>
<td>紧急事件</td>
</tr>
<tr>
<td>LOG_ERR</td>
<td>出错条件</td>
</tr>
<tr>
<td>LOG_WARNING</td>
<td>警告条件</td>
</tr>
<tr>
<td>LOG_NOTICE</td>
<td>正常但重大事件</td>
</tr>
<tr>
<td>LOG_INFO</td>
<td>信息消息</td>
</tr>
<tr>
<td>LOG_DEBUG</td>
<td>调试信息</td>
</tr>
</tbody>
</table>
<h4 id="syslog_u4EE3_u7801_u793A_u4F8B"><a href="#syslog_u4EE3_u7801_u793A_u4F8B" class="headerlink" title="syslog代码示例"></a>syslog代码示例</h4><pre><code>syslog(LOG_INFO, &quot;my daemon is OK&quot;);
</code></pre><blockquote>
<p>严格的说, openlog和closelog是可选的,因为函数syslog在首次使用的时候自动打开日志文件<br>linux系统上日志文件通常是<code>/var/log/messages</code></p>
</blockquote>
<h3 id="u7ED3_u675F_u5B88_u62A4_u8FDB_u7A0B"><a href="#u7ED3_u675F_u5B88_u62A4_u8FDB_u7A0B" class="headerlink" title="结束守护进程"></a>结束守护进程</h3><p>要和一个守护进程通信,你要向他发送信号,让他以某种方式响应</p>
<p>例如:强行要求一个守护进程重新读取它的配置文件,或者改变守护进程的行为,或者指示守护进程结束运行</p>
<h4 id="u901A_u8FC7shell_u811A_u672C_u7ED3_u675F_u5B88_u62A4_u8FDB_u7A0B"><a href="#u901A_u8FC7shell_u811A_u672C_u7ED3_u675F_u5B88_u62A4_u8FDB_u7A0B" class="headerlink" title="通过shell脚本结束守护进程"></a>通过shell脚本结束守护进程</h4><pre><code>#!/bin/sh

WHOAMI=`whoami`

PID=`ps -u $WHOAMI | grep abc | awk &apos;{print $1}&apos;`
if(test &quot;$PID&quot; != &quot;&quot;)then
    kill $PID
fi
</code></pre><blockquote>
<p>注意:脚本文件的名称不要有’abc’字样,不然执行ps的时候会吧脚本名称也print出来</p>
</blockquote>
<h4 id="u901A_u8FC7shell_u786E_u4FDD_u53EA_u542F_u52A8_u4E00_u4E2A_u5B88_u62A4_u8FDB_u7A0B_u5B9E_u4F8B"><a href="#u901A_u8FC7shell_u786E_u4FDD_u53EA_u542F_u52A8_u4E00_u4E2A_u5B88_u62A4_u8FDB_u7A0B_u5B9E_u4F8B" class="headerlink" title="通过shell确保只启动一个守护进程实例"></a>通过shell确保只启动一个守护进程实例</h4><pre><code>#!/bin/sh

WHOAMI=`whoami`

PID=`ps -u $WHOAMI | grep abc | awk &apos;{print $1}&apos;`
if(test &quot;$PID&quot; != &quot;&quot;)then
    ./abc
fi
</code></pre><h3 id="u4F7F_u7528FIFO_u4E0E_u5B88_u62A4_u8FDB_u7A0B_u901A_u4FE1"><a href="#u4F7F_u7528FIFO_u4E0E_u5B88_u62A4_u8FDB_u7A0B_u901A_u4FE1" class="headerlink" title="使用FIFO与守护进程通信"></a>使用FIFO与守护进程通信</h3><h4 id="u8BFBFIFO"><a href="#u8BFBFIFO" class="headerlink" title="读FIFO"></a>读FIFO</h4><pre><code>void readfifo()
{
    int len = 0;
    char buf[1024];
    memset(buf, 0, sizeof(buf));
    int fd = open(&quot;/home/username/1/fifo1&quot;, O_RDONLY);
    while((len = read(fd, buf, sizeof(buf)))&gt;0)
    {
        printf(&quot;%s\n&quot;, buf);
    }
    close(fd);
    return;
}
</code></pre><h4 id="u5199fifo"><a href="#u5199fifo" class="headerlink" title="写fifo"></a>写fifo</h4><pre><code>void writefifo()
{
    int len = 0;
    char buf[1204];
    memset(buf, 0, sizeof(buf));
    int fd = open(&quot;/home/username/1/fifo1&quot;, O_WRONLY);
    scanf(&quot;%s&quot;, buf);
    write(fd, buf, sizeof(buf));
    close(fd);
    return;
}
</code></pre><h4 id="u8BA9_u540E_u53F0_u8FD0_u884C_u7684daemon_u7A0B_u5E8F_u5411_u5C4F_u5E55_u6253_u5370_u4FE1_u606F_u2013_u5B8C_u6574_u7684daemon_u793A_u4F8B_u4EE3_u7801"><a href="#u8BA9_u540E_u53F0_u8FD0_u884C_u7684daemon_u7A0B_u5E8F_u5411_u5C4F_u5E55_u6253_u5370_u4FE1_u606F_u2013_u5B8C_u6574_u7684daemon_u793A_u4F8B_u4EE3_u7801" class="headerlink" title="让后台运行的daemon程序向屏幕打印信息–完整的daemon示例代码"></a>让后台运行的daemon程序向屏幕打印信息–完整的daemon示例代码</h4><pre><code>int signal1(int signo, void (*func)(int))
{
    struct sigaction act, oact;
    act.sa_handler = func;
    sigemptyset(&amp;act.sa_mask);
    act.sa_flags = 0;
    return sigaction(signo, &amp;act, &amp;oact);
}
void setdaemon()
{
    pid_t pid,sid;
    pid = fork();
    if(pid &lt;0)
    {
        printf(&quot;fork failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    if(pid&gt;0)
    {
        exit(EXIT_SUCCESS);
    }
    if((sid = setsid())&lt;0)
    {
        printf(&quot;setsid fialed %s\n&quot;, strerror(errno));
        exit(EXIT_FIALURE);
    }
}

void listenfifo()
{
    const char *sfifoname = &quot;fifo1&quot;; 
    int len = 0;
    char buf[128];
    memset(buf, 0, sizeof(buf));
    int fd = open(sfifoname, O_RDONLY); //打开fifo1管道文件
    if(fd == -1)
    {
        printf(&quot;open %s failed %s\n&quot;, sfifoname, strerror(errno));
    }
    len = read(fd, buf, sizeof(buf)); //进程阻塞,知道有数据才返回来
    if(len &gt;0)
     {
        if(buf[strlen(buf) -1] == &apos;\n&apos;)//如果读到的字符串最后是&apos;\n&apos;, 将&apos;\n&apos;变为0
        {
            buf[strlen(buf) -1] = 0;
        }
        close(STDOUT_FILENO);    //关闭标准输出
        open(buf, O_WRONLY);
    }
    close(fd);
}

void catch_Signal(int sign)
{
    switch(sign)
    {
    case SIGINT:
        listenfifo();
        break;
    }
}
int main(void)
{
    setdaemon();//把进程设为daemon状态
    signal1(SIGINT,catch_Signal);    //捕捉SIINT信号
    while(1)
    {
        ptus(&quot;!! hello world&quot;);
        sleep(1);
    }
    return EXIT_SUCCESS;

}
</code></pre><ol>
<li>执行<code>mkfifo fifo1</code>命令, 创建一个名为fifo1的管道文件</li>
<li>编译上面的代码, 执行程序, 关闭当期控制台终端窗口, 让程序在后台运行</li>
<li>打开一个新的终端窗口, 通过<code>ps aux</code>找到进程PID</li>
<li>执行</li>
</ol>
<pre><code>kill -s 2 PID
tty &gt; fifo
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C/">C++</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Liux多线程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/25/Liux多线程/" class="article-date">
  	<time datetime="2015-10-25T08:46:09.000Z" itemprop="datePublished">2015-10-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/25/Liux多线程/">Liux多线程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u8FDB_u7A0B_u4E0E_u7EBF_u7A0B"><a href="#u8FDB_u7A0B_u4E0E_u7EBF_u7A0B" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程是一个实体, 每个进程都有它自己的内存地址段(heap、stack等等)</p>
<p>进程是执行中的程序, 程序是一个没有生命的实体,只有处理器赋予程序生命时,它才能成为一个活动的实体</p>
<p>进程是操作系统中最基本、最重要的概念</p>
<p>线程，又是被称为轻量级进程（Lightweight Process, LWP）,是程序执行的最小单元</p>
<p>每个程序至少有一个线程,若程序只有一个线程,那就是程序本身</p>
<p>单线程的进程可以简单的认为只有一个线程的进程</p>
<p>一个进程在同一时间只做一件事,有了多线程后一个进程同一时间可以做多件事</p>
<p>每个线程可以处理不同的事务</p>
<p>无论系统有几个CPU,即使进程运行在单CPU上, 多线程也可以使进程并发处理多个事务</p>
<p>一个线程阻塞并不会影响到另外一个线程</p>
<p>多线程的进程可以尽可能的利用系统CPU资源</p>
<p>线程包含了表示进程内执行环境必须的信息,包括标识线程的线程ID, 一组寄存器值,栈,调度优先级和策略,信号屏蔽字,errno变量以及线程私有数据</p>
<p>进程内所有的信息对于线程都是共享的, 包括执行代码,全局变量,堆内存,栈以及文件描述符</p>
<p>线程标识:</p>
<ul>
<li>就像每个进程有个进程ID一样,线程也有自己的ID</li>
<li>进程ID用pid_t来表示, 他是一个unsigned int</li>
<li>线程ID用pthread_t表示,pthread_t不能把它当做整数处理</li>
<li>线程可以通过pthread_self()函数获取自身的线程ID</li>
</ul>
<h2 id="u7EBF_u7A0B_u8C03_u7528"><a href="#u7EBF_u7A0B_u8C03_u7528" class="headerlink" title="线程调用"></a>线程调用</h2><h3 id="u7EBF_u7A0B_u521B_u5EFA"><a href="#u7EBF_u7A0B_u521B_u5EFA" class="headerlink" title="线程创建"></a>线程创建</h3><ul>
<li>在进程中只有一个控制线程</li>
<li>程序开始运行的时候每个进程只有一个线程,它是以单线程方式启动的,在创建多个线程以前,进程的行为与传统的进程没有区别</li>
<li>gcc在链接的时候需要增加<code>-lpthread</code>(链接libpthread.so库)选项</li>
<li>创建一个线程调用pthread_create函数</li>
</ul>
<pre><code>#include &lt;pthread.h&gt;

int pthread_create(pthread_t *thread, const pthread_attr_t * attr, void *(*start_routine)(void *), void *arg);
</code></pre><blockquote>
<p>如果<code>pthread_create</code>成功返回,由thread指向的内存单元被设置为新创建线程的线程ID<br>attr参数用于定制各种不同的线程属性<br>新创建的线程从<code>start_rtn</code>函数地址开始执行,该函数只有一个<code>void *</code>参数,如果需向<code>start_rtn</code>函数传递多个参数,就需要把这些参数放到一个结构中,然后把这个结构的地址做为<code>void *</code>传入<br>线程创建的时候不能保证哪个先运行<br>pthread函数成功返回0<br>注意: 每个线程都拥有一个errno副本,不同的线程拥有不同errno</p>
</blockquote>
<h3 id="u7EBF_u7A0B_u7EC8_u6B62"><a href="#u7EBF_u7A0B_u7EC8_u6B62" class="headerlink" title="线程终止"></a>线程终止</h3><ul>
<li>任一线程调用了<code>exit</code>函数,整个进程就会终止</li>
<li>如果信号默认动作是终止进程, 那么信号发送到该线程,整个进程也会被终止</li>
</ul>
<p>单个线程同过一下三个方式退出</p>
<ul>
<li>线程只是从启动函数中返回,返回值是线程的退出码</li>
<li>线程可以被同一进程中的其他线程取消</li>
<li><p>线程调用pthread_exit</p>
<p>  void pthread_exit(void *arg);</p>
</li>
</ul>
<blockquote>
<p>arg是个无类型指针, 该指针会被其他线程调用pthread_jion捕捉</p>
</blockquote>
<h4 id="pthread_join"><a href="#pthread_join" class="headerlink" title="pthread_join"></a>pthread_join</h4><pre><code>int pthread_join(pthread_t th, void **thr_return);
</code></pre><blockquote>
<p><code>pthread_join</code> 函数用于挂起当前线程, 直至th指定的线程终止为止<br>如果另一个线程返回值不是NULL,则保存在<code>thr_return</code>地址中<br>一个线程所使用的内存资源在应用<code>phread_join</code>调用之前不会被重新分配, 所以对于每个线程必须调用一次<code>pthread_join</code>函数<br>其他线程不能对同一线程再应用pthread_join调用</p>
</blockquote>
<h4 id="pthread_detach"><a href="#pthread_detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h4><pre><code>int pthread_detach(pthread_t th);
</code></pre><blockquote>
<p>pthread_detach函数使线程处于被分离状态<br>对于被分离状态的线程,不需要调用pthread_join,如果其他线程调用pthread_join失败,返回<code>EINVAL</code><br>如果不等待一个线程,同时对线程的返回值不感兴趣,可以设置这个线程为被分离状态,让系统在线程退出的时候自动回收它所占用的资源<br>一个线程不能自己调用pthread_detach改变自己被分离状态,只能由其他线程调用pthread_detach</p>
</blockquote>
<p>可分离线程的使用场景:</p>
<ul>
<li>主线程不需要等待子线程</li>
<li>主线程不关心子线程的返回码</li>
</ul>
<h4 id="pthread_cancel"><a href="#pthread_cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h4><pre><code>int pthread_cancel(pthread_t th);
</code></pre><blockquote>
<p>pthread_cancel 函数允许一个线程取消th指定的另一个线程<br>函数成功返回0,否则返回非0</p>
</blockquote>
<h4 id="pthread_equal"><a href="#pthread_equal" class="headerlink" title="pthread_equal"></a>pthread_equal</h4><pre><code>int pthread_equal(pthread_t th1, pthread_t th2);
</code></pre><blockquote>
<p>pthread_equal函数比较th1与th2是否为同一个线程,由于不可以将pthread数据类型认为是整数,所以也不能用比较整数的方式比较pthread_t<br>如果th1与th2相同,函数返回非0值, 如果不同函数返回0</p>
</blockquote>
<h4 id="u7EBF_u7A0B_u5C5E_u6027"><a href="#u7EBF_u7A0B_u5C5E_u6027" class="headerlink" title="线程属性"></a>线程属性</h4><ul>
<li>以前调用pthread_create传入的attr参数都是空指针,而不是指向pthread_attr_t结构的指针</li>
<li>可以使用pthread_attr_t结构修改线程默认属性,并把这些属性与创建的线程联系起来</li>
<li>可以使用pthread_attr_init函数初始化pthread_attr_t结构</li>
<li>调用pthread_attr_init以后,pthread_attr_t的结构所包含的内容就是操作系统实现支持线程所有属性的默认值,如果要修改其中个别属性的值,需要调用其他函数</li>
</ul>
<pre><code>int pthread_attr_destory(pthread_attr_t *attr);
int pthread_attr_init(pthread_attr_t *attr);
</code></pre><blockquote>
<p>函数pthread_attr_init初始化attr结构<br>函数pthread_attr_destory释放attr内存空间<br>pthread_attr_t的结构对于应用程序来讲是不透明的,应用程序不需要知道有关结构的内部组成<br>通过之前pthread_detach函数概念,可以通过pthread_attr_t在创建线程的时候就指定线程属性为detach,而不用创建以后再去修改线程属性</p>
</blockquote>
<pre><code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
</code></pre><blockquote>
<p>函数pthread_attr_setdetachstate把线程属性设置为下面两个合法值之一</p>
</blockquote>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PTHREAD_CREATE_DETACHED</td>
<td>　设置线程为分离状态</td>
</tr>
<tr>
<td>PTHREAD_CREATE_JOINABLE</td>
<td>　设置线程为正常状态</td>
</tr>
</tbody>
</table>
<h4 id="u793A_u4F8B_u4EE3_u7801"><a href="#u793A_u4F8B_u4EE3_u7801" class="headerlink" title="示例代码"></a>示例代码</h4><pre><code>pthread_t thrd;
pthread_attr_t attr;
pthread_attr_init(&amp;attr);
pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);    //设置线程参数为可分离状态
if(pthread_create(&amp;thread, &amp;attr, func1, NULL) != 0)
{
    printf(&quot;error is %s\n&quot;,strerror(errno));
}
pthread_attr_destory(&amp;attr);
</code></pre><h2 id="u7EBF_u7A0B_u540C_u6B65_u6280_u672F"><a href="#u7EBF_u7A0B_u540C_u6B65_u6280_u672F" class="headerlink" title="线程同步技术"></a>线程同步技术</h2><p>线程共享进程的内存空间,打开文件描述符,全局变量</p>
<p>当有多个线程同时访问一块内存空间或者一个变量、一个文件描述符，如果不加控制，那么可能会出现意想不到的结果</p>
<h3 id="u4E92_u65A5_28mutex_29"><a href="#u4E92_u65A5_28mutex_29" class="headerlink" title="互斥(mutex)"></a>互斥(mutex)</h3><ul>
<li>互斥是相互排斥的意思, 它是一种锁或者信号灯</li>
<li>互斥用来保护多个线程共享的数据和结构不会被同时修改,一个互斥锁只能有两个状态</li>
<li><ul>
<li>locked—加锁</li>
</ul>
</li>
<li><ul>
<li>unlocked—解锁</li>
</ul>
</li>
<li>加锁互斥后不能让其他线程访问</li>
<li>任何时刻只能有一个线程来掌握某个互斥上锁</li>
<li>有一个线程如果试图在一个已经加锁的互斥上再加锁,这个线程会被挂起,直到加锁的线程释放掉互斥锁为止</li>
</ul>
<pre><code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int pthread_mutex_lock(pthread_mutex_t, *mutex);
int pthread_mutex_unlock_(pthread_mutex_t *mutex);
</code></pre><blockquote>
<p>PTHREAD_MUTEX_INITIALIZER是初始化一个快速锁的宏定义<br>pthread_mutex_lock用于给mutex加锁<br>pthread_mutex_unlock用于给mutex解锁</p>
</blockquote>
<h4 id="u7EBF_u7A0B_u4E92_u65A5_u793A_u4F8B"><a href="#u7EBF_u7A0B_u4E92_u65A5_u793A_u4F8B" class="headerlink" title="线程互斥示例"></a>线程互斥示例</h4><pre><code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//初始化一个MUTEX锁

void *func(void *arg)
{
    pthread_mutex_lock(&amp;mutex);//给mutex加锁,这是一个原子操作,不可能出现两个线程同时执行这个代码
    int *a = (int *)arg;
    int i;
    for(i = 0;i&lt;10;i++)
    {
        printf(&quot;thread%d is running\n&quot;, *a);
        sleep(1);
    }
    pthread_mutex_unloac(&amp;mutex);//给mutex解锁
}

int main(int arg, char* args[])
{
    pthread_t thr_d1,thr_d2;
    int 1[2];
    i[1] =1;
    i[2] =2;
    pthread_create(&amp;thr_d1, NULL, func1, &amp;i[0]);
    pthread_create(&amp;thr_d1, NULL, func1, &amp;i[2]);
    pthread_join(thr_d1, NULL);
    pthread_join(thr_d1, NULL);    
    return 0;
}
</code></pre><blockquote>
<p>线程互斥与加锁到解锁之间的代码无关,只与互斥的锁有关</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C/">C++</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Linux进程间通信" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/10/Linux进程间通信/" class="article-date">
  	<time datetime="2015-10-10T06:05:15.000Z" itemprop="datePublished">2015-10-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/10/Linux进程间通信/">Linux进程间通信</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="linux_u4E2D_u7684_u5171_u4EAB_u5E93so"><a href="#linux_u4E2D_u7684_u5171_u4EAB_u5E93so" class="headerlink" title="linux中的共享库so"></a>linux中的共享库so</h2><ul>
<li>so文件在linux中为共享库,与windows下的dll类似</li>
<li>so文件中的函数可以供多个进程调用, 最大可能的提供二进制代码的复用</li>
<li>共享库可以使代码的维护工作大大简化,当修正了一些错误或者添加了新特性的时候,用户只需要获得升级后的so并安装它就可以</li>
<li>注意:即使不同的进程调用同一个so文件,通过共享库不能实现不同进程间的通讯, 因为同一个so文件被不同进程加载到不同的内存空间</li>
</ul>
<h3 id="so_u6587_u4EF6_u7F16_u8BD1_u65B9_u6CD5"><a href="#so_u6587_u4EF6_u7F16_u8BD1_u65B9_u6CD5" class="headerlink" title="so文件编译方法"></a>so文件编译方法</h3><ul>
<li>so文件的源文件中不需要有main函数,即使有也不会被执行</li>
<li>编译的时候gcc需要加<code>-fPIC</code>选项,这样可以使gcc产生与位置无关的代码</li>
<li>链接的时候gcc使用<code>-shared</code>选项,指示生成一个共享库文件</li>
<li>共享库文件名要以lib开头,扩展名为.so</li>
</ul>
<h4 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h4><pre><code>.STUFFIXES:.c .o  
CC=gcc
SRCS=test.c  #要替换成自己的.c文件
OBJS=$(SRCS:.c=.o)
EXEC=libtest.so  

start:$(OBJS)
    $(CC) -shared -o $(EXEC) $(SRCS)
    @echo &apos;----------OK---------&apos;

#.c.o依赖的地方
.c.o:
    # $@就是输出的文件(.o文件)
    $(CC) -g -fPIC -o $@ -c $&lt;    #自动根据$(OBJS)中的文件数量循环编译, 直到编译完所有的.c文件

clean:
    rm -f $(OBJS)
</code></pre><h3 id="so_u6587_u4EF6_u7684_u4F7F_u7528"><a href="#so_u6587_u4EF6_u7684_u4F7F_u7528" class="headerlink" title="so文件的使用"></a>so文件的使用</h3><ul>
<li>为了让Linux能够找到so文件的位置,需要在.bash_profile中添加 <code>export LD_LIBRARY+PATH=$LD_LIBRARY_PATH:.</code></li>
<li>或者将so文件放入linux的系统目录<code>/usr/lib/</code></li>
<li>在c文件中使用so文件,首先需要#include相关h文件</li>
<li>gcc链接时添加 -L 参数指明so文件存放路径, -l参数指明so文件名</li>
<li>以libtest.so文件在当前路径下举例</li>
</ul>
<pre><code>gcc -L. -ltest -o a a.o
</code></pre><ul>
<li>其中<code>-L.</code>意思为在当前路径下寻找so文件</li>
<li><code>-ltest</code>意思为要链接libtest.so这个库文件</li>
<li><code>-o a</code> 意思为编译后的可执行文件名为a</li>
</ul>
<h3 id="C_u548CC++_u6DF7_u5408_u4F7F_u7528"><a href="#C_u548CC++_u6DF7_u5408_u4F7F_u7528" class="headerlink" title="C和C++混合使用"></a>C和C++混合使用</h3><p>当我们在cpp文件中包含test.h文件, 用g++链接libtest.so这个库时会报错:</p>
<p>为了使我们编写的so文件同时可以被C或者C++调用, 我们需要修改h文件中的函数声明部分</p>
<blockquote>
<p>增加带有 <code>__cplusplus</code>的预编译指令<br><code>__cplusplus</code>是c++编译器预定义的一个宏,比如用g++的时候这个宏就被提前定义了 </p>
</blockquote>
<h4 id="u793A_u4F8B"><a href="#u793A_u4F8B" class="headerlink" title="示例"></a>示例</h4><pre><code>#ifndef TEST_H_
#define TEST_H_
#ifndef __cpluscplus
extern &quot;C&quot;{
#endif

int max(int a, int b);
...

# ifdef __cplusplus
}
#endif
#endif 
</code></pre><h2 id="u65E0_u540D_u7BA1_u9053"><a href="#u65E0_u540D_u7BA1_u9053" class="headerlink" title="无名管道"></a>无名管道</h2><p>无名管道是半双工的,就是对于一个管道来讲,只能读,或者写</p>
<p>无名管道只能在相关的、有共同祖先的进程间使用</p>
<p>一个fork或者exec调用创建的子进程继承了父进程的文件描述符</p>
<h3 id="u6253_u5F00_u548C_u5173_u95ED_u7BA1_u9053"><a href="#u6253_u5F00_u548C_u5173_u95ED_u7BA1_u9053" class="headerlink" title="打开和关闭管道"></a>打开和关闭管道</h3><pre><code>int pipe(int filedes[2]);
</code></pre><blockquote>
<p>在你从一个管道中读出或者写入数据,这个管道必须存在<br>如果成功建立了管道,则会打开两个文件描述符并且把它们的值保存在一个整数数组中<br>第一个文件描述符用于读取数据,第二个文件描述符用于写入数据<br>如果出错返回-1, 同时设置errno<br>关闭一个管道用<code>close()</code>函数</p>
</blockquote>
<h3 id="u8BFB_u5199_u7BA1_u9053"><a href="#u8BFB_u5199_u7BA1_u9053" class="headerlink" title="读写管道"></a>读写管道</h3><p>读写管道与读写普通文件方式一样,调用write与read函数即可</p>
<p>几乎不会在一个进程中打开一个管道仅供进程自己使用,管道是用来交换数据的</p>
<p>因为一个进程已经能够访问它要通过管道共享的数据,和自己共享数据是没有意义的</p>
<p>试图对一个管道的两端进行读写操作是一个严重的错误</p>
<h4 id="u8BFB_u5199_u65E0_u540D_u7BA1_u9053_u7684_u793A_u4F8B"><a href="#u8BFB_u5199_u65E0_u540D_u7BA1_u9053_u7684_u793A_u4F8B" class="headerlink" title="读写无名管道的示例"></a>读写无名管道的示例</h4><pre><code>int main(int arg, char * args[])
{
    int fd[2];        //管道描述符
    char buf[100];    //存放管道收发数据
    int len;
    pipe(fd);
    memset(buf, 0, sizeof(buf)); //清空buf
    int pid = fork();
    if(pid == 0)
    {
        close(fd[1]);    //关闭第二个管道(写)
        while((len = read(fd[0], buf, sizeof(buf)))&gt;0)    //循环读取第一个管道
        {
            write(STDOUT_FILENO, buf, len);
        }
        close(fd(0));
    }
    else
    {
        close(fd(0));    //关闭第一个管道(读)
        strcpy(buf, &quot;hello world\n&quot;);
        write(fd[1], buf, sizeof(buf));
        close(fd[1]);
        waitpid(pid, NULL, 0);
    }
    return 0;
}
</code></pre><h2 id="u6709_u540D_u7BA1_u9053_28FIFO_29"><a href="#u6709_u540D_u7BA1_u9053_28FIFO_29" class="headerlink" title="有名管道(FIFO)"></a>有名管道(FIFO)</h2><p>有名管道是持久稳定的</p>
<p>它们存在于文件系统中</p>
<p>FIFO比无名管道作用更大, 因为它们能让无关联的进程之间交换数据</p>
<p>一个shell命令可以建立有名管道</p>
<pre><code>mkfifo [option] name
</code></pre><blockquote>
<p>mkfifo 创建一个名为name的有名管道</p>
</blockquote>
<h3 id="fifo_u7684_u4F7F_u7528"><a href="#fifo_u7684_u4F7F_u7528" class="headerlink" title="fifo的使用"></a>fifo的使用</h3><pre><code>mkfifo fifo1
</code></pre><blockquote>
<p>创建一个有名管道fifo1</p>
</blockquote>
<pre><code>cat &lt; fifo1
</code></pre><blockquote>
<p>通过cat命令从fifo1中读取数据</p>
</blockquote>
<pre><code>ls &gt; fifo1
</code></pre><blockquote>
<p>将ls命令输出的结果写入fifo1中  </p>
</blockquote>
<h3 id="fifo"><a href="#fifo" class="headerlink" title="fifo"></a>fifo</h3><p>创建fifo</p>
<pre><code>int mkfifo(const char *pathname, mode_t mode);
</code></pre><blockquote>
<p>函数执行成功返回1, 否则返回-1,并设置变量errno</p>
</blockquote>
<p>删除fifo</p>
<pre><code>int unlink(const char *pathname);
</code></pre><blockquote>
<p>函数执行成功返回0, 否则返回-1, 并且设置变量errno</p>
</blockquote>
<h4 id="fifo__u793A_u4F8B"><a href="#fifo__u793A_u4F8B" class="headerlink" title="fifo 示例"></a>fifo 示例</h4><p>读fifo:</p>
<pre><code>int main(void)
{
    int len = 0;
    char buf[100];
    memset(buf, 0, sizeof(buf));
    int fd = open(&quot;fifo1&quot;, O_RDONLY);    //以只读方式打开fifo1
    while((len = read(fd, buf, sizeof(buf)))&gt;0) //循环从fifo1中读取数据, 直到fifo1被关闭,循环终止
    {
        printf(&quot;%s\n&quot;, buf);
        memset(buf, 0, sizeof(buf));    
    }
    close(fd);
    return 0;
}
</code></pre><p>写fifo:</p>
<pre><code>int main(void)
{
    int len = 0;
    char buf[100];
    memset(buf, 0, sizeof(buf));
    int fd = open(&quot;fifo1&quot;, O_WRONLY);//以只写方式打开fifo1
    while((1)
    {
        scanf(&quot;s%&quot;, buf);
        if(buf[0] == &apos;0&apos;)    //如果用户输入&apos;0&apos;,退出循环
            break;
        write(fd, buf, sizeof(buf));    //将用户从键盘输入的字符通过fifo发送出去
    }
    close(fd);
    return 0;
}
</code></pre><h2 id="u5185_u5B58_u5171_u4EAB"><a href="#u5185_u5B58_u5171_u4EAB" class="headerlink" title="内存共享"></a>内存共享</h2><p>共享内存是由内核出于在多个进程间交换信息的目的而留出的一块内存区</p>
<p>如果段的权限设置恰当,每个要访问该段内存的进程都可以把它映像到自己的私有地址空间中</p>
<p>如果一个进程更新了段中的数据, 其他进程页立即会看到更新</p>
<p>由一个进程创建的段,也可以由另一个进程读写</p>
<p>每个进程都把它自己对共享内存的映像放入自己的地址空间</p>
<h3 id="u521B_u5EFA_u5171_u4EAB_u5185_u5B58"><a href="#u521B_u5EFA_u5171_u4EAB_u5185_u5B58" class="headerlink" title="创建共享内存"></a>创建共享内存</h3><pre><code>#include&lt;sys/ipc.h&gt;
#include&lt;sys/shm.h&gt;
int shmget(key_t key, size_t size, int shm-flg);
</code></pre><blockquote>
<p>参数key既可以是IPC_PRIVATE,也可以是fork函数返回的一个关键字<br>参数size指定段的大小<br>参数flags-八进制数, 0xxx,转化为二进制后分别代表rw-rw-rw-<br>shmget成功返回段标示符,失败返回-1</p>
</blockquote>
<p>创建共享内存后,在命令行执行 <code>ipcs -m</code>显示, 已经成功的创建了一块共享内存区</p>
<blockquote>
<p>nattch字段显示已经附加到这个内存区的进程数</p>
</blockquote>
<p>在命令行执行 <code>ipcrm shm shmid</code>删除共享内存</p>
<h3 id="u9644_u52A0_u5171_u4EAB_u5185_u5B58_u533A"><a href="#u9644_u52A0_u5171_u4EAB_u5185_u5B58_u533A" class="headerlink" title="附加共享内存区"></a>附加共享内存区</h3><pre><code>void *shmat(int shmid, const void *shmaddr, int shmflg);
int shmdt(const void *shmaddr);
</code></pre><blockquote>
<p>参数shmid是要附加的共享内存区标示符<br>总是把参数shmaddr设为0<br>参数shmflg可以为SHM_RDONLY,这意味着附加段是只读的<br>shmat成功返回被附加了段的地址, 失败返回-1, 并设置errno<br>函数shmdt是将附加在shmaddr的段从调用进程的地址空间分离出去,这个地址必须是shmat返回的</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C/">C++</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Linux进程控制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/07/Linux进程控制/" class="article-date">
  	<time datetime="2015-10-07T08:28:01.000Z" itemprop="datePublished">2015-10-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/07/Linux进程控制/">Linux进程控制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Linux_u8FDB_u7A0B_u6A21_u578B"><a href="#Linux_u8FDB_u7A0B_u6A21_u578B" class="headerlink" title="Linux进程模型"></a>Linux进程模型</h2><p>传统的Linux模型里有三种创建或者修改进程的操作:</p>
<ul>
<li>system用于调用shell, 执行一个指定命令</li>
<li>fork用于创建一个新的进程,该进程几乎是当前进程的一个完全拷贝</li>
<li>exec可以在进程中用另外的程序来替换当前运行的进程</li>
</ul>
<h3 id="u4EC0_u4E48_u662F_u8FDB_u7A0B"><a href="#u4EC0_u4E48_u662F_u8FDB_u7A0B" class="headerlink" title="什么是进程"></a>什么是进程</h3><blockquote>
<ul>
<li>进程是一个正在执行的程序实例,他也是Linux基本的调度单位,一个进程由如下元素组成</li>
<li>进程当前上下文(context),它是进程当前执行状态</li>
<li>进程当前执行目录</li>
<li>进程访问的文件和目录</li>
<li>程序的访问权限</li>
<li>内存和其他分配给进程的系统资源</li>
</ul>
</blockquote>
<ul>
<li>内核使用进程来控制对CPU和其他系统资源的访问,并且使用进程来决定在CPU上运行那个程序, 运行多久以及采用什么特性运行它</li>
<li>内核的调度器负责所有的进程间分配CPU时间,称为时间片, 它轮流在每个进程分的时间片用完后从进程那里抢回控制权</li>
<li>时间片非常小,小到让系统上的几个进程仿佛是在同一时间运行一样</li>
<li>每个进程还包含了有关他们自身的成分信息, 必要的时候内核能在执行与不执行它之间进行切换</li>
<li>进程具有许多能位移定义它们的属性和特性</li>
<li>进程的属性或特性能够吧它们表示出来并且规定他们的行为</li>
<li>Linux内核维护了关于每个进程的大量信息, 并且对外提供一个访问这些信息的接口</li>
</ul>
<h3 id="u8FDB_u7A0B_u6807_u8BC6_u53F7"><a href="#u8FDB_u7A0B_u6807_u8BC6_u53F7" class="headerlink" title="进程标识号"></a>进程标识号</h3><p>进程最知名的属性就是进程号(processID,PID)和它父进程号(parent processID, PPID)</p>
<ul>
<li>PID和PPID都是非零整数</li>
<li>一个PID唯一标识一个进程</li>
<li>一个进程创建另一个新进程称为子进程,相反地,创建的进程称为父进程</li>
<li>所有进程追溯其祖先最终都会落到进程号为1的进程身上,这个进程叫init进程<ul>
<li>init进程是linux内核启动后第一个执行的进程</li>
<li>init引导系统,启动守护进程并且运行必要的程序</li>
</ul>
</li>
</ul>
<p>虽然计算机用数字工作挺好,但普通人甚至程序员还是感到使用名字更舒服一些, 幸运的是有两种方法能把UID转换为人可读的名字:</p>
<blockquote>
<p>getlogin函数返回执行程序的用户登录名<br>可以把登录名最为参数传递给getpwnam函数,这个函数能返回/etc/passwd文件中与该登录名响应的一行完整信息</p>
</blockquote>
<pre><code>#include&lt;pwd.h&gt;
struct passwd *getpwnam(const char *name);
</code></pre><blockquote>
<p>name必须是一个指向包含用户名的字符串指针<br>getpwnam返回一个指向passwd结构的指针</p>
</blockquote>
<pre><code>#include&lt;sys/types.h&gt;
#include&lt;pwd.h&gt;
int main(void)
{
    char *login = getlogin();
    struct passwd *ps = getpwnam(login);
    printf(&quot;user name=%s\n&quot;, ps-&gt;pw_name);
    printf(&quot;UID=%d\n&quot;, ps-&gt;pw_uid);
    printf(&quot;home dir=%s\n&quot;, ps-&gt;pw_dir);
    return EXIT_SUCCESS;

}
</code></pre><h2 id="u521B_u5EFA_u8FDB_u7A0B"><a href="#u521B_u5EFA_u8FDB_u7A0B" class="headerlink" title="创建进程"></a>创建进程</h2><h3 id="system_u7CFB_u7EDF_u8C03_u7528"><a href="#system_u7CFB_u7EDF_u8C03_u7528" class="headerlink" title="system系统调用"></a>system系统调用</h3><pre><code>#include&lt;stdlib.h&gt;
int system(const char *string);
</code></pre><blockquote>
<p>system函数传递给/bin/sh -c 来执行string所指定的命令<br>string中可以包含选项和参数<br>如果没有找到/bin/sh,函数返回127, 如果出现其他错误返回-1,成功返回0,但如果string为NULL,返回一个非0值</p>
</blockquote>
<h3 id="fork_u7CFB_u7EDF_u8C03_u7528"><a href="#fork_u7CFB_u7EDF_u8C03_u7528" class="headerlink" title="fork系统调用"></a>fork系统调用</h3><pre><code>#include &lt;unistd.h&gt;
pid_t fork(void);
</code></pre><blockquote>
<p>fork执行成功, 向父进程返回子进程的PID,并向子进程返回0,这意味着fork即使只调用一次,也会返回两次<br>fork创建的新进程是和父进程(除PID和PPID)一样的副本<br>父进程和子进程之间有点区别,子进程没有继承父进程的超时设置(使用alarm调用)、父进程创建的文件锁，或者未决信号</p>
</blockquote>
<pre><code>int main（void）
{
    pid_t child = fork();
    if(child == -1)
    {    

        return -1;
    }
    if(child == 0)
    {
        printf(&quot;is child\n&quot;);
    }
    else
    {
        printf(&quot;is parent, child pid is %d\n&quot;, getpid());
    }
}
</code></pre><ul>
<li>你不能预计父进程是在它的子进程之前还是之后运行, 它的执行是无序的, 是异步的.</li>
<li>fork的异步行为意味着你不应该在子进程中执行依赖与父进程的代码,反之亦然</li>
<li>fork调用可能失败,原因上是系统上已经运行了太多进程,已经超过了允许执行的最大进程数</li>
<li><p>fork执行失败,会向父进程返回-1,而且不创建子进程</p>
</li>
<li><p>fork过程包括把父进程全部内存映像复制给子进程,这个过程很慢</p>
</li>
<li>UNIX的设计者创建了vfork调用,vfork调用也创建新进程,但它不产生父进程的副本</li>
<li>Linux已经使用了写时复制技术,因此Linux的fork和UNIX的vfork一样快</li>
</ul>
<h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><pre><code>int execve(const char *path, const char *arg, char *const envp[]);
</code></pre><blockquote>
<p>fork创建了一个新的进程,产生一个新的PID<br>execve用被执行的程序全部替换了调用进程的映像<br>execve启动一个新程序,替换原有进程,所以被执行进程的PID不会改变<br>execve函数接受三个参数<br>-path- 要执行的文件完整路径<br>-argv-传递给程序完整参数列表,包括argv[0],它一般是执行程序的名字<br>-envp-是指向执行execed程序的环境指针,可以设为NULL</p>
</blockquote>
<h4 id="u793A_u4F8B"><a href="#u793A_u4F8B" class="headerlink" title="示例"></a>示例</h4><pre><code>int main(int arg, char *args[])
{
    close(STDOUT_FILENO);//关闭标准输出
    open(&quot;/dev/pts/2&quot;,O_WRONLY);// 打开&quot;/dev/pts/2&quot;,作为标准输出
    pid_t pid = fork();//调用一个fork产生一个子进程
    int status;
    if(pid == -1)
    {
        printf(&quot;fork failed\n&quot;);
        return 0;
    }
    if(pid == 0)//子进程调用execve,执行ls -l 命令
    {
        char *gars[] = {&quot;/bin/ls&quot;,&quot;-1&quot;, NULL};
        execve(&quot;/bin/ls&quot;, args, NULL);
    }
    else
    {
        return 0;//父进程退出
    }
}
</code></pre><h3 id="u6536_u96C6_u5B50_u8FDB_u7A0B_u9000_u51FA_u72B6_u6001"><a href="#u6536_u96C6_u5B50_u8FDB_u7A0B_u9000_u51FA_u72B6_u6001" class="headerlink" title="收集子进程退出状态"></a>收集子进程退出状态</h3><p>wait和waitpid函数可以收集子进程的退出状态</p>
<pre><code>#include &lt;sys/wait.h&gt;
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);
</code></pre><blockquote>
<p>status保存进程的退出状态<br>pid为等待进程的PID,它能接受下表列出的4种值中的一个</p>
</blockquote>
<table>
<thead>
<tr>
<th>值</th>
<th>描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td> -1</td>
<td>等待任何PGID等于PID的绝对值子进程 </td>
</tr>
<tr>
<td> 1</td>
<td>等待任何子进程 </td>
</tr>
<tr>
<td> 0</td>
<td>等待任何PGID等于调用进程的子进程 </td>
</tr>
<tr>
<td> &gt;0</td>
<td>等待PID等于pid的子进程 </td>
</tr>
</tbody>
</table>
<p>用fork或者exec函数创建了一个新进程,为了收集新进程的退出状态并防止出现僵死进程(zombie process), 父进程应该调用waitpid等待子进程的终止</p>
<h4 id="u50F5_u6B7B_u8FDB_u7A0B"><a href="#u50F5_u6B7B_u8FDB_u7A0B" class="headerlink" title="僵死进程"></a>僵死进程</h4><ul>
<li>一个僵死进程是在父进程有机会用wait或者waitpid收集它退出状态之前就终止的子进程</li>
<li>之所以被称为僵死进程是因为它虽死掉了, 但依然在进程表中存在</li>
<li>子进程退出后分配给它的内存和资源都被释放,但它还是在内核进程表中保留了一条,内核在父进程回收子进程的退出状态之前一直保留它</li>
<li>有一两个僵死进程不算什么问题, 但一旦一个程序频繁执行fork或者exec却又不能收集退出状态,那么最终将填满进程表,这会影响性能,可能导致系统重新启动</li>
</ul>
<h4 id="u5B64_u513F_u8FDB_u7A0B"><a href="#u5B64_u513F_u8FDB_u7A0B" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><ul>
<li>孤儿进程是一个父进程调用wait或者waitpid之前就已经退出的子进程, 此时init进程称为子进程的父进程</li>
<li>init进程为子进程的父进程收集退出状态,从而避免出现僵死进程</li>
</ul>
<h2 id="u7ED3_u675F_u8FDB_u7A0B"><a href="#u7ED3_u675F_u8FDB_u7A0B" class="headerlink" title="结束进程"></a>结束进程</h2><p>一个进程由于以下5个原因中的一个终止:</p>
<ul>
<li>main函数调用了return</li>
<li>调用了exit函数</li>
<li>调用了_exit函数</li>
<li>调用了abort函数</li>
<li>被一个信号终止</li>
</ul>
<p>前三个原因都是正常终止,后面两个是非正常终止</p>
<p>无论进程为何中止,最后都执行相同的内核代码, 关闭打开的文件,释放内存资源, 和其他清理工作</p>
<h3 id="exit_u51FD_u6570"><a href="#exit_u51FD_u6570" class="headerlink" title="exit函数"></a>exit函数</h3><pre><code>int exit(int status);
</code></pre><blockquote>
<p>exit导致程序正常终止,并且返回给父进程的状态</p>
</blockquote>
<h3 id="abort__u51FD_u6570"><a href="#abort__u51FD_u6570" class="headerlink" title="abort 函数"></a>abort 函数</h3><pre><code>void abort(void)
</code></pre><blockquote>
<p>abort导致程序异常终止<br>abort还可以让程序产生core,这是大多数调试器用于分析程序崩溃时的文件</p>
</blockquote>
<ul>
<li>虽然任何打开的文件都被关闭了, 但是abort仍然是一个粗暴的调用, 应该作为最后的手段来使用</li>
</ul>
<h3 id="kill_u51FD_u6570"><a href="#kill_u51FD_u6570" class="headerlink" title="kill函数"></a>kill函数</h3><pre><code>#include&lt;signal.h&gt;
#include&lt;sys/types.h&gt;
int kill(pid_t pid, int sig);
</code></pre><blockquote>
<p>exit,abort用来杀死进程自己<br>kill函数用来杀死另一个进程<br>参数pid指定一个要杀死的进程,而sig是要发送的信号,SIGKILL</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C/">C++</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Linux文件输入输出和目录操作" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/07/Linux文件输入输出和目录操作/" class="article-date">
  	<time datetime="2015-10-07T08:20:50.000Z" itemprop="datePublished">2015-10-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/07/Linux文件输入输出和目录操作/">Linux文件输入输出和目录操作</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u6587_u4EF6_u7CFB_u7EDF"><a href="#u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统是一种存储和组织计算机文件和资料的方法</p>
<p><strong>它的主要内容是:</strong><br>(1)定义磁盘文件结构<br>(2)定义文件操作<br>(3)冗错<br>(4)对上接口</p>
<h4 id="u6587_u4EF6_u7ED3_u6784_3A"><a href="#u6587_u4EF6_u7ED3_u6784_3A" class="headerlink" title="文件结构:"></a>文件结构:</h4><p>(1)引导区<br>(2)超级块Master<br>(3)存放数据区data<br>(4)索引区 INode</p>
<h4 id="u6587_u4EF6_u7CFB_u7EDF_u5206_u7C7B_3A"><a href="#u6587_u4EF6_u7CFB_u7EDF_u5206_u7C7B_3A" class="headerlink" title="文件系统分类:"></a>文件系统分类:</h4><p>磁盘文件系统 :NTFS,EXT3<br>闪存文件系统 :JFFS2,YAFFS<br>数据库文件系统 :BFS,WINFS<br>网络文件系统 :NFS<br>虚拟文件系统 :VFS(Proc)</p>
<h3 id="u4E00_u5207_u7686_u6587_u4EF6"><a href="#u4E00_u5207_u7686_u6587_u4EF6" class="headerlink" title="一切皆文件"></a>一切皆文件</h3><blockquote>
<p>Linux中一切皆文件</p>
</blockquote>
<p>Linux中文件类型:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标示符</th>
</tr>
</thead>
<tbody>
<tr>
<td>一般文件</td>
<td>-</td>
</tr>
<tr>
<td>目录文件</td>
<td>d</td>
</tr>
<tr>
<td>链接文件</td>
<td>l</td>
</tr>
<tr>
<td>块设备</td>
<td>b</td>
</tr>
<tr>
<td>字符设备</td>
<td>c</td>
</tr>
<tr>
<td>socket</td>
<td>s     </td>
</tr>
<tr>
<td>管道</td>
<td>p</td>
</tr>
</tbody>
</table>
<p>管道:把一个文件的出口写到另一个文件的入口,或者是把一个程序的出口写到另一个程序的入口</p>
<h3 id="u6587_u4EF6_u5C5E_u6027"><a href="#u6587_u4EF6_u5C5E_u6027" class="headerlink" title="文件属性"></a>文件属性</h3><p>例如: <code>drwxr-xr-x</code><br>我们可以将文件属性分成4部分: </p>
<table>
<thead>
<tr>
<th>d</th>
<th>rwx</th>
<th>r-x</th>
<th>r-x</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件类型</td>
<td>owner权限</td>
<td>用户组权限</td>
<td>其他用户权限</td>
</tr>
</tbody>
</table>
<p><strong>文件颜色:</strong></p>
<p>蓝色–目录<br>绿色–可执行文件<br>红色–压缩文件<br>浅蓝色–链接文件<br>灰色–其他文件</p>
<h3 id="Linux_u76EE_u5F55_u7ED3_u6784"><a href="#Linux_u76EE_u5F55_u7ED3_u6784" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p>/bin        二进制    存放系统可执行文件<br>/sbin                    存放管理员系统可执行文件<br>/etc                      配置文件<br>/lib                      共享类库<br>/dev                    设备<br>/tmp                   临时文件<br>/boot                  启动<br>/root                   root用户目录<br>/mnt                   挂载目录<br>/opt                    优化目录<br>/usr                     用户程序目录<br>/user/bin (sbin)    用户可执行文件目录<br>/var                    系统变量<br>/proc                  虚拟文件系统FVS<br>/lost+found        当系统崩溃时用户找回文件<br>/home                 用户文档</p>
<h2 id="u4F7F_u7528_u6587_u4EF6_u63CF_u8FF0_u7B26"><a href="#u4F7F_u7528_u6587_u4EF6_u63CF_u8FF0_u7B26" class="headerlink" title="使用文件描述符"></a>使用文件描述符</h2><h3 id="u6253_u5F00_u548C_u5173_u95ED_u6587_u4EF6_u63CF_u8FF0_u7B26"><a href="#u6253_u5F00_u548C_u5173_u95ED_u6587_u4EF6_u63CF_u8FF0_u7B26" class="headerlink" title="打开和关闭文件描述符"></a>打开和关闭文件描述符</h3><pre><code>#include&lt;sys/types.h&gt;
#include&lt;sys/stat.h&gt;
#inlcude&lt;fcntl.h&gt;
#include&lt;unistd.h&gt;
int open(const char *pathname, int flags);
int close()int fd;
</code></pre><blockquote>
<p>open试图打开参数pathname中的一个文件<br>参数flags指定访问该文件的方式<br>必须把flags设置为O_RDONLY、O_WRONLY、O_RDWR、O_CREAT、O_APPEND分别表示只读、只写、读写 如果文件不存在就创建、追加<br>open成功后会返回一个文件描述符<br>open失败后会返回-1,并设置errno变量</p>
</blockquote>
<h4 id="errno_u793A_u4F8B"><a href="#errno_u793A_u4F8B" class="headerlink" title="errno示例"></a>errno示例</h4><pre><code>#include&lt;sys/types.h&gt;
#include&lt;sys/stat.h&gt;
#inlcude&lt;fcntl.h&gt;
#include&lt;unistd.h&gt;
#include&lt;errno.h&gt;

int main(void)
{
    char s[] = &quot;abc.txt&quot;
    int fd = open(s, O_RDONLY);
    if(fd == -1)
    {
        printf(&quot;%s\n&quot;, strerror(errno));
    }
    else
    {
        printf(&quot;fd = %d\n&quot;, fd);
        close(fd);
    }
    return EXIT_SUCCESS;
}
</code></pre><p>若当前目录下没有abc.txt文件, 则会打印”No such file or derctory “</p>
<blockquote>
<p>在一个文件描述符用完后一定要用close()函数关闭它, 这样才能保证该进程对文件所有加的锁全部被释放</p>
</blockquote>
<h4 id="u5B9E_u9A8C_u2013_u6587_u4EF6_u63CF_u8FF0_u7B26_u7684_u4F5C_u7528"><a href="#u5B9E_u9A8C_u2013_u6587_u4EF6_u63CF_u8FF0_u7B26_u7684_u4F5C_u7528" class="headerlink" title="实验–文件描述符的作用"></a>实验–文件描述符的作用</h4><p>把上面的打开文件做成一个死循环</p>
<pre><code>int main(void)
{
    char s[] = &quot;abc.txt&quot;
    int fd = open(s, O_RDONLY);
    if(fd == -1)
    {
        printf(&quot;%s\n&quot;, strerror(errno));
    }
    else
    {
        while(1)
        {
            printf(&quot;fd = %d\n&quot;, fd);
            sleep(1);  //代表休眠1秒
        }
        close(fd);
    }
    return EXIT_SUCCESS;
}
</code></pre><p>查看进程编号: </p>
<pre><code>ps -u test
</code></pre><p>显示编号为: 12421 pts/2    00:00:00 abc</p>
<p>进入proc/12421/fd目录下:</p>
<pre><code>cd  /proc/12421/fd
</code></pre><p>列出fd目录下的内容:</p>
<pre><code>ls
</code></pre><p>显示结果为: 0  1  2  3<br>其中: 0代表标准输入, 1代表标准输出, 2代表标准错误, 3就是代表所代开的abc.txt文件</p>
<p>查看文件3的属性:</p>
<pre><code>file 3
</code></pre><p>显示结果为: 3:symbolic link to ‘/home/test/1/1/abc.txt’<br>表示文件的路径</p>
<p>通过<code>cat 3</code> 就是可以查看文件内容</p>
<h4 id="u901A_u8FC7open_u51FD_u6570_u6539_u53D8_u6807_u51C6_u8F93_u51FA_u7684_u65B9_u6CD5"><a href="#u901A_u8FC7open_u51FD_u6570_u6539_u53D8_u6807_u51C6_u8F93_u51FA_u7684_u65B9_u6CD5" class="headerlink" title="通过open函数改变标准输出的方法"></a>通过open函数改变标准输出的方法</h4><pre><code>int main(void)
{
    char s[] = &quot;abc.txt&quot;;
    int i = 0;

    close(STDOUT_FILENO);//关闭标准输出文件描述符
    int fd1 = open(&quot;/dev/pts/1&quot;, O_WRONLY);//打开设备文件/dev/pts/1，该设备将做为标准输出文件描述符
    int fd = open(s, O_RDONLY);//
    if (fd == -1)
    {
        printf(&quot;%s\n&quot;, strerror(errno));//
    }else
    {
        while(1)
        {
            printf(&quot;fd1 = %d, fd = %d:%d\n&quot;, fd1, fd, i++);//printf语句将会打印到/dev/pts/1上
            sleep(1);//
        }
        close(fd);
    }
    return EXIT_SUCCESS;
}
</code></pre><h3 id="u8BFB_u5199_u6587_u4EF6_u63CF_u8FF0_u7B26"><a href="#u8BFB_u5199_u6587_u4EF6_u63CF_u8FF0_u7B26" class="headerlink" title="读写文件描述符"></a>读写文件描述符</h3><pre><code>ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, void *bug, size_t count);
</code></pre><blockquote>
<p>read用于从该文件描述符对应的文件读取数据, 调用成功返回读出的字节数<br>参数fd必须是用open调用返回的有效文件描述符<br>参数buf为读出数据的缓冲区, count指定读出的字节数<br>成功返回读取字节数, 如果遇到EOF, 返回0, 出错返回-1</p>
</blockquote>
<h5 id="read_u51FD_u6570_u793A_u4F8B"><a href="#read_u51FD_u6570_u793A_u4F8B" class="headerlink" title="read函数示例"></a>read函数示例</h5><pre><code>int main()
{
    char s[] = &quot;abc.txt&quot;
    int fd = open(s, O_RDONLY);//只读方式打开文件
    if(fd == -1)
    {
        printf(&quot;error is %s\n&quot;, strerror(errno));
    } else
    {
        printf(&quot;success fd=%d\n&quot;, fd);
        char buf[100];
        memset(buf, 0, sizeof(buf));
        while(read(fd, buf, sizeof(buf) -1) &gt; 0)//循环读取文件内容, 指导文件结尾, 退出循环
        {
            printf(&quot;%s\n&quot;, buf);
            memset(buf, 0, sizeof(buf));//buf清0
        }

        close(fd);
    }
    return 0;
}
</code></pre><h4 id="write_u51FD_u6570_u793A_u4F8B"><a href="#write_u51FD_u6570_u793A_u4F8B" class="headerlink" title="write函数示例"></a>write函数示例</h4><pre><code>int main(int arg, char *args[])
{
    char s[] = &quot;abc.txt&quot;;
    int fd = open(s, O_RDWR | O_APPEND);//用读写追加方式打开文件
    if (fd == -1)
    {
        printf(&quot;error is %s\n&quot;, strerror(errno));
    }else
    {
        printf(&quot;success fd = %d\n&quot;, fd);
        char buf[100];
        memset(buf, 0, sizeof(buf));
        strcpy(buf, &quot;hello world\n&quot;);
        int i = write(fd, buf, strlen(buf));//这里要用strlen函数,不能用sizeof
        close(fd);
    }
    return 0;
}
</code></pre><h3 id="u83B7_u53D6_u6587_u4EF6_u4FE1_u606F"><a href="#u83B7_u53D6_u6587_u4EF6_u4FE1_u606F" class="headerlink" title="获取文件信息"></a>获取文件信息</h3><p>使用fstat获取文件信息</p>
<pre><code>int fstat(int fd, struct stat *buf)
</code></pre><blockquote>
<p>参数fd必须是用open调用返回的有效描述符</p>
</blockquote>
<p>使用 stat获取文件信息</p>
<pre><code>int stat(int fd, struct stat *buf)
</code></pre><blockquote>
<p>参数path是路径加文件名的字符串</p>
</blockquote>
<h4 id="Struct_stat_u5B9A_u4E49_u5982_u4E0B"><a href="#Struct_stat_u5B9A_u4E49_u5982_u4E0B" class="headerlink" title="Struct stat定义如下"></a>Struct stat定义如下</h4><pre><code>struct stat{
    dev_t        st_dev;     /* ID of device containing file */
    ino_t       st_ino;     /* inode number */
    mode_t      st_mode;     /* protection */
    nlink_t     st_nlink;     /* number of hard links */
    uid_t         st_uid;     /* user ID of owner */
    gid_t         st_gid;     /* group ID of owner */
    dev_t         st_rdev;     /* device ID (if special file) */
    off_t         st_size;     /* total size, in bytes */
    blksize_t     st_blksize; /* block size for filesystem I/O */
    blkcnt_t     st_blocks;     /* number of blocks allocated */
    time_t         st_atime;     /* time of last access */
    time_t         st_mtime;     /* time of last modification */
    time_t         st_ctime;     /* time of last status change */
};
</code></pre><p>为了正确解释文件类型, 有一套宏能够计算stat接口的st_mode成员</p>
<pre><code>#define S_IRWXU 00700   /* mask for file owner permissions */  
#define S_IRUSR 00400   /* owner has read permission */  
#define S_IWUSR 00200   /* owner has write permission */  
#define S_IXUSR 00100   /* owner has execute permission */  

#define S_IRWXG 00070   /* mask for group permissions */  
#define S_IRGRP 00040   /* group has read permission */  
#define S_IWGRP 00020   /* group has write permission */  
#define S_IXGRP 00010   /* group has execute permission */  

#define S_IRWXO 00007   /* mask for permissions for others (not in group) */  
#define S_IROTH 00004   /* others have read permission */  
#define S_IWOTH 00002   /* others have write permission */  
#define S_IXOTH 00001   /* others have execute permission */  
</code></pre><h4 id="u5F97_u5230_u6587_u4EF6_u72B6_u6001_u4EE3_u7801_u793A_u4F8B"><a href="#u5F97_u5230_u6587_u4EF6_u72B6_u6001_u4EE3_u7801_u793A_u4F8B" class="headerlink" title="得到文件状态代码示例"></a>得到文件状态代码示例</h4><pre><code>int main(int arg, char *args[])
{
    int fd = open(args[1], O_RDONLY);
    if (fd == -1)
    {
        printf(&quot;error is %s\n&quot;, strerror(errno));
    }else
    {
        printf(&quot;success fd = %d\n&quot;, fd);
        struct stat buf;
        fstat(fd, &amp;buf);
        if (S_ISREG(buf.st_mode))//判断文件是否为标准文件
        {
            printf(&quot;%s is charfile\n&quot;, args[1]);
        }
        if (S_ISDIR(buf.st_mode))//判断文件是否为目录
        {
            printf(&quot;%s is dir\n&quot;, args[1]);
        }

        printf(&quot;%s size =%d\n&quot;, args[1], buf.st_size);//得到文件大小

        close(fd);
    }
    return 0;
}
</code></pre><h3 id="u8BFB_u5199_u7528_u6237_u8F93_u5165_2C__u5C4F_u5E55_u4E0D_u56DE_u663E"><a href="#u8BFB_u5199_u7528_u6237_u8F93_u5165_2C__u5C4F_u5E55_u4E0D_u56DE_u663E" class="headerlink" title="读写用户输入, 屏幕不回显"></a>读写用户输入, 屏幕不回显</h3><pre><code>char *getpass(const char *prompt);
</code></pre><blockquote>
<p>getpass函数用于从键盘读取用户输入, 但屏幕不回显<br>参数prompt为屏幕提示字符<br>函数返回值为用户键盘输入的字符</p>
</blockquote>
<h2 id="u6587_u4EF6_u548C_u76EE_u5F55_u64CD_u4F5C"><a href="#u6587_u4EF6_u548C_u76EE_u5F55_u64CD_u4F5C" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h2><p>这里介绍的函数是库函数, 而不是系统调用</p>
<blockquote>
<p>库函数和系统函数调用的区别在于系统调用能够让你直接访问linux内核提供的服务<br>系统调用函数存在于内核空间, 库函数都是用户模式, 所以系统调用不当可能会破坏系统, 但库函数调用风险就要小很多<br>库函数对I/O操作进行缓冲, 减少了系统调用开销, 同时移植性也更好</p>
</blockquote>
<h3 id="u6253_u5F00_u548C_u5173_u95ED_u6587_u4EF6"><a href="#u6253_u5F00_u548C_u5173_u95ED_u6587_u4EF6" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h3><pre><code>FILE *p fopen(const char *path, const char *mode);
int fclose(FILE *stream);
</code></pre><blockquote>
<p>fopen以mode模式打开名为path的文件<br>fopen 返回一个文件指针<br>出现错误, fopen返回NULL, 并把errno设置为恰当的值</p>
</blockquote>
<p>参数mode字符串则代表着流形态。<br>mode有下列几种形态字符串:</p>
<pre><code>r 打开只读文件，该文件必须存在。

r+ 打开可读写的文件，该文件必须存在。

rb+ 读写打开一个二进制文件，只允许读写数据。

rt+ 读写打开一个文本文件，允许读和写。

w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。

w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。

a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）

a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）

wb 只写打开或新建一个二进制文件；只允许写数据。

wb+ 读写打开或建立一个二进制文件，允许读和写。

wt+ 读写打开或着建立一个文本文件；允许读写。

at+ 读写打开一个文本文件，允许读或在文本末追加数据。

ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。
</code></pre><h3 id="u8BFB_u5199_u6587_u4EF6"><a href="#u8BFB_u5199_u6587_u4EF6" class="headerlink" title="读写文件"></a>读写文件</h3><pre><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(void *ptr, size_t size, size_t nmemb, FILE *stream);
</code></pre><blockquote>
<p>参数ptr指向缓冲区保存或读取的数据<br>参数size控制记录大小<br>参数nmemb为记录数<br>函数返回读取或回写的数据</p>
</blockquote>
<h4 id="C_u5E93_u51FD_u6570_u8BFB_u53D6_u6587_u4EF6_u7684_u4EE3_u7801"><a href="#C_u5E93_u51FD_u6570_u8BFB_u53D6_u6587_u4EF6_u7684_u4EE3_u7801" class="headerlink" title="C库函数读取文件的代码"></a>C库函数读取文件的代码</h4><pre><code>int main(int arg, char *args[])
{
    FILE *p = fopen(args[1], &quot;r+&quot;);
    if (p == NULL)
    {
        printf(&quot;error is %s\n&quot;, strerror(errno));
    }
    else
    {
        printf(&quot;success\n&quot;);
        char buf[100];
        size_t rc = 0;
        while(1)
        {
            size_t tmp = fread(buf, 1, sizeof(buf), p);//原则是第二个参数乘以第三个参数的大小不能超过缓冲区
            rc += tmp;
            if (tmp == 0)
                break;

        }
        printf(&quot;rc = %d\n&quot;, rc);
        fclose(p);
    }
    return 0;
}
</code></pre><h4 id="c_u5E93_u51FD_u6570_u8BFB_u5199_u4E8C_u8FDB_u5236_u6587_u4EF6_u7684_u4EE3_u7801"><a href="#c_u5E93_u51FD_u6570_u8BFB_u5199_u4E8C_u8FDB_u5236_u6587_u4EF6_u7684_u4EE3_u7801" class="headerlink" title="c库函数读写二进制文件的代码"></a>c库函数读写二进制文件的代码</h4><pre><code>struct person
{
    int id;
    char name[20];
    int age;
    int sex;
    char tel[20];
};

//以二进制的形式将信息写入文件中
int main(int arg, char *args[])
{
    FILE *p = fopen(args[1], &quot;w&quot;); //如果是Windows下,这里要使用&quot;wb&quot;
    if (p == NULL)
    {
        printf(&quot;error is %s\n&quot;, strerror(errno));
    } else
    {
        printf(&quot;success\n&quot;);
        struct person man[10];
        memset(&amp;man, 0, sizeof(man));

        man[0].id = 0;
        strcpy(man[0].name, &quot;苍井空&quot;);
        man[0].age = 50;
        man[0].sex = 1;
        strcpy(man[0].tel, &quot;911&quot;);

        man[1].id = 1;
        strcpy(man[1].name, &quot;饭岛爱&quot;);
        man[1].age = 20;
        man[1].sex = 0;
        strcpy(man[1].tel, &quot;119&quot;);

        fwrite(&amp;man, sizeof(struct person), 2, p);
        fclose(p);
    }
    return 0;
}
</code></pre><p>读取:</p>
<pre><code>int main(int arg, char *args[])
{
    FILE *p = fopen(args[1], &quot;w&quot;);
    if (p == NULL)
    {
        printf(&quot;error is %s\n&quot;, strerror(errno));
    } else
    {
        printf(&quot;success\n&quot;);
        struct person man;
        memset(&amp;man, 0, sizeof(man));

        while(fread(&amp;man, sizeof(struct person), 1, p))
        {
            printf(&quot;id=%d\n&quot;, man.id);
            printf(&quot;name=%s\n&quot;, man.name);
            printf(&quot;age=%d\n&quot;, man.age);
            printf(&quot;tel=%s\n&quot;, man.tel);
        }
        fclose(p);
    }
    return 0;
}
</code></pre><h3 id="u683C_u5F0F_u5316_u8F93_u5165_u548C_u8F93_u51FA"><a href="#u683C_u5F0F_u5316_u8F93_u5165_u548C_u8F93_u51FA" class="headerlink" title="格式化输入和输出"></a>格式化输入和输出</h3><pre><code>int fprintf(FILE *stream, const char *fornat, ...);
int fscanf(FILE *stream, const char *fornat, ...);
</code></pre><h3 id="u884C_u8F93_u5165_u548C_u884C_u8F93_u51FA"><a href="#u884C_u8F93_u5165_u548C_u884C_u8F93_u51FA" class="headerlink" title="行输入和行输出"></a>行输入和行输出</h3><pre><code>char fgets(char *s, int size, FILE *stream);
char fputs(const char *s, FILE *stream);
</code></pre><blockquote>
<p>fgets从文件中读取一行, 返回EOF代表文件结尾<br>fputs向文件中写入一行</p>
</blockquote>
<h3 id="u6587_u4EF6_u5220_u9664_u548C_u6539_u540D"><a href="#u6587_u4EF6_u5220_u9664_u548C_u6539_u540D" class="headerlink" title="文件删除和改名"></a>文件删除和改名</h3><pre><code>int remove(const char *pathname);
int rename(cnst char *oldpath, const char *newpath);
</code></pre><blockquote>
<p>remove函数删除pathname指向的文件名<br>rename函数修改文件名称<br>执行成功返回0, 失败返回-1, 错误码保存在变量errno中</p>
</blockquote>
<h4 id="u5199log_u7684_u4EE3_u7801"><a href="#u5199log_u7684_u4EE3_u7801" class="headerlink" title="写log的代码"></a>写log的代码</h4><pre><code>void writelog(const char *log)
{
    time_t tDate;
    struct tm *eventTime;
    time(&amp;tDate);//得到系统当前时间
    eventTime = localtime(&amp;tDate);//将time_t数据类型转化为struct tm结构
    int iYear = eventTime-&gt;tm_year + 1900;
    int iMon = eventTime-&gt;tm_mon + 1;
    int iDay = eventTime-&gt;tm_mday;
    int iHour = eventTime-&gt;tm_hour;
    int iMin = eventTime-&gt;tm_min;
    int iSec = eventTime-&gt;tm_sec;

    printf(&quot;tm_isdst = %d\n&quot;, eventTime-&gt;tm_isdst);

    char sDate[16];
    sprintf(sDate, &quot;%04d-%02d-%02d&quot;, iYear, iMon, iDay);
    char sTime[16];
    sprintf(sTime, &quot;%02d:%02d:%02d&quot;, iHour, iMin, iSec);
    char s[1024];
    sprintf(s, &quot;%s %s %s\n&quot;, sDate, sTime, log);
    FILE *p = fopen(&quot;my.log&quot;, &quot;a+&quot;);
    if (p == NULL)
    {
        printf(&quot;write log my.log error:%s\n&quot;, strerror(errno));
    }else
    {
        fputs(s, p);
        fclose(p);
    }
    return;
}
</code></pre><h3 id="u627E_u5230_u5F53_u524D_u76EE_u5F55"><a href="#u627E_u5230_u5F53_u524D_u76EE_u5F55" class="headerlink" title="找到当前目录"></a>找到当前目录</h3><pre><code>char *getcwd(char *buf, size_t size);
</code></pre><blockquote>
<p>getcwd函数把当前工作目录的据对路径名复制到buf中, size只是buf的大小<br>如果buf不够大,布恩那个装下整个路径名, getcwd返回NULL</p>
</blockquote>
<h3 id="u83B7_u5F97_u76EE_u5F55_u5217_u8868"><a href="#u83B7_u5F97_u76EE_u5F55_u5217_u8868" class="headerlink" title="获得目录列表"></a>获得目录列表</h3><ul>
<li>用opendir函数打开目录文件</li>
<li>用readdir函数读取目录文件内容</li>
<li>用closedir函数关闭目录文件</li>
<li>这些函数都在<dirent.h>中声明</dirent.h></li>
</ul>
<pre><code>DIR *opendir(const char *pathname);
struct dirent *readdir(DIR *dir);
int closedir(DIR *dir);
</code></pre><blockquote>
<p>opendir函数打开pathname指向的目录文件, 如果错误返回NULL</p>
</blockquote>
<h4 id="u8BFB_u76EE_u5F55_u7684_u793A_u4F8B"><a href="#u8BFB_u76EE_u5F55_u7684_u793A_u4F8B" class="headerlink" title="读目录的示例"></a>读目录的示例</h4><pre><code>int main(int arg, char *args[])
{
    if (arg &lt;2)
        return 0;

    DIR *dp;
    struct dirent *dirp;
    dp = opendir(args[1]);//打开目录文件
    if (dp == NULL)
    {
        printf(&quot;error is %s\n&quot;, strerror(errno));
        return 0;
    }

    while((dirp = readdir(dp)) != NULL)//用readdir循环读取目录内容，读到目录尾，循环break
    {
        printf(&quot;%s\n&quot;, dirp-&gt;d_name);//将目录下的文件名打印到屏幕

    }

    closedir(dp);//关闭目录

    return 0;
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/c/">c++</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Liux-内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/04/Liux-内存管理/" class="article-date">
  	<time datetime="2015-10-04T12:55:28.000Z" itemprop="datePublished">2015-10-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/04/Liux-内存管理/">Liux 内存管理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Linx_u7684_u5185_u5B58_u7BA1_u7406"><a href="#Linx_u7684_u5185_u5B58_u7BA1_u7406" class="headerlink" title="Linx的内存管理"></a>Linx的内存管理</h2><p>内存段: 一个进程被操作系统加载到内存后并不是加载到一段连续的内存空间, 而是至少分为三段或多段内存空间.<br><img src="http://7xlrdt.com1.z0.glb.clouddn.com/linux内存管理_1.jpg" alt=""></p>
<h3 id="u6808"><a href="#u6808" class="headerlink" title="栈"></a>栈</h3><ul>
<li>是一种先进后出的结构</li>
<li>就像往一个管子里放东西, 最后进去的先拿出来, 最先放进去的最后拿出来</li>
<li>栈空间有系统自动维护, 不需要通过代码申请或者释放</li>
</ul>
<pre><code>int abc()
{
    int a;    //在stack中放入一个int型变量a,abc函数退出的时候系统自动从stack中将a删除.
    return 0;
}
</code></pre><p>-</p>
<pre><code>int abc(int a, int b)//调用abc函数的时候在stack中放入两个int型变量a,b. b先入栈,a随后入栈.
{                    //abc函数退出的时候系统从stack中将a删除, 然后删除b
    return a+b;
}
</code></pre><blockquote>
<p>a和b是在函数调用前入栈还是在函数调用后入栈?? </p>
</blockquote>
<h4 id="stdcall_28standard_calling_29"><a href="#stdcall_28standard_calling_29" class="headerlink" title="_stdcall(standard calling)"></a>_stdcall(standard calling)</h4><ul>
<li>是Pascal默认调用函数方式;</li>
<li>参数从右向左压入栈</li>
<li>函数参数由被调用者压入或弹出栈</li>
</ul>
<h4 id="cdecl_28C_default_calling_29"><a href="#cdecl_28C_default_calling_29" class="headerlink" title="_cdecl(C default calling)"></a>_cdecl(C default calling)</h4><ul>
<li>是C/C++默认调用函数方式;</li>
<li>参数从右向左压入栈;</li>
<li>函数参数由被调用者压入或弹出栈</li>
</ul>
<pre><code>int _attribute_((stdcall) abc(int a, int b));
int _attribute_((cdecl) abc(int a, int b));
</code></pre><h3 id="u5806_28heap_29"><a href="#u5806_28heap_29" class="headerlink" title="堆(heap)"></a>堆(heap)</h3><ul>
<li>是一种动态的结构</li>
<li>堆在存取上没有栈那样严格的先进后出的顺序</li>
<li>堆就像一个大容器, 随时拿进来, 随时拿出去</li>
<li>堆空间需要malloc或者new申请或者释放</li>
</ul>
<pre><code>int abc()
{
    int *p = new int;    //堆中申请了一块int型内存
    delete p;            //释放堆中内存
    return a+b;
}
</code></pre><h3 id="u5185_u5B58_u7684_u5206_u914D_u548C_u91CA_u653E"><a href="#u5185_u5B58_u7684_u5206_u914D_u548C_u91CA_u653E" class="headerlink" title="内存的分配和释放"></a>内存的分配和释放</h3><ul>
<li>C语言用malloc、calloc、realloc、和free函数实现动态内存管理</li>
<li>C++语言用new、delete操作符实现动态内存管理</li>
<li>这些函数以及操作符可以让用户根据需要从操作系统堆(heap)中获取、使用和释放内存。</li>
<li>动态内存分配是编制高效率程序的基础</li>
<li>动态内存管理还可以能够把程序员从在代码中添加任意的限制中解放出来</li>
<li>用户不再人为的限制数组或者字符串的长度</li>
</ul>
<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>malloc函数分配没有被初始化过的内存块</p>
<pre><code>void* malloc(size_t size);
</code></pre><ul>
<li>参数size指定分配内存的字节数</li>
<li>返回值为指向新分配内存的指针, 如果失败返回NULL</li>
<li>一般需要检查malloc返回的值</li>
<li>使用malloc得到的内存必须再调用free释放给操作系统</li>
</ul>
<h4 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h4><p>calloc 函数分配内存并初始化内存块</p>
<pre><code>void* calloc(size_t nmemb, size_t size)
</code></pre><ul>
<li>功能与malloc非常相似, 函数返回一个指向半酣nmemb个元素的数组指针, 数组中每个元素的大小为size个字节</li>
<li>和malloc不同的是calloc对分配到的内存进行初始化, 把每个比特位设置为0</li>
<li>返回值为指向新分配内存的指针, 如果失败返回NULL</li>
</ul>
<h4 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h4><p>realloc函数改变以前分配的内存块的大小</p>
<pre><code>void* realloc(void *prt, size_t size)
</code></pre><ul>
<li>realloc可以调整以前由malloc或者calloc调用获得内存的大小</li>
<li>参数prt必须是由调用malloc或者calloc返回的内存指针</li>
<li>参数size既可以大于原来指针指向内存块大小, 也可以小于</li>
<li>增大或减小的操作是原地, 也就是相对于内存块当前地址地方进行的</li>
<li>如果不能这样做, realloc就把原来的数据复制到新的位置</li>
</ul>
<p>以下几点也适用于realloc函数:</p>
<blockquote>
<ul>
<li>realloc不对增加的内存块做初始化</li>
<li>realloc如果不能扩大内存块, 就返回NULL, 而且保持原来的数据不动</li>
<li>realloc的第一个参数如果为NULL, 则它的作用和malloc一样</li>
<li>realloc第二个参数如果是0, 那么就释放原来的内存块</li>
</ul>
</blockquote>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>free函数就是释放一块内存</p>
<pre><code>void free(void *prt)
</code></pre><ul>
<li>参数prt必须是调用malloc或者calloc返回的内存指针</li>
<li>内存分配函数从系统堆(heap)中获得内存, 内存作为一种有限资源可能会被用尽, 所以用完的内存一定要释放</li>
<li>悬空指针是在内存已经被释放后遗留下来未初始化的指针, 如果试图访问一个悬空指针, 系统会出现问题</li>
</ul>
<h4 id="new__u548C_delete_u64CD_u4F5C_u7B26"><a href="#new__u548C_delete_u64CD_u4F5C_u7B26" class="headerlink" title="new 和 delete操作符"></a>new 和 delete操作符</h4><ul>
<li>new 和 delete    操作符不是函数, 是C++内建的, 所以不需要包含头文件</li>
<li>new 返回为指向新分配内存的指针, 如果失败返回NULL</li>
<li>使用new得到的内存必须再调用delete释放给操作系统</li>
<li>malloc只可用于一般性质的内存申请和释放, 但new\delete不但可以为普通数据类型分配释放内存, 同时还可以为对象分配释放内存</li>
<li>new 分配的内存不能使用free函数来释放, 同样, malloc分配的内存不能使用delete来释放</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C/">C++</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-循环链表" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/02/循环链表/" class="article-date">
  	<time datetime="2015-10-02T14:06:43.000Z" itemprop="datePublished">2015-10-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/02/循环链表/">循环链表</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><p>循环链表的定义：将单链表中最后一个数据元素的next指针指向第一个元素<br>.<img src="http://7xlrdt.com1.z0.glb.clouddn.com/circle_list1.png" alt=""></p>
<h4 id="u5FAA_u73AF_u94FE_u8868_u62E5_u6709_u5355_u94FE_u8868_u7684_u6240_u6709_u64CD_u4F5C"><a href="#u5FAA_u73AF_u94FE_u8868_u62E5_u6709_u5355_u94FE_u8868_u7684_u6240_u6709_u64CD_u4F5C" class="headerlink" title="循环链表拥有单链表的所有操作"></a>循环链表拥有单链表的所有操作</h4><ul>
<li>创建链表</li>
<li>销毁链表</li>
<li>获取链表长度</li>
<li>清空链表</li>
<li>获取第pos个元素操作</li>
<li>插入元素到位置pos</li>
<li>删除位置pos处的元素</li>
</ul>
<h4 id="u65B0_u589E_u529F_u80FD_uFF1A_u6E38_u6807_u7684_u5B9A_u4E49"><a href="#u65B0_u589E_u529F_u80FD_uFF1A_u6E38_u6807_u7684_u5B9A_u4E49" class="headerlink" title="新增功能：游标的定义"></a>新增功能：游标的定义</h4><p>在循环链表中可以定义一个“当前”指针，这个指针通常称为游标，可以通过这个游标来遍历链表中的所有元素。<br><img src="http://7xlrdt.com1.z0.glb.clouddn.com/circulate_list2.png" alt=""></p>
<h4 id="u5FAA_u73AF_u94FE_u8868_u65B0_u64CD_u4F5C"><a href="#u5FAA_u73AF_u94FE_u8868_u65B0_u64CD_u4F5C" class="headerlink" title="循环链表新操作"></a>循环链表新操作</h4><pre><code>//直接指定删除链表中的某个数据元素
CircleListNode* CircleList_DeleteNode(CircleList* list, CircleListNode* node);
//将游标重置指向链表中的第一个数据元素
CircleListNode* CircleList_Reset(CircleList* list);
//获取当前游标指向的数据元素
CircleListNode* CircleList_Current(CircleList* list);
//将游标移动指向到链表中的下一个数据元素
CircleListNode* CircleList_Next(CircleList* list);
</code></pre><p>###设计与实现</p>
<hr>
<h4 id="u58F0_u660E"><a href="#u58F0_u660E" class="headerlink" title="声明"></a>声明</h4><pre><code>#ifndef _CIRCLELIST_H_
#define _CIRCLELIST_H_

typedef void CircleList;
/*
typedef struct _tag_CircleListNode CircleListNode;
struct _tag_CircleListNode
{
    CircleListNode* next;
};
*/

typedef struct _tag_CircleListNode
{
    struct _tag_CircleListNode * next;
}CircleListNode

CircleList* CircleList_Create();
void CircleList_Destory(CircleList* list);
void CircleList_Clear(CircleList* list);
int CircleList_Length(CircleList* list);
int CircleList_Insert(CircleList* list, CircleListNode* node,int pos);
CircleListNode* CircleList_Get(CircleList* list, int pos);
CircleListNode* CircleList_Delete(CircleList* list, int pos);
//add 
CircleListNode* CircleList_DeleteNode(CircleList* list, CirclListNode* node);
CircleListNode* CircleList_Reset(CircleList* list);
CircleListNode* CircleList_Current(CircleList* list);
CircleListNode* CircleList_Next(CircleList* list);
#endif
</code></pre><h4 id="u5B9E_u73B0"><a href="#u5B9E_u73B0" class="headerlink" title="实现"></a>实现</h4><h5 id="u5FAA_u73AF_u94FE_u8868_u7ED3_u6784_u4F53_u7684_u5B9A_u4E49"><a href="#u5FAA_u73AF_u94FE_u8868_u7ED3_u6784_u4F53_u7684_u5B9A_u4E49" class="headerlink" title="循环链表结构体的定义"></a>循环链表结构体的定义</h5><pre><code>typedef struct _tag_CircleList
{
    CircleListNode header;        //头结点
    CircleListNode* slider;        //游标
    int length;                    //长度
} TCircleList;
</code></pre><h5 id="u521B_u5EFA_u548C_u9500_u6BC1"><a href="#u521B_u5EFA_u548C_u9500_u6BC1" class="headerlink" title="创建和销毁"></a>创建和销毁</h5><pre><code>//循环链表的创建
CircleList* CircleList_Create() // O(1)
{
    TCircleList* ret = (TCircleList*)malloc(sizeof(TCircleList));
    if (ret == NULL)
    {
        return NULL;
    }

    ret-&gt;length = 0;
    ret-&gt;header.next = NULL;
    ret-&gt;slider = NULL;
    return ret;
}

//循环链表的销毁
void CircleList_Destroy(CircleList* list) // O(1)
{
    if (list == NULL)
    {
        return ;
    }
    free(list);
}

//清空链表
void CircleList_Clear(CircleList* list) // O(1)
{
    TCircleList* sList = (TCircleList*)list;
    if (sList == NULL)
    {
        return ;
    }
    sList-&gt;length = 0;
    sList-&gt;header.next = NULL;
    sList-&gt;slider = NULL;
}
</code></pre><h5 id="u957F_u5EA6_u7684_u83B7_u53D6"><a href="#u957F_u5EA6_u7684_u83B7_u53D6" class="headerlink" title="长度的获取"></a>长度的获取</h5><pre><code>int CircleList_Length(CircleList* list) // O(1)
{
    TCircleList* sList = (TCircleList*)list;
    int ret = -1;
    if (list == NULL)
    {
        return ret;
    }
    ret = sList-&gt;length;
    return ret;
}
</code></pre><h5 id="u94FE_u8868_u7684_u64CD_u4F5C"><a href="#u94FE_u8868_u7684_u64CD_u4F5C" class="headerlink" title="链表的操作"></a>链表的操作</h5><pre><code>//数据插入
int CircleList_Insert(CircleList* list, CircleListNode* node, int pos) // O(n)
{ 
    int ret = 0, i=0;
    TCircleList* sList = (TCircleList*)list;

    if (list == NULL || node== NULL || pos&lt;0)
    {
        return -1;
    }
    //if( ret )
    {
        CircleListNode* current = (CircleListNode*)sList;

        for(i=0; (i&lt;pos) &amp;&amp; (current-&gt;next != NULL); i++)
        {
            current = current-&gt;next;
        }

        //current-&gt;next 0号节点的地址
        node-&gt;next = current-&gt;next; //1
        current-&gt;next = node; //2

        //若第一次插入节点
        if( sList-&gt;length == 0 )
        {
            sList-&gt;slider = node;
        }

        sList-&gt;length++;

        //若头插法
        if( current == (CircleListNode*)sList )
        {
            //获取最后一个元素
            CircleListNode* last = CircleList_Get(sList, sList-&gt;length - 1); 
            last-&gt;next = current-&gt;next; //3
        }
    }

    return ret;
}

//根据位置获取节点元素    
CircleListNode* CircleList_Get(CircleList* list, int pos) // O(n)
{
    TCircleList* sList = (TCircleList*)list;
    CircleListNode* ret = NULL;
    int i = 0;

    if (list==NULL || pos&lt;0)
    {
        return NULL;
    }
    //if( (sList != NULL) &amp;&amp; (pos &gt;= 0) &amp;&amp; (sList-&gt;length &gt; 0) )
    {
        CircleListNode* current = (CircleListNode*)sList;

        for(i=0; i&lt;pos; i++)
        {
            current = current-&gt;next;
        }

        ret = current-&gt;next;
    }

    return ret;
}

//根据位置删除元素
CircleListNode* CircleList_Delete(CircleList* list, int pos) // O(n)
{
    TCircleList* sList = (TCircleList*)list;
    CircleListNode* ret = NULL;
    int i = 0;

    if( (sList != NULL) &amp;&amp; (pos &gt;= 0) &amp;&amp; (sList-&gt;length &gt; 0) )
    {
        CircleListNode* current = (CircleListNode*)sList;
        CircleListNode* last = NULL;

        for(i=0; i&lt;pos; i++)
        {
            current = current-&gt;next;
        }

        //若删除第一个元素
        if( current == (CircleListNode*)sList )
        {
            last = (CircleListNode*)CircleList_Get(sList, sList-&gt;length - 1);
        }

        //求要删除的元素
        ret = current-&gt;next;
        current-&gt;next = ret-&gt;next;

        sList-&gt;length--;

        //判断链表是否为空
        if( last != NULL )
        {
            sList-&gt;header.next = ret-&gt;next;
            last-&gt;next = ret-&gt;next;
        }

        //若删除的元素为游标所指的元素
        if( sList-&gt;slider == ret )
        {
            sList-&gt;slider = ret-&gt;next;
        }

        //若删除元素后，链表长度为0
        if( sList-&gt;length == 0 )
        {
            sList-&gt;header.next = NULL;
            sList-&gt;slider = NULL;
        }
    }

    return ret;
}

//根据具体元素来删除链表中的元素
CircleListNode* CircleList_DeleteNode(CircleList* list, CircleListNode* node) // O(n)
{
    TCircleList* sList = (TCircleList*)list;
    CircleListNode* ret = NULL;
    int i = 0;

    if( sList != NULL )
    {
        CircleListNode* current = (CircleListNode*)sList;

        //查找node在循环链表中的位置i
        for(i=0; i&lt;sList-&gt;length; i++)
        {
            if( current-&gt;next == node )
            {
                ret = current-&gt;next;
                break;
            }

            current = current-&gt;next;
        }

        //如果ret找到，根据i去删除    
        if( ret != NULL )
        {
            CircleList_Delete(sList, i);
        }
    }

    return ret;
}

CircleListNode* CircleList_Reset(CircleList* list) // O(1)
{
    TCircleList* sList = (TCircleList*)list;
    CircleListNode* ret = NULL;

    if( sList != NULL )
    {
        sList-&gt;slider = sList-&gt;header.next;
        ret = sList-&gt;slider;
    }

    return ret;
}

CircleListNode* CircleList_Current(CircleList* list) // O(1)
{
    TCircleList* sList = (TCircleList*)list;
    CircleListNode* ret = NULL;

    if( sList != NULL )
    {
        ret = sList-&gt;slider;
    }

    return ret;
}

CircleListNode* CircleList_Next(CircleList* list) // O(1)
{
    TCircleList* sList = (TCircleList*)list;
    CircleListNode* ret = NULL;

    if( (sList != NULL) &amp;&amp; (sList-&gt;slider != NULL) )
    {
        ret = sList-&gt;slider;
        sList-&gt;slider = ret-&gt;next;
    }

    return ret;
}
</code></pre><h3 id="u4F18_u70B9_u548C_u7F3A_u70B9"><a href="#u4F18_u70B9_u548C_u7F3A_u70B9" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><ul>
<li><p>优点：功能强了<br>循环链表只是在单链表的基础上做了一个加强<br>循环链表可以完全取代单链表的使用<br>循环链表的Next和Current操作可以高效的遍历链表中的所有元素</p>
</li>
<li><p>缺点：<br>代码复杂度提高了<br>约瑟夫问题-循环链表典型应用<br>n 个人围成一个圆圈，首先第 1 个人从 1 开始一个人一个人顺时针报数，报到第 m 个人，令其出列。然后再从下一 个人开始从 1 顺时针报数，报到第 m 个人，再令其出列，…，如此下去，求出列顺序。<br><img src="http://7xlrdt.com1.z0.glb.clouddn.com/circulate_list3.png" alt=""></p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线性表/">线性表</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C/">C++</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Bigtiger
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>